<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTPolyNet.molecule &#8212; HTPolyNet 1.0.6 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for HTPolyNet.molecule</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: molecule</span>
<span class="sd">   :synopsis: manages generation of molecular templates</span>
<span class="sd">   </span>
<span class="sd">.. moduleauthor: Cameron F. Abrams, &lt;cfa22@drexel.edu&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">import</span> <span class="nn">HTPolyNet.projectfilesystem</span> <span class="k">as</span> <span class="nn">pfs</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.topocoord</span> <span class="kn">import</span> <span class="n">TopoCoord</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.bondtemplate</span> <span class="kn">import</span> <span class="n">BondTemplate</span><span class="p">,</span><span class="n">BondTemplateList</span><span class="p">,</span><span class="n">ReactionBond</span><span class="p">,</span><span class="n">ReactionBondList</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.coordinates</span> <span class="kn">import</span> <span class="n">dfrotate</span><span class="p">,</span> <span class="n">GRX_ATTRIBUTES</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.ambertools</span> <span class="kn">import</span> <span class="n">GAFFParameterize</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.gromacs</span> <span class="kn">import</span> <span class="n">mdp_modify</span><span class="p">,</span><span class="n">gro_from_trr</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.command</span> <span class="kn">import</span> <span class="n">Command</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.reaction</span> <span class="kn">import</span> <span class="n">Reaction</span><span class="p">,</span> <span class="n">ReactionList</span><span class="p">,</span> <span class="n">reaction_stage</span><span class="p">,</span> <span class="n">generate_product_name</span><span class="p">,</span> <span class="n">reactant_resid_to_presid</span>

<span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_rotmat</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span><span class="n">radians</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_rotmat generates a rotation matrix that rotates coordinates around axis by radians</span>

<span class="sd">    :param axis: 0=x,1=y,2=z</span>
<span class="sd">    :type axis: int</span>
<span class="sd">    :param radians: angle measure</span>
<span class="sd">    :type radians: float</span>
<span class="sd">    :return: rotation matrix</span>
<span class="sd">    :rtype: np.ndarray(3,float)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">sr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
    <span class="n">cr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">cr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">sr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">sr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">cr</span>
    <span class="k">elif</span> <span class="n">axis</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">cr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">sr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="n">sr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">cr</span>
    <span class="k">elif</span> <span class="n">axis</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">cr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=-</span><span class="n">sr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">sr</span>
        <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">cr</span>
    <span class="k">return</span> <span class="n">R</span>

<div class="viewcode-block" id="yield_bonds"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.yield_bonds">[docs]</a><span class="k">def</span> <span class="nf">yield_bonds</span><span class="p">(</span><span class="n">R</span><span class="p">:</span><span class="n">Reaction</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">resid_mapper</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;yield_bonds for each bond pattern in the reaction R, yield the specific bond represented by this pattern in the molecule&#39;s topology</span>

<span class="sd">    :param R: a Reaction</span>
<span class="sd">    :type R: Reaction</span>
<span class="sd">    :param TC: molecule topology and coordinates</span>
<span class="sd">    :type TC: TopoCoord</span>
<span class="sd">    :param resid_mapper: dictionary that maps in-reactant resids to in-product resids</span>
<span class="sd">    :type resid_mapper: dict</span>
<span class="sd">    :yield: a reaction bond</span>
<span class="sd">    :rtype: ReactionBond</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nreactants</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bondrec</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="n">atom_keys</span><span class="o">=</span><span class="n">bondrec</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">order</span><span class="o">=</span><span class="n">bondrec</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_keys</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
        <span class="n">atomrecs</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_keys</span><span class="p">]</span>
        <span class="n">atom_names</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
        <span class="n">in_reactant_resids</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nreactants</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">in_product_resids</span><span class="o">=</span><span class="p">[</span><span class="n">resid_mapper</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">in_reactant_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_product_resids</span><span class="o">=</span><span class="p">[</span><span class="n">resid_mapper</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">in_reactant_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">atom_idx</span><span class="o">=</span><span class="p">[</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,{</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">in_product_resids</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">atom_names</span><span class="p">[</span><span class="n">x</span><span class="p">]})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_resnames</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">bystander_atomnames</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_bystanders</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">)</span>
        <span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_resnames</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">,</span><span class="n">onewaway_atomnames</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_oneaways</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">ReactionBond</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">,</span><span class="n">in_product_resids</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">)</span></div>

<div class="viewcode-block" id="yield_bonds_as_df"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.yield_bonds_as_df">[docs]</a><span class="k">def</span> <span class="nf">yield_bonds_as_df</span><span class="p">(</span><span class="n">R</span><span class="p">:</span><span class="n">Reaction</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">resid_mapper</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;yield_bonds_as_df returns a pandas DataFrame identifying all reaction bonds obtained by matching the reaction template bonds to instances in the molecule topology</span>

<span class="sd">    :param R: a Reaction</span>
<span class="sd">    :type R: Reaction</span>
<span class="sd">    :param TC: molecule topology and coordinates</span>
<span class="sd">    :type TC: TopoCoord</span>
<span class="sd">    :param resid_mapper: dictionary that maps in-reactant resids to in-product resids</span>
<span class="sd">    :type resid_mapper: dict</span>
<span class="sd">    :return: dataframe with all reaction bonds</span>
<span class="sd">    :rtype: pd.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">nreactants</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bondrec</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
        <span class="n">atom_keys</span><span class="o">=</span><span class="n">bondrec</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">order</span><span class="o">=</span><span class="n">bondrec</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_keys</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
        <span class="n">atomrecs</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_keys</span><span class="p">]</span>
        <span class="n">atom_names</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
        <span class="n">in_reactant_resids</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nreactants</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">in_product_resids</span><span class="o">=</span><span class="p">[</span><span class="n">resid_mapper</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">in_reactant_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_product_resids</span><span class="o">=</span><span class="p">[</span><span class="n">resid_mapper</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">in_reactant_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="p">[</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,{</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">in_product_resids</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">atom_names</span><span class="p">[</span><span class="n">x</span><span class="p">]})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">ri</span><span class="p">,</span><span class="n">rj</span><span class="o">=</span><span class="n">in_product_resids</span>
        <span class="n">row_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ai&#39;</span><span class="p">:[</span><span class="n">ai</span><span class="p">],</span><span class="s1">&#39;aj&#39;</span><span class="p">:[</span><span class="n">aj</span><span class="p">],</span><span class="s1">&#39;ri&#39;</span><span class="p">:[</span><span class="n">ri</span><span class="p">],</span><span class="s1">&#39;rj&#39;</span><span class="p">:[</span><span class="n">rj</span><span class="p">],</span><span class="s1">&#39;order&#39;</span><span class="p">:[</span><span class="n">order</span><span class="p">],</span><span class="s1">&#39;reactantName&#39;</span><span class="p">:[</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="p">]}</span>
        <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">bdf</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">row_dict</span><span class="p">)),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bdf</span></div>

<div class="viewcode-block" id="Molecule"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule">[docs]</a><span class="k">class</span> <span class="nc">Molecule</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">generator</span><span class="p">:</span><span class="n">Reaction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">origin</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="o">=</span><span class="n">name</span> <span class="c1"># stereoisomer parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">=</span><span class="n">TopoCoord</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">:</span><span class="n">Reaction</span><span class="o">=</span><span class="n">generator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">=</span><span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reaction_bonds</span><span class="p">:</span><span class="n">ReactionBondList</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bond_templates</span><span class="p">:</span><span class="n">BondTemplateList</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_relateds</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stereocenters</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># list of atomnames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">:</span><span class="nb">dict</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">Molecule</span><span class="p">)</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nconformers</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformers_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="o">=</span><span class="p">[]</span> <span class="c1"># just a list of gro file basenames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zrecs</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_reactant</span><span class="o">=</span><span class="kc">False</span>

<div class="viewcode-block" id="Molecule.New"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.New">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">New</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">mol_name</span><span class="p">,</span><span class="n">generator</span><span class="p">:</span><span class="n">Reaction</span><span class="p">,</span><span class="n">molrec</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;New generates a new, partially populated Molecule based on directives in the configuration input</span>

<span class="sd">        :param mol_name: name of molecule</span>
<span class="sd">        :type mol_name: str</span>
<span class="sd">        :param generator: reaction that generates this molecule, if applicable</span>
<span class="sd">        :type generator: Reaction</span>
<span class="sd">        :param molrec: dictionary of directive for this molecule, defaults to {}</span>
<span class="sd">        :type molrec: dict, optional</span>
<span class="sd">        :return: a new Molecule object</span>
<span class="sd">        :rtype: Molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="o">=</span><span class="bp">cls</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">mol_name</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">generator</span><span class="o">=</span><span class="n">generator</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">molrec</span><span class="p">:</span> <span class="k">return</span> <span class="n">M</span>
        <span class="n">M</span><span class="o">.</span><span class="n">symmetry_relateds</span><span class="o">=</span><span class="n">molrec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;symmetry_equivalent_atoms&#39;</span><span class="p">,[])</span>
        <span class="n">M</span><span class="o">.</span><span class="n">stereocenters</span><span class="o">=</span><span class="n">molrec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stereocenters&#39;</span><span class="p">,[])</span>
        <span class="c1"># expand list of stereocenters if any are in symmetry sets</span>
        <span class="n">extra_stereocenters</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">stc</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">stereocenters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="n">M</span><span class="o">.</span><span class="n">symmetry_relateds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stc</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">:</span>
                    <span class="n">sc_copy</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">sc_copy</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">stc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">sc_copy</span> <span class="ow">in</span> <span class="n">extra_stereocenters</span><span class="p">:</span>
                        <span class="n">extra_stereocenters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sc_copy</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">stereocenters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extra_stereocenters</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> stereocenters: </span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">stereocenters</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># generate shells for new stereoisomers</span>
        <span class="n">M</span><span class="o">.</span><span class="n">create_new_stereoisomers</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> stereoisomers: </span><span class="si">{</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">M</span><span class="o">.</span><span class="n">stereoisomers</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">M</span><span class="o">.</span><span class="n">conformers_dict</span><span class="o">=</span><span class="n">molrec</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;conformers&#39;</span><span class="p">,{})</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> conformers_dict </span><span class="si">{</span><span class="n">M</span><span class="o">.</span><span class="n">conformers_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span></div>

<div class="viewcode-block" id="Molecule.set_origin"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.set_origin">[docs]</a>    <span class="k">def</span> <span class="nf">set_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_origin sets the value of the origin member</span>

<span class="sd">        :param value: value</span>
<span class="sd">        :type value: anything</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="o">=</span><span class="n">value</span></div>

<div class="viewcode-block" id="Molecule.get_origin"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.get_origin">[docs]</a>    <span class="k">def</span> <span class="nf">get_origin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_origin returns the value of the origin member</span>

<span class="sd">        :return: value of origin member</span>
<span class="sd">        :rtype: anything</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span></div>

<div class="viewcode-block" id="Molecule.update_zrecs"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.update_zrecs">[docs]</a>    <span class="k">def</span> <span class="nf">update_zrecs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">zrecs</span><span class="p">,</span><span class="n">moldict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;update_zrecs updates the &quot;z-records&quot; based on z&#39;s declared in the input configuration file</span>

<span class="sd">        :param zrecs: zrecs extracted from configuration file for this molecule</span>
<span class="sd">        :type zrecs: dict</span>
<span class="sd">        :param moldict: dictionary of available molecules</span>
<span class="sd">        :type moldict: dicts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">replace_if_greater</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">matchattr</span><span class="o">=</span><span class="p">[],</span><span class="n">maxattr</span><span class="o">=</span><span class="p">[]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matchattr</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">maxattr</span><span class="p">:</span> <span class="k">return</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                <span class="n">matched</span><span class="o">=</span><span class="nb">all</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">==</span><span class="n">rec</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">matchattr</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">matched</span><span class="p">:</span>
                    <span class="n">replace</span><span class="o">=</span><span class="nb">all</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">&lt;</span><span class="n">rec</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">maxattr</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
                        <span class="n">D</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="n">D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Update zrecs in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> from </span><span class="si">{</span><span class="n">zrecs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">seq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span>
        <span class="k">for</span> <span class="n">zr</span> <span class="ow">in</span> <span class="n">zrecs</span><span class="p">:</span>
            <span class="n">resid</span><span class="o">=</span><span class="n">zr</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
            <span class="n">rname</span><span class="o">=</span><span class="n">seq</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span>
            <span class="n">target</span><span class="o">=</span><span class="n">moldict</span><span class="p">[</span><span class="n">rname</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">zrecs</span><span class="si">}</span><span class="s1"> -&gt;&#39;</span><span class="p">)</span>
            <span class="n">found</span><span class="o">=</span><span class="n">replace_if_greater</span><span class="p">(</span><span class="n">zr</span><span class="p">,</span><span class="n">target</span><span class="o">.</span><span class="n">zrecs</span><span class="p">,</span><span class="n">matchattr</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">,</span><span class="s1">&#39;atom&#39;</span><span class="p">],</span><span class="n">maxattr</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span> <span class="n">target</span><span class="o">.</span><span class="n">zrecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zr</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;-&gt; </span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">target</span><span class="o">.</span><span class="n">zrecs</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.determine_sequence"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.determine_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">determine_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">moldict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;determine_sequence recursively determine the sequence of a molecule using the network of reactions that must be executed to generate it from primitives</span>

<span class="sd">        :param moldict: dictionary of available molecules</span>
<span class="sd">        :type moldict: dict</span>
<span class="sd">        :return: list of resnames in order of sequence</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="p">]</span>
        <span class="n">R</span><span class="p">:</span><span class="n">Reaction</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span>
        <span class="n">thisseq</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">rid</span><span class="p">,</span><span class="n">rname</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parentname</span><span class="o">=</span><span class="n">moldict</span><span class="p">[</span><span class="n">rname</span><span class="p">]</span><span class="o">.</span><span class="n">parentname</span>
            <span class="n">thisseq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">moldict</span><span class="p">[</span><span class="n">parentname</span><span class="p">]</span><span class="o">.</span><span class="n">determine_sequence</span><span class="p">(</span><span class="n">moldict</span><span class="p">))</span>
            <span class="c1"># logger.debug(thisseq)</span>
        <span class="k">return</span> <span class="n">thisseq</span></div>
    
<div class="viewcode-block" id="Molecule.set_sequence_from_moldict"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.set_sequence_from_moldict">[docs]</a>    <span class="k">def</span> <span class="nf">set_sequence_from_moldict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">moldict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_sequence_from_moldict set the sequence of this molecule using the recursive determine_sequence method</span>

<span class="sd">        :param moldict: dictionary of available molecules</span>
<span class="sd">        :type moldict: dict</span>
<span class="sd">        :return: self</span>
<span class="sd">        :rtype: Molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">determine_sequence</span><span class="p">(</span><span class="n">moldict</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Molecule.set_sequence_from_coordinates"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.set_sequence_from_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">set_sequence_from_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_sequence Establish the sequence-list (residue names in order) based on resNum attributes in atom list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">gro_DataFrame</span><span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">)</span>
        <span class="n">trial_sequence</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">current_resid</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">adf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">ri</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span>
            <span class="n">rn</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ri</span><span class="o">!=</span><span class="n">current_resid</span><span class="p">:</span>
                <span class="n">current_resid</span><span class="o">=</span><span class="n">ri</span>
                <span class="n">trial_sequence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rn</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">trial_sequence</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;trial </span><span class="si">{</span><span class="n">trial_sequence</span><span class="si">}</span><span class="s1"> seq </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Molecule.create_new_stereoisomers"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.create_new_stereoisomers">[docs]</a>    <span class="k">def</span> <span class="nf">create_new_stereoisomers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create_new_stereoisomers generate new molecules to hold stereoisomers of self</span>

<span class="sd">        :return: None if no action taken</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">:</span> <span class="k">return</span>  <span class="c1"># we only consider stereoisomers on monomers</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereocenters</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">basename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;-S&#39;</span>
        <span class="n">b</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stereocenters</span><span class="p">))]</span>
        <span class="n">sseq</span><span class="o">=</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">sseq</span><span class="p">)</span> <span class="c1"># skip the unmodified; it&#39;s the base molecule</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sseq</span><span class="p">:</span>
            <span class="n">s</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
            <span class="n">mname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">basename</span><span class="si">}{</span><span class="n">s</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">[</span><span class="n">mname</span><span class="p">]</span><span class="o">=</span><span class="n">Molecule</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">mname</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">[</span><span class="n">mname</span><span class="p">]</span><span class="o">.</span><span class="n">parentname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>
            
<div class="viewcode-block" id="Molecule.initialize_molecule_cycles"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.initialize_molecule_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_molecule_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initialize_molecule_cycles assigns cycle indexes to all atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">cycle_dict</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">detect_cycles</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">cs_of_l</span> <span class="ow">in</span> <span class="n">cycle_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cs_of_l</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Resetting cycle and cycle_idx&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">reset_grx_attributes_from_idx_list</span><span class="p">(</span><span class="s1">&#39;cycle&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Done&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.initialize_monomer_grx_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.initialize_monomer_grx_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_monomer_grx_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initialize_monomer_grx_attributes initializes all GRX attributes of atoms in molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;molecule&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;molecule_name&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sea_idx&#39;</span><span class="p">,</span><span class="s1">&#39;chain&#39;</span><span class="p">,</span><span class="s1">&#39;chain_idx&#39;</span><span class="p">,</span><span class="s1">&#39;cycle&#39;</span><span class="p">,</span><span class="s1">&#39;cycle_idx&#39;</span><span class="p">]:</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="n">att</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># set symmetry class indices</span>
        <span class="n">sea_idx</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">: symmetry_relateds </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">symmetry_relateds</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_relateds</span><span class="p">:</span>
            <span class="c1"># logger.debug(f&#39;sea_idx {sea_idx} set for set {s}&#39;)</span>
            <span class="k">for</span> <span class="n">atomName</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="c1"># logger.debug(f&#39;{atomName} {sea_idx}&#39;)</span>
                <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;sea_idx&#39;</span><span class="p">,</span><span class="n">sea_idx</span><span class="p">,{</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">atomName</span><span class="p">})</span>
            <span class="n">sea_idx</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c1"># set z and nreactions</span>
        <span class="n">idx</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">zr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zrecs</span><span class="p">:</span>
            <span class="n">an</span><span class="o">=</span><span class="n">zr</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span>
            <span class="n">rnum</span><span class="o">=</span><span class="n">zr</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rnum</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">z</span><span class="o">=</span><span class="n">zr</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> setting z for </span><span class="si">{</span><span class="n">an</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">rnum</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="n">z</span><span class="p">,{</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">an</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">rnum</span><span class="p">})</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,{</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">an</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">rnum</span><span class="p">}))</span>
            <span class="k">for</span> <span class="n">sr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetry_relateds</span><span class="p">:</span>
                <span class="c1"># logger.debug(f&#39;{self.name}: setting z for {an}, considering sr {sr}&#39;)</span>
                <span class="k">if</span> <span class="n">an</span> <span class="ow">in</span> <span class="n">sr</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">bn</span> <span class="ow">in</span> <span class="n">sr</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">bn</span><span class="o">==</span><span class="n">an</span><span class="p">:</span> <span class="k">continue</span>
                        <span class="c1"># logger.debug(f&#39;{self.name}: setting z for {bn}&#39;)</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,{</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">bn</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">rnum</span><span class="p">}))</span>
                        <span class="n">TC</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="n">z</span><span class="p">,{</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">bn</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">rnum</span><span class="p">})</span>

        <span class="c1"># set chain, chain_idx</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pairs</span><span class="o">=</span><span class="n">product</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">j</span><span class="p">:</span>
                <span class="n">iname</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
                <span class="n">jname</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
                <span class="k">if</span> <span class="n">TC</span><span class="o">.</span><span class="n">are_bonded</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">and</span> <span class="n">iname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">jname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
                    <span class="c1"># this monomer has two carbon atoms capable of reacting</span>
                    <span class="c1"># that are bound to each other -- this means that</span>
                    <span class="c1"># the two originated as a double-bond.</span>
                    <span class="c1"># *If* there is one with three hydrogens</span>
                    <span class="c1"># (remember this is an activated monomer)</span>
                    <span class="c1"># then it is the &quot;tail&quot;; the other is the &quot;head&quot;.</span>
                    <span class="n">i_nH</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">count_H</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">j_nH</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">count_H</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i_nH</span><span class="o">==</span><span class="mi">3</span> <span class="ow">and</span> <span class="n">j_nH</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># i is the tail</span>
                        <span class="n">entry</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">i_nH</span><span class="o">!=</span><span class="mi">3</span> <span class="ow">and</span> <span class="n">j_nH</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># j is the tail</span>
                        <span class="n">entry</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;In molecule </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">, cannot identify bonded reactive head and tail atoms</span><span class="se">\n</span><span class="s1">Assuming </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> is head and </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> is tail&#39;</span><span class="p">)</span>
                        <span class="n">entry</span><span class="o">=</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># logger.debug(f&#39;Adding {entry} to chainlist of {self.name}&#39;)</span>
                    <span class="n">TC</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">reset_grx_attributes_from_idx_list</span><span class="p">(</span><span class="s1">&#39;chain&#39;</span><span class="p">)</span>
        <span class="c1"># set cycle, cycle_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_molecule_cycles</span><span class="p">()</span></div>

<div class="viewcode-block" id="Molecule.previously_parameterized"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.previously_parameterized">[docs]</a>    <span class="k">def</span> <span class="nf">previously_parameterized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;previously_parameterized if a gro file exists in the project molecule/parameterized directory for this molecule, return True</span>

<span class="sd">        :return: True if gro file found</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rval</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">]:</span>
            <span class="n">rval</span><span class="o">=</span><span class="n">rval</span> <span class="ow">and</span> <span class="n">pfs</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;molecules/parameterized&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rval</span></div>

<div class="viewcode-block" id="Molecule.parameterize"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.parameterize">[docs]</a>    <span class="k">def</span> <span class="nf">parameterize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">input_structure_format</span><span class="o">=</span><span class="s1">&#39;mol2&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;parameterize manages GAFF parameterization of this molecule</span>

<span class="sd">        :param outname: output file basename, defaults to &#39;&#39;</span>
<span class="sd">        :type outname: str, optional</span>
<span class="sd">        :param input_structure_format: input structure format, defaults to &#39;mol2&#39; (&#39;pdb&#39; is other possibility)</span>
<span class="sd">        :type input_structure_format: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">input_structure_format</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;Cannot parameterize molecule </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> without </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">input_structure_format</span><span class="si">}</span><span class="s1"> as input&#39;</span>
        <span class="k">if</span> <span class="n">outname</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">outname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">GAFFParameterize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">outname</span><span class="p">,</span><span class="n">input_structure_format</span><span class="o">=</span><span class="n">input_structure_format</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_top_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outname</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outname</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">,</span><span class="n">mol2filename</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outname</span><span class="si">}</span><span class="s1">.mol2&#39;</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.minimize"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.minimize">[docs]</a>    <span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;minimize manages invocation of vacuum minimization</span>

<span class="sd">        :param outname: output file basename, defaults to &#39;&#39;</span>
<span class="sd">        :type outname: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">outname</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">outname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">vacuum_minimize</span><span class="p">(</span><span class="n">outname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.relax"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.relax">[docs]</a>    <span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">relax_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;relax manages invocation of MD relaxations</span>

<span class="sd">        :param relax_dict: dictionary of simulation directives</span>
<span class="sd">        :type relax_dict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deffnm</span><span class="o">=</span><span class="n">relax_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;deffnm&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">-relax&#39;</span><span class="p">)</span>
        <span class="n">nsteps</span><span class="o">=</span><span class="n">relax_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nsteps&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">temperature</span><span class="o">=</span><span class="n">relax_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;temperature&#39;</span><span class="p">,</span><span class="mi">10000</span><span class="p">)</span>
        <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">boxsize</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">maxspan</span><span class="p">())</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_coords</span><span class="p">(</span><span class="n">new_boxsize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span>
        <span class="n">mdp_prefix</span><span class="o">=</span><span class="s1">&#39;single-molecule-nvt&#39;</span>
        <span class="n">pfs</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mdp/</span><span class="si">{</span><span class="n">mdp_prefix</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
        <span class="n">mdp_modify</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mdp_prefix</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">,{</span><span class="s1">&#39;nsteps&#39;</span><span class="p">:</span><span class="n">nsteps</span><span class="p">,</span><span class="s1">&#39;gen-vel&#39;</span><span class="p">:</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span><span class="s1">&#39;ref_t&#39;</span><span class="p">:</span><span class="n">temperature</span><span class="p">,</span><span class="s1">&#39;gen-temp&#39;</span><span class="p">:</span><span class="n">temperature</span><span class="p">})</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;In vacuo equilibration of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.gro for </span><span class="si">{</span><span class="n">nsteps</span><span class="si">}</span><span class="s1"> steps at </span><span class="si">{</span><span class="n">temperature</span><span class="si">}</span><span class="s1"> K&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">deffnm</span><span class="p">,</span><span class="n">mdp</span><span class="o">=</span><span class="n">mdp_prefix</span><span class="p">,</span><span class="n">boxSize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.center_coords"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.center_coords">[docs]</a>    <span class="k">def</span> <span class="nf">center_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_boxsize</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;center_coords wrapper for the TopoCoord.center_coords method</span>

<span class="sd">        :param new_boxsize: new box size, defaults to None</span>
<span class="sd">        :type new_boxsize: np.ndarray, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">center_coords</span><span class="p">(</span><span class="n">new_boxsize</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.generate"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">available_molecules</span><span class="o">=</span><span class="p">{},</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;generate manages generating topology and coordinates for self</span>

<span class="sd">        :param outname: output file basename, defaults to &#39;&#39;</span>
<span class="sd">        :type outname: str, optional</span>
<span class="sd">        :param available_molecules: dictionary of available molecules, defaults to {}</span>
<span class="sd">        :type available_molecules: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.generate() begins&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outname</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="n">outname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">do_minimization</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">GAFF_dict</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;GAFF&#39;</span><span class="p">,{})</span>
        <span class="k">if</span> <span class="n">GAFF_dict</span><span class="p">:</span> <span class="n">do_minimization</span><span class="o">=</span><span class="n">GAFF_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;minimize_molecules&#39;</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">do_parameterization</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">:</span>
            <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span>
            <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">stage</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">,</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">param</span><span class="p">,</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cap</span><span class="p">]:</span> <span class="n">do_parameterization</span><span class="o">=</span><span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">=</span><span class="n">TopoCoord</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using reaction </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">stage</span><span class="p">)</span><span class="si">}</span><span class="s1">) to generate </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> parent </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">isf</span><span class="o">=</span><span class="s1">&#39;mol2&#39;</span>
            <span class="n">resid_mapper</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adding </span><span class="si">{</span><span class="n">ri</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">new_reactant</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">available_molecules</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span>
                <span class="n">new_reactant</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_mol2</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">-reactant</span><span class="si">{</span><span class="n">ri</span><span class="si">}</span><span class="s1">-prebonding.mol2&#39;</span><span class="p">,</span><span class="n">molname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">rnr</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_reactant</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span>
                <span class="n">shifts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">new_reactant</span><span class="o">.</span><span class="n">TopoCoord</span><span class="p">)</span>
                <span class="c1"># for ln in self.TopoCoord.Coordinates.A.head().to_string().split(&#39;\n&#39;): logger.debug(ln)</span>
                <span class="n">resid_mapper</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">rnr</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">shifts</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="o">+</span><span class="n">rnr</span><span class="o">+</span><span class="n">shifts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))})</span>
            <span class="c1"># logger.debug(f&#39;{self.name}: resid_mapper {resid_mapper}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;{self.TopoCoord.idx_lists}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;\n{self.TopoCoord.Coordinates.A.to_string()}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;composite prebonded molecule in box {self.TopoCoord.Coordinates.box}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_mol2</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">-prebonding.mol2&#39;</span><span class="p">,</span><span class="n">molname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_sequence_from_coordinates</span><span class="p">()</span>
            <span class="c1"># bonds_to_make=list(yield_bonds(R,self.TopoCoord,resid_mapper))</span>
            <span class="n">bdf</span><span class="o">=</span><span class="n">yield_bonds_as_df</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">resid_mapper</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;Generation of {self.name}: composite molecule has {len(self.sequence)} resids&#39;)</span>
            <span class="c1"># logger.debug(f&#39;generation of {self.name}: composite molecule:\n{composite_mol.TopoCoord.Coordinates.A.to_string()}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">make_bonds</span><span class="p">(</span><span class="n">bdf</span><span class="p">,</span><span class="n">available_molecules</span><span class="p">,</span><span class="n">R</span><span class="o">.</span><span class="n">stage</span><span class="p">)</span>
            <span class="c1"># self.TopoCoord.set_gro_attribute(&#39;reactantName&#39;,R.product)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;sea_idx&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># turn off symmetry-equivalence for multimers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;molecule&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;molecule_name&#39;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_gro_attributes</span><span class="p">(</span><span class="n">GRX_ATTRIBUTES</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="si">}</span><span class="s1">.grx&#39;</span><span class="p">)</span>
            <span class="c1"># if pfs.exists(f&#39;molecules/inputs/{self.name}.mol2&#39;): # an override structure is present</span>
            <span class="c1">#     logger.debug(f&#39;Using override input molecules/inputs/{self.name}.{isf} as a generator&#39;)</span>
            <span class="c1">#     pfs.checkout(f&#39;molecules/inputs/{self.name}.{isf}&#39;)</span>
            <span class="c1"># else:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_mol2</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.mol2&#39;</span><span class="p">,</span><span class="n">molname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">do_parameterization</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">,</span><span class="n">grotitle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_top</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">)</span>
            <span class="c1"># if pfs.exists(f&#39;molecules/inputs/{self.name}.pdb&#39;): # an override structure is present</span>
            <span class="c1">#     isf=&#39;pdb&#39;</span>
            <span class="c1">#     logger.debug(f&#39;Using override input molecules/inputs/{self.name}.{isf} as a generator&#39;)</span>
            <span class="c1">#     pfs.checkout(f&#39;molecules/inputs/{self.name}.{isf}&#39;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this molecule was not assigned a generator: implies it is a monomer and must have a parameterization</span>
            <span class="n">input_structure_formats</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mol2&#39;</span><span class="p">,</span><span class="s1">&#39;pdb&#39;</span><span class="p">]</span>
            <span class="n">isf</span><span class="o">=</span><span class="kc">None</span>
            <span class="k">for</span> <span class="n">isf</span> <span class="ow">in</span> <span class="n">input_structure_formats</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pfs</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;molecules/inputs/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">isf</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using input molecules/inputs/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">isf</span><span class="si">}</span><span class="s1"> as a generator&#39;</span><span class="p">)</span>
                    <span class="n">pfs</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;molecules/inputs/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">isf</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">assert</span> <span class="n">isf</span><span class="p">,</span><span class="s1">&#39;Error: no valid input structure file found&#39;</span>
            <span class="n">do_parameterization</span><span class="o">=</span><span class="kc">True</span>

        <span class="n">reactantName</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">do_parameterization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameterize</span><span class="p">(</span><span class="n">outname</span><span class="p">,</span><span class="n">input_structure_format</span><span class="o">=</span><span class="n">isf</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Built </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> using topology of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="si">}</span><span class="s1">; copying </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="si">}</span><span class="s1">.top to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load_top_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">)</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="si">}</span><span class="s1">.grx&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.grx&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_minimization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">outname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_sequence_from_coordinates</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">generator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="s1">&#39;reactantName&#39;</span><span class="p">,</span><span class="n">reactantName</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initialize_monomer_grx_attributes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_gro_attributes</span><span class="p">(</span><span class="n">GRX_ATTRIBUTES</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">reactantName</span><span class="si">}</span><span class="s1">.grx&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">do_parameterization</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">parentname</span><span class="p">:</span>
                <span class="n">grx</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">reactantName</span><span class="si">}</span><span class="s1">.grx&#39;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">grx</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">read_gro_attributes</span><span class="p">(</span><span class="n">grx</span><span class="p">)</span>
                <span class="c1">#self.reset_chains_from_attributes()</span>
        <span class="c1"># logger.debug(f&#39;{self.name} gro\n{self.TopoCoord.Coordinates.A.to_string()}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prepare_new_bonds</span><span class="p">(</span><span class="n">available_molecules</span><span class="o">=</span><span class="n">available_molecules</span><span class="p">)</span>
        <span class="c1"># for ln in self.TopoCoord.Coordinates.A.head().to_string().split(&#39;\n&#39;): logger.debug(ln)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_molecular_weight</span><span class="p">()</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> g/mol&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Done.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.get_molecular_weight"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.get_molecular_weight">[docs]</a>    <span class="k">def</span> <span class="nf">get_molecular_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_molecular_weight returns the molecular weight of self</span>

<span class="sd">        :return: _description_</span>
<span class="sd">        :rtype: _type_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mass</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">total_mass</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;gromacs&#39;</span><span class="p">)</span> <span class="c1"># g</span>
        <span class="k">return</span> <span class="n">mass</span></div>

<div class="viewcode-block" id="Molecule.prepare_new_bonds"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.prepare_new_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_new_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">available_molecules</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;prepare_new_bonds populates the bond templates and reaction bonds for self</span>

<span class="sd">        :param available_molecules: dictionary of available molecules, defaults to {}</span>
<span class="sd">        :type available_molecules: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(f&#39;set_reaction_bonds: molecules {list(available_molecules.keys())}&#39;)</span>
        <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generator</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">R</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reaction_bonds</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bond_templates</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="c1"># logger.debug(f&#39;prepare_new_bonds {self.name}: chainlists {TC.idx_lists[&quot;chain&quot;]}&#39;)</span>
        <span class="k">for</span> <span class="n">bondrec</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="n">atom_keys</span><span class="o">=</span><span class="n">bondrec</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
            <span class="n">order</span><span class="o">=</span><span class="n">bondrec</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_keys</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
            <span class="n">atomrecs</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_keys</span><span class="p">]</span>
            <span class="n">atom_names</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
            <span class="n">reactant_keys</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;reactant&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
            <span class="n">in_reactant_resids</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atomrecs</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">reactant_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">reactant_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># this is an intraresidue bond</span>
                <span class="n">reactant_names</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">[</span><span class="n">reactant_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reactant_names</span><span class="o">=</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reactant_keys</span><span class="p">]</span>
            <span class="n">reactant_sequences</span><span class="o">=</span><span class="p">[</span><span class="n">available_molecules</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">sequence</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">reactant_names</span><span class="p">]</span>
            <span class="n">product_sequence</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">reactant_sequences</span><span class="p">:</span>
                <span class="n">product_sequence</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;product_sequence {product_sequence}&#39;)</span>
            <span class="n">sequence_residue_idx_origins</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reactant_sequences</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">sequence_residue_idx_origins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">reactant_sequences</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">in_product_resids</span><span class="o">=</span><span class="p">[</span><span class="n">in_reactant_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+</span><span class="n">sequence_residue_idx_origins</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># logger.debug(f&#39;in_product_resids {in_product_resids}&#39;)</span>
            <span class="n">in_product_resnames</span><span class="o">=</span><span class="p">[</span><span class="n">product_sequence</span><span class="p">[</span><span class="n">in_product_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">atom_idx</span><span class="o">=</span><span class="p">[</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,{</span><span class="s1">&#39;resNum&#39;</span><span class="p">:</span><span class="n">in_product_resids</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">atom_names</span><span class="p">[</span><span class="n">x</span><span class="p">]})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># logger.debug(f&#39;{R.name} names {atom_names} in_product_resids {in_product_resids} idx {atom_idx}&#39;)</span>
            <span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_resnames</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">bystander_atomnames</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_bystanders</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">)</span>
            <span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_resnames</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">,</span><span class="n">oneaway_atomnames</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_oneaways</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;{self.name} bystanders {bystander_resids} {bystander_resnames} {bystander_atomidx} {bystander_atomnames}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;{self.name} oneaways {oneaway_resids} {oneaway_resnames} {oneaway_atomidx} {oneaway_atomnames}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reaction_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ReactionBond</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">,</span><span class="n">in_product_resids</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">))</span>
            <span class="n">intraresidue</span><span class="o">=</span><span class="n">in_product_resids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">in_product_resids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bond_templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BondTemplate</span><span class="p">(</span><span class="n">atom_names</span><span class="p">,</span><span class="n">in_product_resnames</span><span class="p">,</span><span class="n">intraresidue</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">bystander_resnames</span><span class="p">,</span><span class="n">bystander_atomnames</span><span class="p">,</span><span class="n">oneaway_resnames</span><span class="p">,</span><span class="n">oneaway_atomnames</span><span class="p">))</span></div>

<div class="viewcode-block" id="Molecule.idx_mappers"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.idx_mappers">[docs]</a>    <span class="k">def</span> <span class="nf">idx_mappers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">otherTC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">other_bond</span><span class="p">,</span><span class="n">bystanders</span><span class="p">,</span><span class="n">oneaways</span><span class="p">,</span><span class="n">uniq_atom_idx</span><span class="p">:</span><span class="nb">set</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;idx_mappers computes the mapping dictionary from molecule template index to instance index in the other TopoCoord</span>

<span class="sd">        :param otherTC: the other TopoCoord</span>
<span class="sd">        :type otherTC: TopoCoord</span>
<span class="sd">        :param other_bond: 2 atom indices of the bond in the other TopoCoord</span>
<span class="sd">        :type other_bond: list-like container of length 2</span>
<span class="sd">        :param bystanders: bystander lists, one for each reacting atom</span>
<span class="sd">        :type bystanders: lists</span>
<span class="sd">        :param oneaways: oneaways, one for each atom in the bond</span>
<span class="sd">        :type oneaways: list (2)</span>
<span class="sd">        :param uniq_atom_idx: set of unique atoms in template that must be mapped to instance</span>
<span class="sd">        :type uniq_atom_idx: set</span>
<span class="sd">        :raises Exception: if there is a buggy double-counting of one or more indexes</span>
<span class="sd">        :return: two-way dictionaries of index mappers instance&lt;-&gt;template</span>
<span class="sd">        :rtype: tuple of two dictionaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_bond</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">bystanders</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">oneaways</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span>
        <span class="n">ut</span><span class="o">=</span><span class="n">uniq_atom_idx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Template name </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">i_idx</span><span class="p">,</span><span class="n">j_idx</span><span class="o">=</span><span class="n">other_bond</span>
        <span class="n">i_resName</span><span class="p">,</span><span class="n">i_resNum</span><span class="p">,</span><span class="n">i_atomName</span><span class="o">=</span><span class="n">otherTC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">([</span><span class="s1">&#39;resName&#39;</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">],{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">i_idx</span><span class="p">})</span>
        <span class="n">j_resName</span><span class="p">,</span><span class="n">j_resNum</span><span class="p">,</span><span class="n">j_atomName</span><span class="o">=</span><span class="n">otherTC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">([</span><span class="s1">&#39;resName&#39;</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">],{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j_idx</span><span class="p">})</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;i_idx </span><span class="si">{</span><span class="n">i_idx</span><span class="si">}</span><span class="s1"> i_resName </span><span class="si">{</span><span class="n">i_resName</span><span class="si">}</span><span class="s1"> i_resNum </span><span class="si">{</span><span class="n">i_resNum</span><span class="si">}</span><span class="s1"> i_atomName </span><span class="si">{</span><span class="n">i_atomName</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;j_idx </span><span class="si">{</span><span class="n">j_idx</span><span class="si">}</span><span class="s1"> j_resName </span><span class="si">{</span><span class="n">j_resName</span><span class="si">}</span><span class="s1"> j_resNum </span><span class="si">{</span><span class="n">j_resNum</span><span class="si">}</span><span class="s1"> j_atomName </span><span class="si">{</span><span class="n">j_atomName</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># identify the template bond represented by the other_bond parameter</span>
        <span class="n">ij</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">RB</span><span class="p">,</span><span class="n">BT</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reaction_bonds</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bond_templates</span><span class="p">):</span>
            <span class="n">temp_resids</span><span class="o">=</span><span class="n">RB</span><span class="o">.</span><span class="n">resids</span>
            <span class="n">temp_iname</span><span class="p">,</span><span class="n">temp_jname</span><span class="o">=</span><span class="n">BT</span><span class="o">.</span><span class="n">names</span>
            <span class="n">temp_iresname</span><span class="p">,</span><span class="n">temp_jresname</span><span class="o">=</span><span class="n">BT</span><span class="o">.</span><span class="n">resnames</span>
            <span class="n">temp_bystander_resids</span><span class="o">=</span><span class="n">RB</span><span class="o">.</span><span class="n">bystander_resids</span>
            <span class="n">temp_oneaway_resids</span><span class="o">=</span><span class="n">RB</span><span class="o">.</span><span class="n">oneaway_resids</span>
            <span class="c1"># logger.debug(f&#39;temp_iresname {temp_iresname} temp_iname {temp_iname}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;temp_jresname {temp_jresname} temp_jname {temp_jname}&#39;)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i_atomName</span><span class="p">,</span><span class="n">i_resName</span><span class="p">)</span><span class="o">==</span><span class="p">(</span><span class="n">temp_iname</span><span class="p">,</span><span class="n">temp_iresname</span><span class="p">):</span>
                <span class="n">ij</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span> <span class="c1"># found it -- stop looking</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">i_atomName</span><span class="p">,</span><span class="n">i_resName</span><span class="p">)</span><span class="o">==</span><span class="p">(</span><span class="n">temp_jname</span><span class="p">,</span><span class="n">temp_jresname</span><span class="p">):</span>
                <span class="n">ij</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ij</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Mappers using template </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> unable to map from instance bond </span><span class="si">{</span><span class="n">i_resName</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">i_resNum</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">i_atomName</span><span class="si">}</span><span class="s1">---</span><span class="si">{</span><span class="n">j_resName</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j_resNum</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j_atomName</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">inst_resids</span><span class="o">=</span><span class="p">[</span><span class="n">i_resNum</span><span class="p">,</span><span class="n">j_resNum</span><span class="p">]</span>
        <span class="n">inst_resids</span><span class="o">=</span><span class="p">[</span><span class="n">inst_resids</span><span class="p">[</span><span class="n">ij</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">inst_bystander_resids</span><span class="o">=</span><span class="p">[</span><span class="n">bystanders</span><span class="p">[</span><span class="n">ij</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">inst_oneaway_resids</span><span class="o">=</span><span class="p">[</span><span class="n">oneaways</span><span class="p">[</span><span class="n">ij</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">inst_bystander_resids</span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">temp_bystander_resids</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]),</span><span class="sa">f</span><span class="s1">&#39;Error: bystander count mismatch&#39;</span>
           <span class="c1"># use dataframe merges to create globalIdx maps</span>
        <span class="n">instdf</span><span class="o">=</span><span class="n">otherTC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">tempdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">inst2temp</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">temp2inst</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1"># logger.debug(f&#39;inst resids from {[i_resNum,j_resNum,*inst_bystanders]}&#39;) </span>
        <span class="c1"># logger.debug(f&#39;temp resids from {[temp_iresid,temp_jresid,*temp_bystanders]}&#39;)</span>
        <span class="k">for</span> <span class="n">inst</span><span class="p">,</span><span class="n">temp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="o">*</span><span class="n">inst_resids</span><span class="p">,</span><span class="o">*</span><span class="n">inst_bystander_resids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">*</span><span class="n">inst_bystander_resids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">*</span><span class="n">inst_oneaway_resids</span><span class="p">],</span>
                             <span class="p">[</span><span class="o">*</span><span class="n">temp_resids</span><span class="p">,</span><span class="o">*</span><span class="n">temp_bystander_resids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">*</span><span class="n">temp_bystander_resids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">*</span><span class="n">temp_oneaway_resids</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">inst</span> <span class="ow">and</span> <span class="n">temp</span><span class="p">:</span>  <span class="c1"># None&#39;s in the bystander lists and oneaways lists should be ignored</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;map inst resid </span><span class="si">{</span><span class="n">inst</span><span class="si">}</span><span class="s1"> to template resid </span><span class="si">{</span><span class="n">temp</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">idf</span><span class="o">=</span><span class="n">instdf</span><span class="p">[</span><span class="n">instdf</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">inst</span><span class="p">][[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># logger.debug(f&#39;idf res {inst}:\n{idf.to_string()}&#39;)</span>
                <span class="n">tdf</span><span class="o">=</span><span class="n">tempdf</span><span class="p">[</span><span class="n">tempdf</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">temp</span><span class="p">][[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># logger.debug(f&#39;tdf res {temp}:\n{tdf.to_string()}&#39;)</span>
                <span class="n">tdf</span><span class="o">=</span><span class="n">tdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">idf</span><span class="p">,</span><span class="n">on</span><span class="o">=</span><span class="s1">&#39;atomName&#39;</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span><span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;_template&#39;</span><span class="p">,</span><span class="s1">&#39;_instance&#39;</span><span class="p">))</span>
                <span class="c1"># logger.debug(f&#39;merged\n{tdf.to_string()}&#39;)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">tdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">temp_idx</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;globalIdx_template&#39;</span><span class="p">]</span>
                    <span class="n">inst_idx</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;globalIdx_instance&#39;</span><span class="p">]</span>
                    <span class="c1"># logger.debug(f&#39;t {temp_idx} &lt;-&gt; i {inst_idx}&#39;)</span>
                    <span class="c1"># only map template atoms that are identified in the passed in set</span>
                    <span class="k">if</span> <span class="n">temp_idx</span> <span class="ow">in</span> <span class="n">ut</span><span class="p">:</span>
                        <span class="n">ut</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_idx</span><span class="p">)</span>
                        <span class="n">temp2inst</span><span class="p">[</span><span class="n">temp_idx</span><span class="p">]</span><span class="o">=</span><span class="n">inst_idx</span>
                        <span class="n">inst2temp</span><span class="p">[</span><span class="n">inst_idx</span><span class="p">]</span><span class="o">=</span><span class="n">temp_idx</span>
                    <span class="k">if</span> <span class="n">temp_idx</span> <span class="ow">in</span> <span class="n">temp2inst</span> <span class="ow">and</span> <span class="n">temp2inst</span><span class="p">[</span><span class="n">temp_idx</span><span class="p">]</span><span class="o">!=</span><span class="n">inst_idx</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: temp_idx </span><span class="si">{</span><span class="n">temp_idx</span><span class="si">}</span><span class="s1"> already claimed in temp2inst; bug&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inst2temp</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;Error: could not establish two-way dict of atom globalIdx&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">inst2temp</span><span class="p">,</span><span class="n">temp2inst</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.get_angles_dihedrals"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.get_angles_dihedrals">[docs]</a>    <span class="k">def</span> <span class="nf">get_angles_dihedrals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bond</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_angles_dihedrals returns copies of selections from the Topology interaction-type dataframes that contain the two atoms indicated in the bond</span>

<span class="sd">        :param bond: 2-element list-like container of ints</span>
<span class="sd">        :type bond: list-like container</span>
<span class="sd">        :raises Exception: dies if a NaN is found in any selection</span>
<span class="sd">        :return: tuple of the three dataframe selection copies for angles, dihedrals, and 1-4 pairs </span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">bond</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span>
        <span class="n">ad</span><span class="o">=</span><span class="n">d</span><span class="p">[((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">aj</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">aj</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">ai</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">==</span><span class="n">aj</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">aj</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">==</span><span class="n">ai</span><span class="p">))]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span>
        <span class="n">td</span><span class="o">=</span><span class="n">d</span><span class="p">[((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">aj</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">aj</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">ai</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">==</span><span class="n">aj</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">aj</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">==</span><span class="n">ai</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">al</span><span class="o">==</span><span class="n">aj</span><span class="p">))</span><span class="o">|</span>
             <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">==</span><span class="n">aj</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">al</span><span class="o">==</span><span class="n">ai</span><span class="p">))]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">]:</span>
            <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">and</span> <span class="n">td</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in molecule/dihedrals&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span>

        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
        <span class="n">paird</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ai</span><span class="p">,</span><span class="n">al</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">td</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">td</span><span class="o">.</span><span class="n">al</span><span class="p">):</span>
            <span class="n">tpair</span><span class="o">=</span><span class="n">d</span><span class="p">[((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">al</span><span class="p">))</span><span class="o">|</span>
                    <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">al</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">ai</span><span class="p">))]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">paird</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">paird</span><span class="p">,</span><span class="n">tpair</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">]:</span>
            <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">and</span> <span class="n">paird</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in molecule/pairs&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span>
        <span class="k">return</span> <span class="n">ad</span><span class="p">,</span><span class="n">td</span><span class="p">,</span><span class="n">paird</span></div>

<div class="viewcode-block" id="Molecule.get_resname"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.get_resname">[docs]</a>    <span class="k">def</span> <span class="nf">get_resname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">internal_resid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_resname returns the residue name at position internal_resid in the molecule&#39;s sequence</span>

<span class="sd">        :param internal_resid: molecule-internal residue index</span>
<span class="sd">        :type internal_resid: int</span>
<span class="sd">        :return: residue name</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">internal_resid</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="c1"># def inherit_attribute_from_reactants(self,attribute,available_molecules,increment=True,no_increment_if_negative=True):</span>
    <span class="c1">#     &quot;&quot;&quot;inherit_attribute_from_reactants populate certain atom attributes in molecule from its constituent reactants</span>

    <span class="c1">#     :param attribute: _description_</span>
    <span class="c1">#     :type attribute: _type_</span>
    <span class="c1">#     :param available_molecules: _description_</span>
    <span class="c1">#     :type available_molecules: _type_</span>
    <span class="c1">#     :param increment: _description_, defaults to True</span>
    <span class="c1">#     :type increment: bool, optional</span>
    <span class="c1">#     :param no_increment_if_negative: _description_, defaults to True</span>
    <span class="c1">#     :type no_increment_if_negative: bool, optional</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     adf=self.TopoCoord.Coordinates.A</span>
    <span class="c1">#     ordered_attribute_idx=[]</span>
    <span class="c1">#     curr_max=0</span>
    <span class="c1">#     # logger.debug(f&#39;{self.name}({adf.shape[0]}) inheriting {attribute} from {self.sequence}&#39;)</span>
    <span class="c1">#     # logger.debug(f&#39;available molecules {list(available_molecules.keys())}&#39;)</span>
    <span class="c1">#     for i,r in enumerate(self.sequence):</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         for this residue number, read the list of unique atom names</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         namesinres=list(adf[adf[&#39;resNum&#39;]==(i+1)][&#39;atomName&#39;])</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         access coordinates of standalone residue template with this name &#39;r&#39; on the list of available molecules</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         rdf=available_molecules[r].TopoCoord.Coordinates.A</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         get the attribute values from residue template</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         x=list(rdf[rdf[&#39;atomName&#39;].isin(namesinres)][attribute])</span>
    <span class="c1">#         # logger.debug(f&#39;{r}-&gt;{len(x)}&#39;)</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         increment these attribute value based on residue number in this molecule</span>
    <span class="c1">#         &#39;&#39;&#39;</span>
    <span class="c1">#         if increment:</span>
    <span class="c1">#             i_x=[]</span>
    <span class="c1">#             for y in x:</span>
    <span class="c1">#                 if y&gt;0 or (y&lt;0 and not no_increment_if_negative):</span>
    <span class="c1">#                     i_x.append(y+curr_max)</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     i_x.append(y)</span>
    <span class="c1">#             curr_max=max(i_x)</span>
    <span class="c1">#         ordered_attribute_idx.extend(i_x)</span>
    <span class="c1">#     assert len(ordered_attribute_idx)==adf.shape[0]</span>
    <span class="c1">#     adf[attribute]=ordered_attribute_idx</span>

<div class="viewcode-block" id="Molecule.merge"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;merge merges TopoCoord from other into self&#39;s TopoCoord</span>

<span class="sd">        :param other: another Molecule</span>
<span class="sd">        :type other: Molecule</span>
<span class="sd">        :return: a shift tuple (returned by Coordinates.merge())</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">TopoCoord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shifts</span></div>

<div class="viewcode-block" id="Molecule.load_top_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.load_top_gro">[docs]</a>    <span class="k">def</span> <span class="nf">load_top_gro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">topfilename</span><span class="p">,</span><span class="n">grofilename</span><span class="p">,</span><span class="n">mol2filename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;load_top_gro generate a new TopoCoord member object for this molecule by reading in a Gromacs topology file and a Gromacs gro file</span>

<span class="sd">        :param topfilename: Gromacs topology file</span>
<span class="sd">        :type topfilename: str</span>
<span class="sd">        :param grofilename: Gromacs gro file</span>
<span class="sd">        :type grofilename: str</span>
<span class="sd">        :param mol2filename: alternative coordinate mol2 file, defaults to &#39;&#39;</span>
<span class="sd">        :type mol2filename: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">=</span><span class="n">TopoCoord</span><span class="p">(</span><span class="n">topfilename</span><span class="o">=</span><span class="n">topfilename</span><span class="p">,</span><span class="n">grofilename</span><span class="o">=</span><span class="n">grofilename</span><span class="p">,</span><span class="n">mol2filename</span><span class="o">=</span><span class="n">mol2filename</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.set_gro_attribute"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.set_gro_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">set_gro_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">srs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_gro_attribute sets attribute of atoms to srs (drillst through to Coordinates.set_atomset_attributes())</span>

<span class="sd">        :param attribute: name of attribute</span>
<span class="sd">        :type attribute: str</span>
<span class="sd">        :param srs: scalar or list-like attribute values in same ordering as self.A</span>
<span class="sd">        :type srs: scalar or list-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span><span class="n">srs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.read_gro_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.read_gro_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">read_gro_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">,</span><span class="n">attribute_list</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read attributes from file into self.TopoCoord.Coordinates.A</span>

<span class="sd">        :param grxfilename: name of input file</span>
<span class="sd">        :type grxfilename: str</span>
<span class="sd">        :param attribute_list: list of attributes to take, defaults to [] (take all)</span>
<span class="sd">        :type attribute_list: list, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">read_gro_attributes</span><span class="p">(</span><span class="n">grxfilename</span><span class="p">,</span><span class="n">attribute_list</span><span class="o">=</span><span class="n">attribute_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.write_gro_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.write_gro_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">write_gro_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute_list</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes atomic attributes to a file</span>

<span class="sd">        :param attributes_list: list of attributes to write</span>
<span class="sd">        :type attributes_list: list</span>
<span class="sd">        :param grxfilename: name of output file</span>
<span class="sd">        :type grxfilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_gro_attributes</span><span class="p">(</span><span class="n">attribute_list</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.make_bonds"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.make_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">make_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">moldict</span><span class="p">,</span><span class="n">stage</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_bonds adds new bonds to the molecule&#39;s topology and deletes any sacrificial hydrogens</span>

<span class="sd">        :param bdf: pandas dataframe identifying new bonds</span>
<span class="sd">        :type bdf: pd.DataFrame</span>
<span class="sd">        :param moldict: dictionary of available molecular templates</span>
<span class="sd">        :type moldict: dict</span>
<span class="sd">        :param stage: enumerated parameter indicating reaction_stage</span>
<span class="sd">        :type stage: reaction_stage(Enum)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="n">explicit_sacrificial_Hs</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">aname</span><span class="p">,</span><span class="n">bname</span><span class="o">=</span><span class="p">[</span><span class="n">TC</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">rj</span><span class="p">]]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;generating </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> bond </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">ri</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">aname</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">rj</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">bname</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="si">}</span><span class="s1"> order </span><span class="si">{</span><span class="n">r</span><span class="o">.</span><span class="n">order</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ri</span><span class="o">!=</span><span class="n">r</span><span class="o">.</span><span class="n">rj</span><span class="p">:</span>
                <span class="n">resid_sets</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_resid_sets</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">])</span>
                <span class="n">hxi</span><span class="p">,</span><span class="n">hxj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transrot</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">ri</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">rj</span><span class="p">,</span><span class="n">connected_resids</span><span class="o">=</span><span class="n">resid_sets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">explicit_sacrificial_Hs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">hxi</span><span class="p">,</span><span class="n">hxj</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stage</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">,</span> <span class="n">reaction_stage</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="n">reaction_stage</span><span class="o">.</span><span class="n">cap</span><span class="p">]:</span>
            <span class="n">template_source</span><span class="o">=</span><span class="s1">&#39;ambertools&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">template_source</span><span class="o">=</span><span class="s1">&#39;internal&#39;</span>  <span class="c1"># signals that a template molecule should be identified to parameterize this bond</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">update_topology_and_coordinates</span><span class="p">(</span><span class="n">bdf</span><span class="p">,</span><span class="n">moldict</span><span class="p">,</span><span class="n">explicit_sacH</span><span class="o">=</span><span class="n">explicit_sacrificial_Hs</span><span class="p">,</span><span class="n">template_source</span><span class="o">=</span><span class="n">template_source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_molecule_cycles</span><span class="p">()</span></div>

<div class="viewcode-block" id="Molecule.transrot"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.transrot">[docs]</a>    <span class="k">def</span> <span class="nf">transrot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">at_idx</span><span class="p">,</span><span class="n">at_resid</span><span class="p">,</span><span class="n">from_idx</span><span class="p">,</span><span class="n">from_resid</span><span class="p">,</span><span class="n">connected_resids</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;transrot given a composite molecule, translate and rotate the piece downstream of the yet-to-be created bond specified by (at_idx,at_resid) and (from_idx,from_resid) to minimize steric overlaps and identify the best two sacrificial hydrogens</span>

<span class="sd">        :param at_idx: global index of left-hand atom in new bond</span>
<span class="sd">        :type at_idx: int</span>
<span class="sd">        :param at_resid: global index of left-hand residue</span>
<span class="sd">        :type at_resid: int</span>
<span class="sd">        :param from_idx: global index of right-hand atom in new</span>
<span class="sd">        :type from_idx: int</span>
<span class="sd">        :param from_resid: global index of right-hand residue</span>
<span class="sd">        :type from_resid: int</span>
<span class="sd">        :param connected_resids: list of all other resids attached to right-hand residue that should move with it, defaults to []</span>
<span class="sd">        :type connected_resids: list, optional</span>
<span class="sd">        :return: 2-tuple containing global indices </span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Rotate and translate</span>
        <span class="k">if</span> <span class="n">at_resid</span><span class="o">==</span><span class="n">from_resid</span><span class="p">:</span>
            <span class="k">return</span> <span class="c1"># should never happen but JIC</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> connected resids </span><span class="si">{</span><span class="n">connected_resids</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="n">ATC</span><span class="o">=</span><span class="n">TopoCoord</span><span class="p">()</span>
        <span class="n">BTC</span><span class="o">=</span><span class="n">TopoCoord</span><span class="p">()</span>
        <span class="n">C</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">gro_DataFrame</span><span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">)</span>
        <span class="n">ATC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">at_resid</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bresids</span><span class="o">=</span><span class="n">connected_resids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bresids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_resid</span><span class="p">)</span>
        <span class="n">BTC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bresids</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">BTC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
        <span class="n">NONROT</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="o">~</span><span class="n">C</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bresids</span><span class="p">)]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> atoms&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;holding </span><span class="si">{</span><span class="n">at_resid</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">NONROT</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;rotating/translating </span><span class="si">{</span><span class="n">bresids</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">BTC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="p">(</span><span class="n">NONROT</span><span class="o">+</span><span class="n">BTC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mypartners</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">at_idx</span><span class="p">)</span>
        <span class="n">otpartners</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">from_idx</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Partners of </span><span class="si">{</span><span class="n">at_idx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">mypartners</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Partners of </span><span class="si">{</span><span class="n">from_idx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">otpartners</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">myHpartners</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mypartners</span><span class="p">,[</span><span class="n">C</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mypartners</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)}</span>
        <span class="n">otHpartners</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">otpartners</span><span class="p">,[</span><span class="n">C</span><span class="p">[</span><span class="n">C</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">otpartners</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)}</span>
        <span class="n">myHighestH</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">myHpartners</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">==</span><span class="nb">max</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">myHpartners</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">))}</span>
        <span class="n">otHighestH</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">otHpartners</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">==</span><span class="nb">max</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">otHpartners</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">))}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">myHighestH</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">otHighestH</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Highest-named H partner of </span><span class="si">{</span><span class="n">at_idx</span><span class="si">}</span><span class="s1"> is </span><span class="si">{</span><span class="n">myHighestH</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Highest-named H partner of </span><span class="si">{</span><span class="n">from_idx</span><span class="si">}</span><span class="s1"> is </span><span class="si">{</span><span class="n">otHighestH</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">myHpartners</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: atom </span><span class="si">{</span><span class="n">at_idx</span><span class="si">}</span><span class="s1"> does not have a deletable H atom!&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">otHpartners</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: atom </span><span class="si">{</span><span class="n">from_idx</span><span class="si">}</span><span class="s1"> does not have a deletable H atom!&#39;</span>

        <span class="n">Ri</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">at_idx</span><span class="p">)</span>
        <span class="n">Rj</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">from_idx</span><span class="p">)</span>
        <span class="n">overall_maximum</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.e9</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">coord_trials</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">myH</span><span class="p">,</span><span class="n">myHnm</span> <span class="ow">in</span> <span class="n">myHpartners</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># keys are globalIdx&#39;s, values are names</span>
            <span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">]:</span><span class="nb">dict</span><span class="p">[</span><span class="n">TopoCoord</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">Rh</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">myH</span><span class="p">)</span>
            <span class="n">Rih</span><span class="o">=</span><span class="n">Ri</span><span class="o">-</span><span class="n">Rh</span>
            <span class="n">Rih</span><span class="o">*=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rih</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">otH</span><span class="p">,</span><span class="n">otHnm</span> <span class="ow">in</span> <span class="n">otHpartners</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># logger.debug(f&#39;{self.name}: Considering {myH} {otH}&#39;)</span>
                <span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">]</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">BTC</span><span class="p">)</span>
                <span class="c1"># logger.debug(f&#39;\n{coord_trials[myH][otH].Coordinates.A.to_string()}&#39;)</span>
                <span class="n">Rk</span><span class="o">=</span><span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">]</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">otH</span><span class="p">)</span>
                <span class="c1"># logger.debug(f&#39;{self.name}:    otH {otH} Rk {Rk}&#39;)</span>
                <span class="n">Rkj</span><span class="o">=</span><span class="n">Rk</span><span class="o">-</span><span class="n">Rj</span>
                <span class="n">Rkj</span><span class="o">*=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rkj</span><span class="p">)</span>
                <span class="c1">#Rhk=Rh-Rk</span>
                <span class="c1">#rhk=np.linalg.norm(Rhk)</span>
                <span class="n">cp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Rkj</span><span class="p">,</span><span class="n">Rih</span><span class="p">)</span>
                <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rkj</span><span class="p">,</span><span class="n">Rih</span><span class="p">)</span>
                <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">v2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
                <span class="n">I</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]])</span>
                <span class="c1"># R is the rotation matrix that will rotate donb to align with accb</span>
                <span class="n">R</span><span class="o">=</span><span class="n">I</span><span class="o">+</span><span class="n">v</span><span class="o">+</span><span class="n">v2</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">c</span><span class="p">)</span>
                <span class="c1"># logger.debug(f&#39;{self.name}: R:\n{R}&#39;)</span>
                <span class="c1"># rotate translate all donor atoms!</span>
                <span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">]</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
                <span class="n">Rk</span><span class="o">=</span><span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">]</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">otH</span><span class="p">)</span>
                <span class="c1"># overlap the two H atoms by translation</span>
                <span class="n">Rik</span><span class="o">=</span><span class="n">Rh</span><span class="o">-</span><span class="n">Rk</span>
                <span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">]</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">Rik</span><span class="p">)</span>
                <span class="n">minD</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">minimum_distance</span><span class="p">(</span><span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">],</span><span class="n">self_excludes</span><span class="o">=</span><span class="p">[</span><span class="n">myH</span><span class="p">],</span><span class="n">other_excludes</span><span class="o">=</span><span class="p">[</span><span class="n">otH</span><span class="p">])</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">: minD </span><span class="si">{</span><span class="n">minD</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">minD</span><span class="o">&gt;</span><span class="n">overall_maximum</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">overall_maximum</span><span class="o">=</span><span class="p">(</span><span class="n">minD</span><span class="p">,</span><span class="n">myH</span><span class="p">,</span><span class="n">otH</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">: overall_maximum </span><span class="si">{</span><span class="n">overall_maximum</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">minD</span><span class="p">,</span><span class="n">myH</span><span class="p">,</span><span class="n">otH</span><span class="o">=</span><span class="n">overall_maximum</span>
        <span class="n">BTC</span><span class="o">=</span><span class="n">coord_trials</span><span class="p">[</span><span class="n">myH</span><span class="p">][</span><span class="n">otH</span><span class="p">]</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">overwrite_coords</span><span class="p">(</span><span class="n">BTC</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">swap_atom_names</span><span class="p">(</span><span class="n">myH</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">myHighestH</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">swap_atom_names</span><span class="p">(</span><span class="n">otH</span><span class="p">,</span><span class="nb">list</span><span class="p">(</span><span class="n">otHighestH</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">myH</span><span class="p">,</span><span class="n">otH</span></div>

<div class="viewcode-block" id="Molecule.atoms_w_same_attribute_as"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.atoms_w_same_attribute_as">[docs]</a>    <span class="k">def</span> <span class="nf">atoms_w_same_attribute_as</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">find_dict</span><span class="o">=</span><span class="p">{},</span><span class="n">same_attribute</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">return_attribute</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;atoms_w_same_attribute_as returns a list of atom attributes named in the return_attribute parameter from atoms that share an attribute named in the same_attribute parameter with the atom identified by the find_dict parameter</span>

<span class="sd">        :param find_dict: dictionary of attribute:value pairs that should uniquely identify an atom, defaults to {}</span>
<span class="sd">        :type find_dict: dict, optional</span>
<span class="sd">        :param same_attribute: name of attribute used to screen atoms, defaults to &#39;&#39;</span>
<span class="sd">        :type same_attribute: str, optional</span>
<span class="sd">        :param return_attribute: attribute value to return a list of from the screened atoms, defaults to &#39;&#39;</span>
<span class="sd">        :type return_attribute: str, optional</span>
<span class="sd">        :return: list of attribute values</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">att_val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="n">same_attribute</span><span class="p">,</span><span class="n">find_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">get_gro_attributelist_by_attributes</span><span class="p">(</span><span class="n">return_attribute</span><span class="p">,{</span><span class="n">same_attribute</span><span class="p">:</span><span class="n">att_val</span><span class="p">})</span></div>

<div class="viewcode-block" id="Molecule.flip_stereocenter"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.flip_stereocenter">[docs]</a>    <span class="k">def</span> <span class="nf">flip_stereocenter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;flip_stereocenter flips stereochemistry of atom at idx</span>

<span class="sd">        :param idx: global index of atom</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="n">A</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> flipping on </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ligand_idx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ligand_idx</span><span class="p">)</span><span class="o">!=</span><span class="mi">4</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Atom </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> cannot be a stereocenter; it only has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ligand_idx</span><span class="p">)</span><span class="si">}</span><span class="s1"> ligands.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># determine the two lightest ligands</span>
        <span class="n">branches</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ligand_idx</span><span class="p">:</span>
            <span class="n">bl</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>
            <span class="n">branches</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="n">bl</span><span class="o">.</span><span class="n">half_as_list</span><span class="p">([</span><span class="n">idx</span><span class="p">,</span><span class="n">n</span><span class="p">],</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">ligand_idx</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
        <span class="n">a</span><span class="o">=</span><span class="n">ligand_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">aset</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">a</span><span class="p">]))))</span>
        <span class="n">b</span><span class="o">=</span><span class="n">ligand_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">bset</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">branches</span><span class="p">[</span><span class="n">b</span><span class="p">]))))</span>
        <span class="c1"># translate origin to location of stereocenter</span>
        <span class="n">O</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">O</span><span class="p">)</span>
        <span class="n">rO</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">ra</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">rb</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">adf</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">aset</span><span class="p">)]</span>
        <span class="n">bdf</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bset</span><span class="p">)]</span>
        <span class="c1"># rotate the two branches to swap them</span>
        <span class="n">rOa</span><span class="o">=</span><span class="n">rO</span><span class="o">-</span><span class="n">ra</span>
        <span class="n">rOa</span><span class="o">*=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rOa</span><span class="p">)</span>
        <span class="n">rOb</span><span class="o">=</span><span class="n">rO</span><span class="o">-</span><span class="n">rb</span>
        <span class="n">rOb</span><span class="o">*=</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rOb</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rOa</span><span class="p">,</span><span class="n">rOb</span><span class="p">)</span>
        <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rOa</span><span class="p">,</span><span class="n">rOb</span><span class="p">)</span>
        <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">v2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">I</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]])</span>
        <span class="n">R</span><span class="o">=</span><span class="n">I</span><span class="o">+</span><span class="n">v</span><span class="o">+</span><span class="n">v2</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">c</span><span class="p">)</span>
        <span class="n">dfrotate</span><span class="p">(</span><span class="n">adf</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">aset</span><span class="p">),[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">adf</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="n">cp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">rOb</span><span class="p">,</span><span class="n">rOa</span><span class="p">)</span>
        <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="n">cp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="o">-</span><span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">v2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span><span class="n">I</span><span class="o">+</span><span class="n">v</span><span class="o">+</span><span class="n">v2</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">c</span><span class="p">)</span>
        <span class="n">dfrotate</span><span class="p">(</span><span class="n">bdf</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">bset</span><span class="p">),[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">bdf</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="c1"># translate back to original coordinate frame</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">O</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.rotate_bond"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.rotate_bond">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_bond</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">deg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;rotate_bond rotates all atoms in molecule on b-side of a-b bond by deg degrees</span>

<span class="sd">        :param a: index of a</span>
<span class="sd">        :type a: int</span>
<span class="sd">        :param b: index of b</span>
<span class="sd">        :type b: int</span>
<span class="sd">        :param deg: angle of rotation (degrees)</span>
<span class="sd">        :type deg: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span>
        <span class="n">A</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">branch</span><span class="o">=</span><span class="n">TopoCoord</span><span class="p">()</span>
        <span class="n">bl</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="p">)</span>
        <span class="n">branchidx</span><span class="o">=</span><span class="n">bl</span><span class="o">.</span><span class="n">half_as_list</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span><span class="mi">99</span><span class="p">)</span>
        <span class="n">ra</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">rb</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">Rab</span><span class="o">=</span><span class="n">ra</span><span class="o">-</span><span class="n">rb</span>
        <span class="n">rab</span><span class="o">=</span><span class="n">Rab</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Rab</span><span class="p">)</span>
        <span class="n">O</span><span class="o">=</span><span class="n">rb</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">O</span><span class="p">)</span>
        <span class="n">branch</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">branchidx</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># do stuff</span>
        <span class="n">rx</span><span class="p">,</span><span class="n">ry</span><span class="p">,</span><span class="n">rz</span><span class="o">=</span><span class="n">rab</span>
        <span class="n">caz</span><span class="o">=</span><span class="n">rx</span><span class="o">/</span><span class="p">(</span><span class="n">rx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ry</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">saz</span><span class="o">=</span><span class="n">ry</span><span class="o">/</span><span class="p">(</span><span class="n">rx</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">ry</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">az</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">caz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">saz</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">az</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">az</span>
        <span class="n">R1</span><span class="o">=</span><span class="n">_rotmat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">az</span><span class="p">)</span>
        <span class="n">ay</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">rab</span><span class="o">/</span><span class="n">rz</span><span class="p">)</span> <span class="c1"># (must live on 0&lt;ay&lt;pi bc polar angle)</span>
        <span class="n">R2</span><span class="o">=</span><span class="n">_rotmat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ay</span><span class="p">)</span>
        <span class="n">R3</span><span class="o">=</span><span class="n">_rotmat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">deg</span><span class="o">/</span><span class="mf">180.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">R4</span><span class="o">=</span><span class="n">_rotmat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="n">ay</span><span class="p">)</span>
        <span class="n">R5</span><span class="o">=</span><span class="n">_rotmat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">az</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmult</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span><span class="n">R1</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmult</span><span class="p">(</span><span class="n">R3</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmult</span><span class="p">(</span><span class="n">R4</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmult</span><span class="p">(</span><span class="n">R5</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
        <span class="n">branch</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="n">bdf</span><span class="o">=</span><span class="n">branch</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">branchidx</span><span class="p">),[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">bdf</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">O</span><span class="p">)</span></div>

    <span class="c1"># def sea_of(self,idx):</span>
    <span class="c1">#     clu=self.atoms_w_same_attribute_as(find_dict={&#39;globalIdx&#39;:idx},</span>
    <span class="c1">#                                             same_attribute=&#39;sea_idx&#39;,</span>
    <span class="c1">#                                             return_attribute=&#39;globalIdx&#39;)</span>
    <span class="c1">#     return list(clu)</span>

<div class="viewcode-block" id="Molecule.generate_stereoisomers"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.generate_stereoisomers">[docs]</a>    <span class="k">def</span> <span class="nf">generate_stereoisomers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;generate_stereoisomers generates list of Molecule shells, one for each stereoisomer</span>

<span class="sd">        :return: only returns if no stereoisomers need to be generated</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span>  <span class="c1"># self has not yet acquired topology/coordinates</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">flip</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stereocenters</span><span class="p">))]</span>
        <span class="n">st_idx</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,{</span><span class="s1">&#39;atomName&#39;</span><span class="p">:</span><span class="n">n</span><span class="p">})</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereocenters</span><span class="p">]</span>
        <span class="n">P</span><span class="o">=</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">flip</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="c1"># one with no flips is the original molecule, so skip it</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
            <span class="n">si_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;-S&#39;</span><span class="o">+</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">p</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">si_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">si_name</span><span class="si">}</span><span class="s1"> not found in dict of stereoisomers of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stereocenter sequence </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1"> generates stereoisomer </span><span class="si">{</span><span class="n">si_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">[</span><span class="n">si_name</span><span class="p">]</span>
            <span class="n">M</span><span class="o">.</span><span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
            <span class="n">M</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="p">)</span>
            <span class="n">fsc</span><span class="o">=</span><span class="p">[</span><span class="n">st_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stereocenters</span><span class="p">))</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fsc</span><span class="p">:</span>
                <span class="n">M</span><span class="o">.</span><span class="n">flip_stereocenter</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">M</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">si_name</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Molecule.generate_conformers"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.Molecule.generate_conformers">[docs]</a>    <span class="k">def</span> <span class="nf">generate_conformers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;generate_conformers generates this molecule&#39;s conformer instances using either gromacs or obabel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only generates gro files</span>
        <span class="n">default_gromacs_params</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="s1">&#39;nvt&#39;</span><span class="p">,</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="mi">600</span><span class="p">,</span> <span class="s1">&#39;ps&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;begin_at&#39;</span><span class="p">:</span> <span class="mi">50</span><span class="p">}</span>
        <span class="c1"># if self.nconformers==0: return</span>
        <span class="n">cd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">conformers_dict</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cd</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> conformer_dict </span><span class="si">{</span><span class="n">cd</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nconformers</span><span class="o">=</span><span class="n">cd</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
        <span class="n">minimize</span><span class="o">=</span><span class="n">cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;minimize&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">generator</span><span class="o">=</span><span class="n">cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;generator&#39;</span><span class="p">,{})</span>
        <span class="k">if</span> <span class="n">generator</span><span class="o">==</span><span class="s1">&#39;obabel&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">minimize</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Confomers generated by obabel should be energy-minimized.  Indicate &quot;mimimize: True&quot; in the confomers directive for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">minimize</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generator</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Generating </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nconformers</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">))</span><span class="si">}</span><span class="s1"> conformers for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">gronames</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
        <span class="n">nd</span><span class="o">=</span><span class="n">cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nzeros&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">:</span>
            <span class="n">gronames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">si</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gro</span> <span class="ow">in</span> <span class="n">gronames</span><span class="p">:</span>
            <span class="n">pfx</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">gro</span><span class="si">}</span><span class="s1">-C&#39;</span>
            <span class="k">if</span> <span class="n">generator</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;obabel&#39;</span><span class="p">:</span>
                <span class="n">compfile</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">gro</span><span class="si">}</span><span class="s1">-obabel-confs.gro&#39;</span>
                <span class="n">c</span><span class="o">=</span><span class="n">Command</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;obabel -igro </span><span class="si">{</span><span class="n">gro</span><span class="si">}</span><span class="s1">.gro -O </span><span class="si">{</span><span class="n">compfile</span><span class="si">}</span><span class="s1"> --conformer --nconf </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nconformers</span><span class="si">}</span><span class="s1"> --writeconformers&#39;</span><span class="p">)</span>
                <span class="n">out</span><span class="p">,</span><span class="n">err</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
                <span class="n">c</span><span class="o">=</span><span class="n">Command</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;wc -l </span><span class="si">{</span><span class="n">compfile</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">out</span><span class="p">,</span><span class="n">err</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
                <span class="n">tok</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">lpf</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="bp">self</span><span class="o">.</span><span class="n">nconformers</span>
                <span class="n">c</span><span class="o">=</span><span class="n">Command</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;split -d -n </span><span class="si">{</span><span class="n">nd</span><span class="si">}</span><span class="s1"> -l </span><span class="si">{</span><span class="n">lpf</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">compfile</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">pfx</span><span class="si">}</span><span class="s1"> --additional-suffix=&quot;.gro&quot;&#39;</span><span class="p">)</span>
                <span class="n">out</span><span class="p">,</span><span class="n">err</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">generator</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;gromacs&#39;</span><span class="p">:</span>
                <span class="n">params</span><span class="o">=</span><span class="n">generator</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;params&#39;</span><span class="p">,</span><span class="n">default_gromacs_params</span><span class="p">)</span>
                <span class="n">begin_at</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;begin_at&#39;</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
                <span class="n">compfile</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">gro</span><span class="si">}</span><span class="s1">-gromacs-confs&#39;</span>
                <span class="n">TC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span> <span class="k">if</span> <span class="n">gro</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">[</span><span class="n">gro</span><span class="p">]</span><span class="o">.</span><span class="n">TopoCoord</span>
                <span class="n">TC</span><span class="o">.</span><span class="n">vacuum_simulate</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">compfile</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">nsamples</span><span class="o">=</span><span class="n">cd</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
                <span class="n">gro_from_trr</span><span class="p">(</span><span class="n">compfile</span><span class="p">,</span><span class="n">nzero</span><span class="o">=</span><span class="n">nd</span><span class="p">,</span><span class="n">outpfx</span><span class="o">=</span><span class="n">pfx</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">begin_at</span><span class="p">)</span>
            <span class="c1"># os.remove(f&#39;{gro}-confs.gro&#39;)</span>
            <span class="n">fmt</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;</span><span class="si">{A}</span><span class="s1">{B:0&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;d}&#39;</span>  <span class="c1"># the trjconv command in gro_from_trr must generate these files</span>
            <span class="n">cfnl</span><span class="o">=</span><span class="p">[</span><span class="n">fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">pfx</span><span class="p">,</span><span class="n">B</span><span class="o">=</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nconformers</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">mname</span> <span class="ow">in</span> <span class="n">cfnl</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mname</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;Error: Conformer coordinates file </span><span class="si">{</span><span class="n">mname</span><span class="si">}</span><span class="s1">.gro not found&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Conformer coordinate filenames </span><span class="si">{</span><span class="n">cfnl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cfnl</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minimize</span><span class="p">:</span>
            <span class="n">saveTC</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">mname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conformers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mname</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Minimizing conformer </span><span class="si">{</span><span class="n">mname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">vacuum_minimize</span><span class="p">(</span><span class="n">outname</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">=</span><span class="n">saveTC</span></div></div>

<span class="n">MoleculeDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="n">Molecule</span><span class="p">]</span>
<span class="n">MoleculeList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">Molecule</span><span class="p">]</span>

<div class="viewcode-block" id="generate_stereo_reactions"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.generate_stereo_reactions">[docs]</a><span class="k">def</span> <span class="nf">generate_stereo_reactions</span><span class="p">(</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;generate_stereo_reactions scans the list of reactions and generates any additional reactions in which all possible stereoisomers are reactants</span>

<span class="sd">    :param RL: list of Reactions</span>
<span class="sd">    :type RL: ReactionList</span>
<span class="sd">    :param MD: dictionary of available Molecules</span>
<span class="sd">    :type MD: MoleculeDict</span>
<span class="sd">    :return: number of new reactions/molecular products created</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># any reaction with one or more reactant with one or more stereoisomers </span>
    <span class="c1"># generates new &quot;build&quot; reactions using the stereoisomer as a reactant</span>
    <span class="c1"># in place</span>
    <span class="n">adds</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">terminal_reactions</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">RL</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">stage</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">param</span><span class="p">,</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">build</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">Prod</span><span class="o">=</span><span class="n">MD</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Stereos for </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">stage</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">)</span>
        <span class="n">reactant_stereoisomers</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">MD</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">stereoisomers</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">reactant_stereoisomers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">m</span> <span class="ow">in</span> <span class="n">MD</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">v</span><span class="p">])</span>  <span class="c1"># all stereoisomers must be in the dict of molecules</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">reactant_stereoisomers</span><span class="p">)</span>
        <span class="n">reactant_keys</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">isomer_lists</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">reactant_stereoisomers</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">combos</span><span class="o">=</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">isomer_lists</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">combos</span><span class="p">)</span>
        <span class="c1"># new_reactions=[]</span>
        <span class="n">sidx</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">combos</span><span class="p">:</span>
            <span class="n">nR</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
            <span class="n">nR</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;S-</span><span class="si">{</span><span class="n">sidx</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;S-</span><span class="si">{</span><span class="n">sidx</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">nR</span><span class="o">.</span><span class="n">stage</span><span class="o">=</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">build</span>
            <span class="n">nR</span><span class="o">.</span><span class="n">reactants</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reactant_keys</span><span class="p">,</span><span class="n">c</span><span class="p">)}</span>
            <span class="c1"># MD[R.product].stereoisomers[nR.product]=Molecule.NewCopy(MD[R.product],nR.product)</span>
            <span class="c1"># add resulting product to global molecule dict so that it will be generated</span>
            <span class="n">MD</span><span class="p">[</span><span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">=</span><span class="n">Molecule</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="p">,</span><span class="n">nR</span><span class="p">)</span>
            <span class="n">adds</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">MD</span><span class="p">[</span><span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">sequence</span><span class="o">=</span><span class="n">MD</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">sequence</span>
            <span class="n">MD</span><span class="p">[</span><span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">parentname</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">product</span>
            <span class="n">Prod</span><span class="o">.</span><span class="n">stereoisomers</span><span class="p">[</span><span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">=</span><span class="n">MD</span><span class="p">[</span><span class="n">nR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>                
            <span class="c1"># new_reactions.append(nR)</span>
            <span class="n">sidx</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">terminal_reactions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nR</span><span class="p">)</span>
    <span class="n">RL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">terminal_reactions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adds</span></div>

<div class="viewcode-block" id="generate_symmetry_reactions"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.molecule.generate_symmetry_reactions">[docs]</a><span class="k">def</span> <span class="nf">generate_symmetry_reactions</span><span class="p">(</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;generate_symmetry_reactions scans reaction list to generate any new reactions implied by symmetry-equivalent atoms</span>

<span class="sd">    :param RL: list of Reactions</span>
<span class="sd">    :type RL: ReactionList</span>
<span class="sd">    :param MD: dict of available molecules</span>
<span class="sd">    :type MD: MoleculeDict</span>
<span class="sd">    :return: number of new reactions/molecular products created</span>
<span class="sd">    :rtype: int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">jdx</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">terminal_reactions</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">tail_adds</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">RL</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">stage</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">param</span><span class="p">,</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">,</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cap</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">Prod</span><span class="o">=</span><span class="n">MD</span><span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Symmetry versions for </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">stage</span><span class="p">)</span><span class="si">}</span><span class="s1">)</span><span class="se">\n</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># thisR_extra_reactions=[]</span>
        <span class="c1"># thisR_extra_molecules={}</span>
        <span class="c1"># logger.debug(f&#39;  Product {R.product} resname sequence {prod_seq_resn}&#39;)</span>
        <span class="n">sra_by_reactant</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">MD</span><span class="p">[</span><span class="n">rname</span><span class="p">]</span><span class="o">.</span><span class="n">symmetry_relateds</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">rname</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  sra_by_reactant: </span><span class="si">{</span><span class="n">sra_by_reactant</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">atom_options</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom_key</span><span class="p">,</span><span class="n">atom_rec</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">this_atom_options</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">art</span><span class="o">=</span><span class="n">atom_rec</span><span class="p">[</span><span class="s1">&#39;reactant&#39;</span><span class="p">]</span>
            <span class="n">target_atom_name</span><span class="o">=</span><span class="n">atom_rec</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">art</span> <span class="ow">in</span> <span class="n">sra_by_reactant</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;art </span><span class="si">{</span><span class="n">art</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">sra_by_reactant</span><span class="p">[</span><span class="n">art</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sra_by_reactant</span><span class="p">[</span><span class="n">art</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="n">sra_by_reactant</span><span class="p">[</span><span class="n">art</span><span class="p">]</span><span class="o">=</span><span class="p">[[</span><span class="n">target_atom_name</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">symm_set</span> <span class="ow">in</span> <span class="n">sra_by_reactant</span><span class="p">[</span><span class="n">art</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">target_atom_name</span> <span class="ow">in</span> <span class="n">symm_set</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">atom_name</span> <span class="ow">in</span> <span class="n">symm_set</span><span class="p">:</span>
                            <span class="n">this_atom_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">atom_key</span><span class="p">,</span><span class="n">atom_name</span><span class="p">])</span>
            <span class="n">atom_options</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_atom_options</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  atom options: </span><span class="si">{</span><span class="n">atom_options</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">olist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">atom_options</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">olist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">atom_options</span><span class="p">))</span>
        <span class="n">idx</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">R</span><span class="o">.</span><span class="n">symmetry_versions</span><span class="o">=</span><span class="n">olist</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;olist </span><span class="si">{</span><span class="n">olist</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">olist</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">olist</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">newR</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
            <span class="n">newR</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;-S</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Permutation </span><span class="si">{</span><span class="n">P</span><span class="si">}</span><span class="s1">:&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
                <span class="n">atomKey</span><span class="p">,</span><span class="n">atomName</span><span class="o">=</span><span class="n">pp</span>
                <span class="n">newR</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atomKey</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">atomName</span>
            <span class="n">pname</span><span class="o">=</span><span class="n">generate_product_name</span><span class="p">(</span><span class="n">newR</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pname</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">pname</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">newR</span><span class="o">.</span><span class="n">product</span><span class="o">=</span><span class="n">pname</span> 
            <span class="n">newR</span><span class="o">.</span><span class="n">stage</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">stage</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Primary:&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">newR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
            <span class="n">terminal_reactions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newR</span><span class="p">)</span>
            <span class="n">MD</span><span class="p">[</span><span class="n">newR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">=</span><span class="n">Molecule</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">newR</span><span class="o">.</span><span class="n">product</span><span class="p">,</span><span class="n">generator</span><span class="o">=</span><span class="n">newR</span><span class="p">)</span>
            <span class="n">MD</span><span class="p">[</span><span class="n">newR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">set_origin</span><span class="p">(</span><span class="s1">&#39;symmetry_product&#39;</span><span class="p">)</span>
            <span class="n">MD</span><span class="p">[</span><span class="n">newR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">set_sequence_from_moldict</span><span class="p">(</span><span class="n">MD</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">rR</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">RL</span> <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">product</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">values</span><span class="p">()]:</span>
                <span class="n">reactantKey</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">rR</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="nb">list</span><span class="p">(</span><span class="n">rR</span><span class="o">.</span><span class="n">reactants</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="p">)]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  New product </span><span class="si">{</span><span class="n">newR</span><span class="o">.</span><span class="n">product</span><span class="si">}</span><span class="s1"> must replace reactant </span><span class="si">{</span><span class="n">reactantKey</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">product</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="n">rR</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">nooR</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rR</span><span class="p">)</span>
                <span class="n">nooR</span><span class="o">.</span><span class="n">stage</span><span class="o">=</span><span class="n">rR</span><span class="o">.</span><span class="n">stage</span>
                <span class="n">nooR</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">rR</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">reactantKey</span><span class="si">}</span><span class="s1">:S</span><span class="si">{</span><span class="n">jdx</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">nooR</span><span class="o">.</span><span class="n">reactants</span><span class="p">[</span><span class="n">reactantKey</span><span class="p">]</span><span class="o">=</span><span class="n">newR</span><span class="o">.</span><span class="n">product</span>
                <span class="c1"># update any atom names to reflect origin of this reactant</span>
                <span class="k">for</span> <span class="n">naK</span><span class="p">,</span><span class="n">naRec</span> <span class="ow">in</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">nooR</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;reactant&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">reactantKey</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">na_resid</span><span class="o">=</span><span class="n">naRec</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span> <span class="c1"># resid of reactant atom in target reactant</span>
                    <span class="n">na_name</span><span class="o">=</span><span class="n">naRec</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
                        <span class="n">oaK</span><span class="p">,</span><span class="n">oa_name</span><span class="o">=</span><span class="n">p</span> 
                        <span class="n">oaRec</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">oaK</span><span class="p">]</span>
                        <span class="n">oa_reactatnName</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">[</span><span class="n">oaRec</span><span class="p">[</span><span class="s1">&#39;reactant&#39;</span><span class="p">]]</span>
                        <span class="n">oa_resid</span><span class="o">=</span><span class="n">oaRec</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span>
                        <span class="n">oa_resid_in_o_product</span><span class="o">=</span><span class="n">reactant_resid_to_presid</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">oa_reactatnName</span><span class="p">,</span><span class="n">oa_resid</span><span class="p">,</span><span class="n">RL</span><span class="p">)</span>
                        <span class="c1"># this atom is an atom in the permutation the resid in product matches</span>
                        <span class="k">if</span> <span class="n">na_resid</span> <span class="o">==</span> <span class="n">oa_resid_in_o_product</span><span class="p">:</span>
                            <span class="n">nooR</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">naK</span><span class="p">][</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">oa_resid_in_o_product</span>
                            <span class="n">nooR</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">naK</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">oa_name</span>
                <span class="n">noor_pname</span><span class="o">=</span><span class="n">generate_product_name</span><span class="p">(</span><span class="n">nooR</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">noor_pname</span> <span class="ow">in</span> <span class="n">MD</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">noor_pname</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">noor_pname</span><span class="o">=</span><span class="n">rR</span><span class="o">.</span><span class="n">product</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;-</span><span class="si">{</span><span class="n">jdx</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="n">nooR</span><span class="o">.</span><span class="n">product</span><span class="o">=</span><span class="n">noor_pname</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Secondary:&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">nooR</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span> <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
                <span class="n">jdx</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">RL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nooR</span><span class="p">)</span>
                <span class="n">tail_adds</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">MD</span><span class="p">[</span><span class="n">nooR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">=</span><span class="n">Molecule</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">nooR</span><span class="o">.</span><span class="n">product</span><span class="p">,</span><span class="n">nooR</span><span class="p">)</span>
                <span class="n">MD</span><span class="p">[</span><span class="n">nooR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">set_origin</span><span class="p">(</span><span class="s1">&#39;symmetry_product&#39;</span><span class="p">)</span>
                <span class="n">MD</span><span class="p">[</span><span class="n">nooR</span><span class="o">.</span><span class="n">product</span><span class="p">]</span><span class="o">.</span><span class="n">set_sequence_from_moldict</span><span class="p">(</span><span class="n">MD</span><span class="p">)</span>
            <span class="n">idx</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Symmetry expansion of reaction </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> ends&#39;</span><span class="p">)</span>

    <span class="n">RL</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">terminal_reactions</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">terminal_reactions</span><span class="p">)</span><span class="o">+</span><span class="n">tail_adds</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">HTPolyNet</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation and Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-tutorials/index.html">Example Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/index.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTPolyNetPackage.html">HTPolyNet package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Cameron Abrams, Ming Huang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>