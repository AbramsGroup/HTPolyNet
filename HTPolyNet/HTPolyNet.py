#!/usr/bin/env python
"""
@author: huang, abrams
"""
import logging
import os
import shutil
from turtle import left
import pandas as pd
import argparse as ap
import numpy as np
from copy import deepcopy
from itertools import product
from multiprocessing import Pool
from functools import partial

''' intrapackage imports '''
from HTPolyNet.configuration import Configuration
from HTPolyNet.topocoord import TopoCoord, BTRC
import HTPolyNet.projectfilesystem as pfs
import HTPolyNet.software as software
from HTPolyNet.gromacs import insert_molecules, grompp_and_mdrun, density_trace, mdp_modify, mdp_library
from HTPolyNet.checkpoint import CPstate, Checkpoint
from HTPolyNet.plot import trace

class HTPolyNet:
    ''' Class for a single HTPolyNet runtime session '''
    def __init__(self,cfgfile='',restart=False):
        logging.info(software.to_string())
        if cfgfile=='':
            logging.error('HTPolyNet requires a configuration file.\n')
            raise RuntimeError('HTPolyNet requires a configuration file.')
        logging.info(f'Configuration: {cfgfile}')
        self.cfg=Configuration.read(os.path.join(pfs.root(),cfgfile))
        software.set_gmx_preferences(self.cfg.parameters)
        self.TopoCoord=TopoCoord(system_name='htpolynet')
        self.cfg.parameters['restart']=restart
        if self.cfg.parameters['restart']:
            logging.info(f'***** THIS IS A RESTART *****')

    def checkout(self,filename,altpath=None):
        if not pfs.checkout(filename):
            searchpath=pfs.local_data_searchpath()
            logging.info(f'No {filename} found in libraries; checking local data searchpath {searchpath}')
            if altpath:
                searchpath.append(altpath)
                logging.info(f'and alternative path {altpath}')
            for p in searchpath:
                logging.debug(f'Searching {p}...')
                fullfilename=os.path.join(p,filename)
                if os.path.exists(fullfilename):
                    basefilename=os.path.basename(filename)
                    shutil.copyfile(fullfilename,basefilename)
                    logging.info(f'Found at {fullfilename}')
                    return True
            logging.debug(f'Could not find {filename} anywhere!')
            return False
        return True

    def generate_molecules(self,force_parameterization=False,force_checkin=False):
        logging.info('*'*10+' GENERATING MOLECULE TEMPLATES '+'*'*10)
        self.molecules={}
        for mname,M in self.cfg.molecules.items():
            M.set_origin('unparameterized')
        cwd=pfs.go_to('molecules/parameterized')
        # checkin=pfs.checkin
        # exists=pfs.exists
        ''' Each molecule implied by the cfg is 'generated' here, either by
            reading from the library or direct parameterization.  In some cases,
            the molecule is to be generated by a reaction; if so, it's
            `generator` attribute will be a Reaction instance '''
        msg=', '.join([m for m in self.cfg.molecules])
        logging.debug(f'Will generate {msg}')
        all_made=all([(m in self.molecules and M.get_origin()!='unparameterized') for m,M in self.cfg.molecules.items()])
        iter=1
        while not all_made:
            logging.debug(f'Pass number {iter} through molecules in cfg')
            iter+=1
            ''' We have to generate molecules that act as precursors to other molecules before
                we create the molecules that need those precursors '''
            for mname,M in self.cfg.molecules.items():
                ''' a molecule with no generator specified is a monomer and can be generated by
                    parameterizing an existing mol2 file or reading in a previous parameterization
                    from the library '''
                if mname not in self.molecules:
                    self.generate_molecule(M,force_parameterization=force_parameterization,force_checkin=force_checkin)
                    if M.get_origin()=='unparameterized':
                        # could not make since waiting on precursors
                        continue
                    self.molecules[mname]=M
                    logging.info(f'Generated {mname}')
            all_made=all([(m in self.molecules and M.get_origin()!='unparameterized') for m,M in self.cfg.molecules.items()])
            logging.info(f'Done making molecules: {all_made}')
            for m in self.cfg.molecules:
                logging.info(f'Mol {m} made? {m in self.molecules} -- origin: {M.get_origin()}')

        ''' We need to copy all symmetry info down to atoms in each molecule based on the reactants
            used to generate them.  We then must use this symmetry information to expand the list
            of Reactions '''
        new_molecules=self.cfg.symmetry_expand_reactions(self.molecules)
        for mname,M in new_molecules.items():
            ''' a molecule with no generator specified is a monomer and can be generated by
                parameterizing an existing mol2 file or reading in a previous parameterization
                from the library '''
            if mname not in self.molecules:
                logging.debug(f'Generating {mname}')
                self.generate_molecule(M,force_parameterization=force_parameterization,force_checkin=force_checkin)
                assert M.get_origin()!='unparameterized'
                self.molecules[mname]=M
                logging.info(f'Generated {mname}')
        self.molecules.update(new_molecules)
        self.cfg.maxconv=self.cfg.calculate_maximum_conversion()
        logging.info(f'Maximum conversion is {self.cfg.maxconv} bonds.')
        for M in self.molecules.values():
            logging.debug(f'Ring detector for {M.name}')
            M.label_ring_atoms()
        logging.debug(f'Reaction bond(s) in each molecular template:')
        for M in self.molecules.values():
            if len(M.reaction_bonds)>0:
                logging.debug(f'Template {M.name}:')
                for b in M.reaction_bonds:
                    (i,j),(ri,rj),(A,B)=b
                    logging.debug(f'   {i}({ri}:{A})---{j}({rj}:{B})')

    def generate_molecule(self,M,**kwargs):
        mname=M.name
        checkin=pfs.checkin
        exists=pfs.exists
        force_parameterization=kwargs.get('force_parameterization',False)
        force_checkin=kwargs.get('force_checkin',False)
        # userlib=kwargs.get('userlib',None)
        if force_parameterization or not M.previously_parameterized():
            logging.debug(f'Parameterization of {mname} requested -- can we generate {mname}?')
            generatable=(not M.generator) or (all([m in self.molecules for m in M.generator.reactants.values()]))
            if generatable:
                logging.info(f'Yes -- calling {mname}.generate()')
                M.generate(available_molecules=self.molecules,**self.cfg.parameters)
                for ex in ['mol2','top','itp','gro']:
                    checkin(f'molecules/parameterized/{mname}.{ex}',overwrite=force_checkin)
                M.set_origin('newly parameterized')
            else:
                logging.debug(f'...no, did not generate {mname}.')
                logging.debug(f'not ({mname}.generator) {bool(not M.generator)}')
                if M.generator:
                    logging.debug(f'reactants {list(M.generator.reactants.values())}')
                return
        else:
            logging.info(f'Fetching parameterized {mname}')
            for ex in ['mol2','top','itp','gro']:
                self.checkout(f'molecules/parameterized/{mname}.{ex}')
            M.load_top_gro(f'{mname}.top',f'{mname}.gro')
            M.set_sequence()
            M.set_reaction_bonds(self.molecules)
            M.TopoCoord.set_gro_attribute('reactantName',M.name)
            M.set_origin('previously parameterized')
        ''' The cfg allows user to indicate and use
            symmetry-equivalent atoms in any molecule. '''
        if 'symmetry_equivalent_atoms' in self.cfg.parameters and mname in self.cfg.parameters['symmetry_equivalent_atoms']:
            M.TopoCoord.set_gro_attribute('sea-idx',-1)
            list_of_symmetry_sets=self.cfg.parameters['symmetry_equivalent_atoms'][mname]
            sea_idx=1
            for s in list_of_symmetry_sets:
                for at in s:
                    logging.debug(f'Sym: res {mname} at {at} sea-idx {sea_idx}')
                    M.TopoCoord.set_gro_attribute_by_attributes('sea-idx',sea_idx,{'atomName':at})
                sea_idx+=1
            M.write_gro_attributes(['sea-idx'],f'{M.name}.sea')
        else: # assume no symmetry specified for this molecule
            if len(M.sequence)==1: # this is a monomer, but not symmetric
                M.TopoCoord.set_gro_attribute('sea-idx',-1)
            else: # this is an oligomer
                M.inherit_attribute_from_reactants('sea-idx',available_molecules=self.molecules)
            M.write_gro_attributes(['sea-idx'],f'{M.name}.sea')

        if mname in self.cfg.parameters['stereocenters']:
            M.stereoisomers=[]
            my_sc=self.cfg.parameters['stereocenters'][mname]
            logging.debug(f'Stereocenters in {mname}: {my_sc}')
            my_sc_idx=[]
            for n in my_sc:
                my_sc_idx.append(M.TopoCoord.get_gro_attribute_by_attributes('globalIdx',{'atomName':n}))
            adds=[]
            if 'symmetry_equivalent_atoms' in self.cfg.parameters and mname in self.cfg.parameters['symmetry_equivalent_atoms']:
                for idx in my_sc_idx:
                    adds.extend(M.sea_of(idx))
            my_sc_idx=adds
            sc_names=[]
            for idx in my_sc_idx:
                sc_names.append(M.TopoCoord.get_gro_attribute_by_attributes('atomName',{'globalIdx':idx}))
            logging.debug(f'With symmetry, stereocenters are {sc_names}')
            flip=[[0,1] for _ in range(len(my_sc_idx))]
            P=product(*flip)
            next(P) # one with no flips is the original molecule, so skip it
            for p in P:
                logging.debug(f'stereocenter pattern {p}')
                MM=deepcopy(M)
                MM.name+='-SC-'+'-'.join([str(_) for _ in p])
                logging.debug(f'generates {MM.name}')
                fsc=[]
                # for i in range(my_sc_idx)
                fsc=[my_sc_idx[i] for i in range(len(my_sc_idx)) if p[i]]
                for f in fsc:
                    MM.flip_stereocenter(f)
                MM.TopoCoord.Coordinates.write_gro(f'{MM.name}.gro')
                M.stereoisomers.append(MM.name)
        return True

    def initialize_topology(self,inpfnm='init'):
        """Create a full gromacs topology that includes all directives necessary
            for an initial liquid simulation.  This will NOT use any #include's;
            all types will be explicitly in-lined.

        :param inpfnm: input file name prefix, defaults to 'init'
        :type inpfnm: str, optional
        """
        cwd=pfs.go_to('systems/init')
        if os.path.isfile(f'{inpfnm}.top'):
            logging.info(f'{inpfnm}.top already exists in {cwd} but we will rebuild it anyway!')
        ''' for each monomer named in the cfg, either parameterize it or fetch its parameterization '''
        already_merged=[]
        for item in self.cfg.initial_composition:
            M=self.molecules[item['molecule']]
            N=item['count']
            t=deepcopy(M.TopoCoord.Topology)
            t.adjust_charges(0)
            t.rep_ex(N)
            logging.info(f'Merging {N} copies of {M.name}\'s topology into global topology')
            self.TopoCoord.Topology.merge(t)
            already_merged.append(M.name)
        for othermol,M in self.molecules.items():
            if not othermol in already_merged:
                self.TopoCoord.Topology.merge_types(M.TopoCoord.Topology)
        logging.info(f'Global topology has {self.TopoCoord.Topology.atomcount()} atoms.')
        self.TopoCoord.write_top(f'{inpfnm}.top')
        logging.info(f'Wrote {inpfnm}.top to {cwd}')

    def setup_liquid_simulation(self,inpfnm='init'):
        """Builds initial top and gro files for initial liquid simulation

        :param inpfnm: input file name prefix, defaults to 'init'
        :type inpfnm: str, optional
        """
        cwd=pfs.go_to('systems/init')
        if 'initial_boxsize' in self.cfg.parameters:
            boxsize=self.cfg.parameters['initial_boxsize']
        elif 'initial_density' in self.cfg.parameters:
            mass_kg=self.TopoCoord.total_mass(units='SI')
            V0_m3=mass_kg/self.cfg.parameters['initial_density']
            L0_m=V0_m3**(1./3.)
            L0_nm=L0_m*1.e9
            logging.info(f'Initial density {self.cfg.parameters["initial_density"]} kg/m^3 and total mass {mass_kg:.3e} kg dictate an initial box side length of {L0_nm:.3f} nm')
            boxsize=[L0_nm,L0_nm,L0_nm]
        # extend system, make gro file
        clist=self.cfg.initial_composition
        c_togromacs={}
        for cc in clist:
            M=self.cfg.molecules[cc['molecule']]
            tc=cc['count']
            total_isomers=len(M.stereoisomers)+1
            count_per_isomer=tc//total_isomers
            leftovers=tc%total_isomers
            c_togromacs[M.name]=count_per_isomer
            if leftovers>0:
                c_togromacs[M.name]+=1
                leftovers-=1
            self.checkout(f'molecules/parameterized/{M.name}.gro',altpath=pfs.subpath('molecules'))
            for isomer in M.stereoisomers:
                c_togromacs[isomer]=count_per_isomer
                if leftovers>0:
                    c_togromacs[isomer]+=1
                    leftovers-=1
                self.checkout(f'molecules/parameterized/{isomer}.gro',altpath=pfs.subpath('molecules'))
            # pass
            # c_togromacs[cc['molecule']]=cc['count']
        # m_togromacs={}
        # for mname,M in self.cfg.molecules.items():
        #     if mname in c_togromacs:
        #         m_togromacs[mname]=M
        #         self.checkout(f'molecules/parameterized/{mname}.gro',altpath=pfs.subpath('molecules'))
        # for m,M in m_togromacs.items():
        #     logging.info(f'Molecule to gromacs: {m} ({M.name})')
        # for m,c in c_togromacs.items():
        #     logging.info(f'Composition to gromacs: {m} {c}')
        if not os.path.exists(f'{inpfnm}.gro') or not os.path.exists(f'{inpfnm}.top'):
            msg=insert_molecules(c_togromacs,boxsize,inpfnm,**self.cfg.parameters)
            logging.info(f'Generated {inpfnm}.top and {inpfnm}.gro.')
        else:
            logging.info(f'Found {inpfnm}.gro.')
        self.TopoCoord.read_gro(f'{inpfnm}.gro')
        self.TopoCoord.atom_count()
        self.TopoCoord.inherit_attributes_from_molecules(['cycle-idx','reactantName'],self.cfg.molecules)
        self.TopoCoord.set_z(self.cfg.reactions,self.molecules)
        self.TopoCoord.write_gro_attributes(['z','cycle-idx','reactantName'],f'{inpfnm}.grx')
        self.TopoCoord.make_ringlist()
        self.TopoCoord.make_resid_graph()

    def do_liquid_simulation(self,inpfnm='init',deffnm='npt-1'):
        """do_liquid_simulation Manages execution of gmx mdrun to perform minimization
            and NPT MD simulation of the initial liquid system.  Final coordinates are
            loaded into the global TopoCoord.

        :param inpfnm: input file name prefix, defaults to 'init'
        :type inpfnm: str, optional
        :param deffnm: deffnm prefix fed to gmx mdrun, defaults to 'npt-1'
        :type deffnm: str, optional
        """
        cwd=pfs.go_to('systems/init')
        nsteps=self.cfg.parameters.get('densification_steps',-2)
        T=self.cfg.parameters.get('densification_temperature',300)
        P=self.cfg.parameters.get('densification_pressure',10)
        if os.path.exists(f'{deffnm}.gro') and self.cfg.parameters['restart']:
            logging.info(f'{deffnm}.gro exists in {os.getcwd()}; skipping initial NPT md.')
        else:
            logging.info(f'Conducting initial NPT MD simulation of liquid')
            mdp_pfx=mdp_library['minimize']
            self.checkout(f'mdp/{mdp_pfx}.mdp')
            msg=grompp_and_mdrun(gro=inpfnm,top=inpfnm,out=f'{inpfnm}-minimized',mdp=mdp_pfx,**self.cfg.parameters)
            mdp_pfx=mdp_library['liquid-densify']
            self.checkout(f'mdp/{mdp_pfx}.mdp')
            mdp_modify(f'{mdp_pfx}.mdp',{'ref_t':T,'gen-temp':T,'ref_p':P})
            msg=grompp_and_mdrun(gro=f'{inpfnm}-minimized',top=inpfnm,out=deffnm,mdp=mdp_pfx,nsteps=nsteps,**self.cfg.parameters)
            logging.info(f'Generated configuration {deffnm}.gro\n')
        density_trace(deffnm,**self.cfg.parameters)
        trace(['Density'],[deffnm],outfile='../../plots/init-density.png')
        # update coordinates; will wrap upon reading in
        self.TopoCoord.copy_coords(TopoCoord(grofilename=f'{deffnm}.gro'))

    def CURE(self):
        # Connect - Update - Relax - Equilibrate
        logging.info('*'*10+' CONNECT - UPDATE - RELAX - EQUILIBRATE (CURE) begins '+'*'*10)
        max_nxlinkbonds=self.cfg.maxconv
        '''
        CURE_initial_search_radius: 0.5 # nm
        CURE_radial_increment: 0.25
        CURE_max_iterations: 150
        CURE_max_conversion_per_iteration: 0.25
        CURE_desired_conversion: 0.95
        CURE_late_threshold: 0.85
        '''
        try:
            desired_conversion=self.cfg.parameters['CURE_desired_conversion']
        except KeyError as error:
            logging.error(f'CURE_desired_conversion not found in configuration.')
            logging.error(f'You must specify a desired conversion explicitly in the configuration file.')
            logging.error(f'For now, this is being defaulted to 0.5')
            desired_conversion=0.5
        max_conversion_per_iteration=self.cfg.parameters.get('CURE_max_conversion_per_iteration',1.0)
        cure_search_radius=self.cfg.parameters.get('CURE_initial_search_radius',0.5)
        checkpoint_file=self.cfg.parameters.get('checkpoint_file','checkpoint.yaml')
        radial_increment=self.cfg.parameters.get('CURE_radial_increment',0.25)
        maxiter=self.cfg.parameters.get('CURE_max_iterations',100)

        n_stages=self.cfg.parameters.get('max_bond_relaxation_stages',6)
        bond_relaxation_increment=self.cfg.parameters.get('max_bond_relaxation_increment',0)
        relax_temperature=self.cfg.parameters.get('relax_temperature',300.0)
        late_threshold=self.cfg.parameters.get('late_threshold',1.0)

        equilibration_temperature=self.cfg.parameters.get('equilibration_temperature',300.0)
        equilibration_pressure=self.cfg.parameters.get('equilibration_pressure',1.0)
        equilibration_steps=self.cfg.parameters.get('equilibration_steps',50000)

        dragging_enabled=False
        drag_limit_nm=self.cfg.parameters.get('drag_limit',0.0)
        drag_trigger_distance=self.cfg.parameters.get('drag_trigger_distance',0.0)
        n_dragstages=self.cfg.parameters.get('max_drag_stages',0)
        drag_temperature=self.cfg.parameters.get('drag_temperature',300.0)
        if n_dragstages>0 and drag_limit_nm>0.0:
             dragging_enabled=True

        curr_nxlinkbonds=0
        curr_conversion=0.0
        max_search_radius=min(self.TopoCoord.Coordinates.box.diagonal()/2)
        max_radidx=int((max_search_radius-cure_search_radius)/radial_increment)
        cure_finished=False
        CP=Checkpoint(checkpoint_file=checkpoint_file)
        CP.iter=1
        while not CP.state==CPstate.post_cure:
            # Checkpointing in this loop uses the CP.state variable; at the end of
            # each section, CP.state is set to indicate the next section
            cwd=pfs.go_to(f'systems/iter-{CP.iter}')
            CP.read_checkpoint(self)
            if CP.state==CPstate.fresh:
                logging.info(f'CURE iteration {CP.iter}/{maxiter} begins.')
                CP.set_state(CPstate.bondsearch) # no need to write a checkpoint
            if CP.state==CPstate.bondsearch:
                """ Capture radius method for identifying potential crosslink bonds """
                logging.info(f'CURE iteration {CP.iter}/{maxiter}: BONDSEARCH')
                CP.radius=cure_search_radius+CP.current_radidx*radial_increment
                apply_probabilities=curr_conversion<late_threshold
                # logging.debug(f'Bond search: curr_conversion {curr_conversion} late_threshold {late_threshold} apply_probabilities {apply_probabilities}')
                bond_limit=int(max_conversion_per_iteration*max_nxlinkbonds)
                bond_target=int((desired_conversion-curr_conversion)*max_nxlinkbonds)
                bond_limit=min([bond_limit,bond_target])
                logging.debug(f'Iteration limited to at most {bond_limit} new bonds')
                while CP.state==CPstate.bondsearch and CP.current_radidx<max_radidx:
                    nbdf=self.cure_searchbonds(CP.radius,header=['ai','aj','reactantName'],
                                                apply_probabilities=apply_probabilities,
                                                abs_max=bond_limit)
                    if nbdf.shape[0]>0:
                        CP.register_bonds(nbdf,bonds_are='unrelaxed')
                        CP.bonds['initial-distance']=self.TopoCoord.return_bond_lengths(CP.bonds)
                        if dragging_enabled and CP.bonds['initial-distance'].max()>drag_trigger_distance:
                            next_stage=CPstate.drag
                        else:
                            next_stage=CPstate.update
                        CP.write_checkpoint(self,next_stage,prefix='0-connect')
                    else:
                        logging.debug(f'CURE iteration {CP.iter}: increasing bondsearch radius to {CP.radius+radial_increment}')
                        CP.current_radidx+=1
                        CP.radius+=radial_increment
                if CP.state==CPstate.bondsearch: # loop exited on radius violation
                    logging.debug(f'CURE iteration {CP.iter} failed to find bonds.')
                    cure_finished=True
            if CP.state==CPstate.drag:
                ''' dragging: series of simulations that use type-6 (non-chemical) bonds
                    that progressively shrink and become stiffer in order to drag the
                    reactive atoms towards each other in preparation for making bonds '''
                logging.info(f'CURE iteration {CP.iter}/{maxiter}: PREBOND DRAGGING')
                CP.read_checkpoint(self)
                min_pfx=mdp_library['drag-minimize']
                nvt_pfx=mdp_library['drag-nvt']
                npt_pfx=mdp_library['drag-npt']
                self.checkout(f'mdp/{min_pfx}.mdp')
                self.checkout(f'mdp/{nvt_pfx}.mdp')
                self.checkout(f'mdp/{npt_pfx}.mdp')
                mdp_modify(f'{nvt_pfx}.mdp',{'gen-temp':drag_temperature,'ref_t':drag_temperature})
                mdp_modify(f'{npt_pfx}.mdp',{'gen-temp':drag_temperature,'ref_t':drag_temperature})
                CP.bonds['current-lengths']=np.array(self.TopoCoord.return_bond_lengths(CP.bonds))
                logging.debug(f'New pairs avg/min/max: {CP.bonds["current-lengths"].mean():.3f}/{CP.bonds["current-lengths"].min():.3f}/{CP.bonds["current-lengths"].max():.3f}')
                maxD=CP.bonds['current-lengths'].max()
                if maxD<0.9:
                    maxD=0.9
                mdp_modify(f'{min_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                mdp_modify(f'{nvt_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                mdp_modify(f'{npt_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                CP.bonds['initial-distance-relax']=self.TopoCoord.return_bond_lengths(CP.bonds)
                # CP.bonds['initial-distance']=self.TopoCoord.return_bond_lengths(CP.bonds)
                self.TopoCoord.add_restraints(CP.bonds,typ=6)
                begin_dragstage=CP.current_dragstage
                for i in range(begin_dragstage,n_dragstages):
                    saveT=self.TopoCoord.copy_bond_parameters(CP.bonds)
                    self.TopoCoord.attenuate_bond_parameters(CP.bonds,i,n_dragstages,minimum_distance=drag_limit_nm)
                    stagepref=f'1-drag-stage-{i+1}'
                    CP.write_checkpoint(self,CPstate.drag,prefix=stagepref)
                    msg=grompp_and_mdrun(gro=stagepref,top=stagepref,out=stagepref+'-min',mdp=min_pfx,rdd=CP.radius,**self.cfg.parameters)
                    nsteps=self.cfg.parameters.get('drag_nvt_steps',-2)
                    msg=grompp_and_mdrun(gro=stagepref+'-min',top=stagepref,out=stagepref+'-nvt',mdp=nvt_pfx,rdd=CP.radius,nsteps=nsteps,**self.cfg.parameters)
                    nsteps=self.cfg.parameters.get('drag_npt_steps',-2)
                    msg=grompp_and_mdrun(gro=stagepref+'-nvt',top=stagepref,out=stagepref+'-npt',mdp=npt_pfx,rdd=CP.radius,nsteps=nsteps,**self.cfg.parameters)
                    self.TopoCoord.copy_coords(TopoCoord(grofilename=stagepref+'-npt.gro'))
                    self.TopoCoord.restore_bond_parameters(saveT)
                    CP.bonds['current-lengths']=np.array(self.TopoCoord.return_bond_lengths(CP.bonds))
                    logging.debug(f'New pairs avg/min/max: {CP.bonds["current-lengths"].mean():.3f}/{CP.bonds["current-lengths"].min():.3f}/{CP.bonds["current-lengths"].max():.3f}')
                    maxD=max([CP.bonds['current-lengths'].max(),0.9])
                    mdp_modify(f'{min_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                    mdp_modify(f'{nvt_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                    mdp_modify(f'{npt_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                    current_lengths=np.array(self.TopoCoord.return_bond_lengths(CP.bonds))
                    logging.debug(f'New restraints avg/min/max: {current_lengths.mean():.3f}/{current_lengths.min():.3f}/{current_lengths.max():.3f}')
                    CP.current_dragstage+=1
                CP.current_dragstage-=1
                self.TopoCoord.remove_restraints(CP.bonds)
                CP.write_checkpoint(self,CPstate.update,prefix='1-drag')
            if CP.state==CPstate.update:
                ''' Update the topology: make bonds, delete sacrificial atoms; only reactions
                    designated as "cure" are used here '''
                logging.info(f'CURE iteration {CP.iter}/{maxiter}: UPDATE TOPOLOGY')
                CP.read_checkpoint(self)
                CP.bonds=self.TopoCoord.update_topology_and_coordinates(CP.bonds,template_dict=self.molecules,write_mapper_to='idx_mapper.dat')
                CP.current_stage=0
                CP.bonds['initial-distance']=self.TopoCoord.return_bond_lengths(CP.bonds)
                self.TopoCoord.make_resid_graph(json_file='2-update-resid-graph.json',draw=f'../../plots/iter-{CP.iter}-graph.png')
                CP.write_checkpoint(self,CPstate.relax,prefix='2-update')
            if CP.state==CPstate.relax:
                ''' Relax all new bonds using progressively shorter and stiffer bond parameters '''
                logging.info(f'CURE iteration {CP.iter}/{maxiter}: BOND RELAXATION')
                CP.read_checkpoint(self)
                min_pfx=mdp_library['relax-minimize']
                nvt_pfx=mdp_library['relax-nvt']
                npt_pfx=mdp_library['relax-npt']
                self.checkout(f'mdp/{min_pfx}.mdp')
                self.checkout(f'mdp/{nvt_pfx}.mdp')
                self.checkout(f'mdp/{npt_pfx}.mdp')
                maxD=max([CP.bonds['initial-distance'].max(),0.9])
                mdp_modify(f'{min_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                mdp_modify(f'{nvt_pfx}.mdp',{'gen-temp':relax_temperature,'ref_t':relax_temperature,'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                mdp_modify(f'{npt_pfx}.mdp',{'gen-temp':relax_temperature,'ref_t':relax_temperature,'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                CP.bonds['initial-distance-relax']=self.TopoCoord.return_bond_lengths(CP.bonds)
                if bond_relaxation_increment>0.0:
                    n_stages=int(CP.bonds['initial-distance-relax'].max()/bond_relaxation_increment)
                    logging.debug(f'Using {n_stages} relaxation stages with increment {bond_relaxation_increment}')
                begin_stage=CP.current_stage
                for i in range(begin_stage,n_stages):
                    saveT=self.TopoCoord.copy_bond_parameters(CP.bonds)
                    self.TopoCoord.attenuate_bond_parameters(CP.bonds,i,n_stages)
                    stagepref=f'3-relax-stage-{i+1}'
                    CP.write_checkpoint(self,CPstate.relax,prefix=stagepref)
                    msg=grompp_and_mdrun(gro=stagepref,top=stagepref,out=stagepref+'-min',mdp=min_pfx,rdd=CP.radius,**self.cfg.parameters)
                    nsteps=self.cfg.parameters.get('relax_nvt_steps',-2)
                    msg=grompp_and_mdrun(gro=stagepref+'-min',top=stagepref,out=stagepref+'-nvt',mdp=nvt_pfx,rdd=CP.radius,nsteps=nsteps,**self.cfg.parameters)
                    nsteps=self.cfg.parameters.get('relax_npt_steps',-2)
                    msg=grompp_and_mdrun(gro=stagepref+'-nvt',top=stagepref,out=stagepref+'-npt',mdp=npt_pfx,rdd=CP.radius,nsteps=nsteps,**self.cfg.parameters)
                    self.TopoCoord.copy_coords(TopoCoord(grofilename=stagepref+'-npt.gro'))
                    self.TopoCoord.restore_bond_parameters(saveT)
                    CP.bonds['current-lengths']=np.array(self.TopoCoord.return_bond_lengths(CP.bonds))
                    logging.debug(f'New bonds avg/min/max: {CP.bonds["current-lengths"].mean():.3f}/{CP.bonds["current-lengths"].min():.3f}/{CP.bonds["current-lengths"].max():.3f}')
                    maxD=max([CP.bonds['current-lengths'].max(),0.9])
                    mdp_modify(f'{min_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                    mdp_modify(f'{nvt_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                    mdp_modify(f'{npt_pfx}.mdp',{'rvdw':maxD,'rcoulomb':maxD,'rlist':maxD})
                    CP.current_stage+=1
                CP.current_stage-=1
                CP.bonds_are='relaxed'
                CP.write_checkpoint(self,CPstate.equilibrate,prefix='4-equilibrate')
            if CP.state==CPstate.equilibrate:
                logging.info(f'CURE iteration {CP.iter}/{maxiter}: EQUILIBRATION')
                CP.read_checkpoint(self)
                ''' Final NPT MD equilibration with full parameters '''
                pfx=mdp_library['equilibrate-npt']
                self.checkout(f'mdp/{pfx}.mdp')
                mdp_modify(f'{pfx}.mdp',{'gen-temp':equilibration_temperature,'ref_t':equilibration_temperature})
                gro,ext=os.path.splitext(CP.gro)
                top,ext=os.path.splitext(CP.top)
                msg=grompp_and_mdrun(gro=gro,top=top,out=gro+'-post',mdp=pfx,nsteps=equilibration_steps,**self.cfg.parameters)
                self.TopoCoord.copy_coords(TopoCoord(grofilename=gro+'-post.gro'))
                CP.write_checkpoint(self,CPstate.post_equilibration,prefix='5-postcure')
            if CP.state==CPstate.post_equilibration:
                curr_nxlinkbonds+=CP.bonds.shape[0]
                curr_conversion=curr_nxlinkbonds/max_nxlinkbonds
                logging.info(f'Iter {CP.iter} current conversion: {curr_conversion} ({curr_nxlinkbonds}/{max_nxlinkbonds})')
                conversion_reached=curr_conversion>=desired_conversion
                iterations_exceeded=CP.iter>=maxiter
                cure_finished = conversion_reached or iterations_exceeded
                if conversion_reached:
                    logging.info(f'Current conversion {curr_conversion} exceeds desired conversion {desired_conversion}')
                if iterations_exceeded:
                    logging.info(f'Current cure iteration {CP.iter} is at the maximum {maxiter}')
                CP.reset_for_next_iter()
            if cure_finished:
                CP.set_state(CPstate.post_cure)

        self.post_CURE(CP)
        if CP.state==CPstate.finished:
            logging.info(f'CURE FINISHED')
            CP.read_checkpoint(self)
            CP.write_checkpoint(self,CPstate.finished,'7-final')

    def post_CURE(self,CP):
        cwd=pfs.go_to(f'systems/post-cure')
        n_stages=self.cfg.parameters.get('max_bond_relaxation_stages',6)
        bond_relaxation_increment=self.cfg.parameters.get('max_bond_relaxation_increment',0.05)
        relax_temperature=self.cfg.parameters.get('relax_temperature',300.0)

        equilibration_temperature=self.cfg.parameters.get('equilibration_temperature',300)
        equilibration_pressure=self.cfg.parameters.get('equilibration_pressure',1)
        equilibration_steps=self.cfg.parameters.get('equilibration_steps',5000)
        if CP.state==CPstate.post_cure:
            CP.read_checkpoint(self)
            ''' perform any post-cure reactions '''
            bdf=self.post_cure_searchbonds()
            # logging.debug(f'post_CURE bdf\n{bdf.to_string()}')
            if bdf.shape[0]>0:
                CP.register_bonds(bdf,bonds_are='unrelaxed')
                CP.bonds=self.TopoCoord.update_topology_and_coordinates(CP.bonds,template_dict=self.molecules)
                min_pfx=mdp_library['relax-minimize']
                nvt_pfx=mdp_library['relax-nvt']
                npt_pfx=mdp_library['relax-npt']
                self.checkout(f'mdp/{min_pfx}.mdp')
                self.checkout(f'mdp/{nvt_pfx}.mdp')
                self.checkout(f'mdp/{npt_pfx}.mdp')
                mdp_modify(f'{nvt_pfx}.mdp',{'ref_t':relax_temperature,'gen-temp':relax_temperature})
                mdp_modify(f'{npt_pfx}.mdp',{'ref_t':relax_temperature,'gen-temp':relax_temperature})
                CP.bonds['initial-distance']=self.TopoCoord.return_bond_lengths(CP.bonds)
                CP.bonds['initial-distance-relax']=self.TopoCoord.return_bond_lengths(CP.bonds)
                if bond_relaxation_increment>0.0:
                    n_stages=int(CP.bonds['initial-distance'].max()/bond_relaxation_increment)
                    logging.debug(f'post-cure using {n_stages} relaxation stages with increment {bond_relaxation_increment}')
                begin_stage=CP.current_stage
                for i in range(begin_stage,n_stages):
                    saveT=self.TopoCoord.copy_bond_parameters(CP.bonds)
                    self.TopoCoord.attenuate_bond_parameters(CP.bonds,i,n_stages)
                    stagepref=f'6-postcure-relax-stage-{i+1}'
                    CP.write_checkpoint(self,CPstate.relax,prefix=stagepref)
                    msg=grompp_and_mdrun(gro=stagepref,top=stagepref,out=stagepref+'-min',mdp=min_pfx,rdd=CP.radius,**self.cfg.parameters)
                    nsteps=self.cfg.parameters.get('relax_nvt_steps',-2)
                    msg=grompp_and_mdrun(gro=stagepref+'-min',top=stagepref,out=stagepref+'-nvt',mdp=nvt_pfx,rdd=CP.radius,nsteps=nsteps,**self.cfg.parameters)
                    nsteps=self.cfg.parameters.get('relax_npt_steps',-2)
                    msg=grompp_and_mdrun(gro=stagepref+'-nvt',top=stagepref,out=stagepref+'-npt',mdp=npt_pfx,rdd=CP.radius,nsteps=nsteps,**self.cfg.parameters)
                    self.TopoCoord.copy_coords(TopoCoord(grofilename=stagepref+'-npt.gro'))
                    self.TopoCoord.restore_bond_parameters(saveT)
                    current_lengths=np.array(self.TopoCoord.return_bond_lengths(CP.bonds))
                    logging.debug(f'-> avg new bond length: {current_lengths.mean():.3f}')
                    CP.current_stage+=1
                CP.current_stage-=1
                CP.bonds_are='relaxed'
                CP.write_checkpoint(self,CPstate.postcure_equilibration,prefix='6-postcure-equilibrate')
        if CP.state==CPstate.postcure_equilibration:
            CP.read_checkpoint(self)
            ''' Final NPT MD equilibration with full parameters '''
            pfx=mdp_library['equilibrate-npt']
            self.checkout(f'mdp/{pfx}.mdp')
            mdp_modify(f'{pfx}.mdp',{'ref_t':equilibration_temperature,'gen-temp':equilibration_temperature,'ref_p':equilibration_pressure})
            gro,ext=os.path.splitext(CP.gro)
            top,ext=os.path.splitext(CP.top)
            msg=grompp_and_mdrun(gro=gro,top=top,out=gro+'-post',mdp=pfx,steps=equilibration_steps,**self.cfg.parameters)
            self.TopoCoord.copy_coords(TopoCoord(grofilename=gro+'-post.gro'))
            CP.write_checkpoint(self,CPstate.finished,prefix='7-final')

    def post_cure_searchbonds(self):
        PCR=[x for x in self.cfg.reactions if x.stage=='post-cure']
        logging.debug(f'Executing {len(PCR)} post-cure reactions')
        adf=self.TopoCoord.gro_DataFrame('atoms')
        raset=adf[adf['z']>0]
        bdf=pd.DataFrame()
        for R in PCR:
            assert len(R.reactants)==1,f'Error: reaction {R.name} is designated post-cure but has more than one reactant'
            logging.debug(f'*** BONDS from reaction {R.name}')
            for bond in R.bonds:
                A=R.atoms[bond['atoms'][0]]
                B=R.atoms[bond['atoms'][1]]
                aname=A['atom']
                areactantname_template=R.reactants[A['reactant']]
                aresid_template=A['resid']
                aresname=self.molecules[areactantname_template].get_resname(aresid_template)
                az=A['z']
                bname=B['atom']
                breactantname_template=R.reactants[B['reactant']]
                bresid_template=B['resid']
                bresname=self.molecules[breactantname_template].get_resname(bresid_template)
                bz=B['z']
                assert areactantname_template==breactantname_template,f'Error: post-cure reaction {R.name} lists a bond whose atoms are in different reactants'
                assert aresname==bresname,f'Error: post-cure reaction {R.name} lists a bond whose atoms are in different residues'
                Aset=raset[(raset['atomName']==aname)&(raset['resName']==aresname)&(raset['z']==az)&(raset['reactantName']==areactantname_template)]
                Aset=Aset.sort_values(by='resNum')
                Bset=raset[(raset['atomName']==bname)&(raset['resName']==bresname)&(raset['z']==bz)&(raset['reactantName']==breactantname_template)&(raset['resNum'].isin(Aset['resNum']))]
                Bset=Bset.sort_values(by='resNum')
                Aset=Aset[Aset['resNum'].isin(Bset['resNum'].to_list())]
                assert Aset.shape[0]==Bset.shape[0],f'Error: no good tally of intramolecular reactive atoms'
                # logging.info(f'Aset\n{Aset["resNum"].to_string()}')
                # logging.info(f'Bset\n{Aset["resNum"].to_string()}')
                Aresids=Aset['resNum'].to_list()
                Bresids=Bset['resNum'].to_list()
                assert all([x==y for x,y in zip(Aresids,Bresids)]),f'Error: residue number mismatch in intramolecular reactions'
                tbdf=pd.DataFrame({'ai':Aset['globalIdx'].to_list(),'aj':Bset['globalIdx'].to_list(),'reactantName':[R.product for _ in range(Aset.shape[0])]})
                bdf=pd.concat((bdf,tbdf),ignore_index=True)
                # logging.debug(f'bdf\n{bdf.to_string()}')
        return bdf

    def set_system(self,CP):
        """set_system Reads all coordinate and topological data from filenames
        indicated in the checkpoint structure; all data is overwritten; called from checkpoint

        :param CP: checkpoint structure
        :type CP: Checkpoint
        """
        top=CP.top
        gro=CP.gro
        grx=CP.grx
        logging.debug(f'RESETTING SYSTEM FROM {top} {gro} {grx}')
        self.TopoCoord=TopoCoord(top,gro)
        if (grx):
            self.TopoCoord.read_gro_attributes(grx)

    def register_system(self,CP,extra_attributes=['z','cycle-idx','reactantName']):
        """register_system Create

        :param CP: checkpoint
        :type CP: Checkpoint
        :param extra_attributes: list of extra atom attributes, defaults to ['z','cycle-idx','reactantName']
        :type extra_attributes: list, optional
        """
        logging.debug(f'WRITING SYSTEM TO {CP.top} {CP.gro} {CP.grx}')
        self.TopoCoord.write_top(CP.top)
        self.TopoCoord.write_gro(CP.gro)
        self.TopoCoord.write_gro_attributes(extra_attributes,CP.grx)

    def cure_searchbonds(self,radius,header=['ai','aj','reactantName'],apply_probabilities=True,abs_max=-1):
        adf=self.TopoCoord.gro_DataFrame('atoms')
        ncpu=self.cfg.parameters['ncpu']
        self.TopoCoord.linkcell_initialize(radius,ncpu=ncpu)
        raset=adf[adf['z']>0]  # this view will be used for downselecting to potential A-B partners
        newbonds=[]
        ''' generate the dataframe of new bonds to make '''
        for R in self.cfg.reactions:
            if R.stage=='post-cure': # ignore post-cure reactions
                continue
            logging.debug(f'*** BONDS from reaction {R.name}')
            prob=R.probability
            for bond in R.bonds:
                A=R.atoms[bond['atoms'][0]]
                B=R.atoms[bond['atoms'][1]]
                aname=A['atom']
                areactantname_template=R.reactants[A['reactant']]
                aresid_template=A['resid']
                aresname=self.molecules[areactantname_template].get_resname(aresid_template)
                az=A['z']
                bname=B['atom']
                breactantname_template=R.reactants[B['reactant']]
                bresid_template=B['resid']
                bresname=self.molecules[breactantname_template].get_resname(bresid_template)
                bz=B['z']
                Aset=raset[(raset['atomName']==aname)&(raset['resName']==aresname)&(raset['z']==az)&(raset['reactantName']==areactantname_template)]
                Bset=raset[(raset['atomName']==bname)&(raset['resName']==bresname)&(raset['z']==bz)&(raset['reactantName']==breactantname_template)]
                Pbonds=list(product(Aset['globalIdx'].to_list(),Bset['globalIdx'].to_list()))
                logging.debug(f'Examining {Aset.shape[0]}x{Bset.shape[0]}={len(Pbonds)} {aresname}:{aname}({az})-{bresname}:{bname}({bz}) pairs')
                passbonds=[]
                if len(Pbonds)>0:
                    bondtestoutcomes={k:0 for k in BTRC}
                    logging.debug(f'Bond search will use {ncpu} processors')
                    p=Pool(processes=ncpu)
                    Pbonds_split=np.array_split(Pbonds,ncpu)
                    results=p.map(partial(self.TopoCoord.bondtest_par,radius=radius), Pbonds_split)
                    p.close()
                    p.join()
                    rc=[]
                    for i,l in enumerate(results):
                        rc.extend(l)
                    for i,R2 in enumerate(rc):
                        RC,rij=R2
                        bondtestoutcomes[RC]+=1
                        if RC==BTRC.passed:
                            passbonds.append((Pbonds[i],rij,R.product,prob))
                    logging.debug(f'*** {len(passbonds)} out of {len(Pbonds)} bonds pass initial filter')
                    logging.debug(f'Bond test outcomes:')
                    for k,v in bondtestoutcomes.items():
                        logging.debug(f'   {str(k)}: {v}')
                    newbonds.extend(passbonds)

        ''' Sort new potential bonds by length (ascending) and claim each one
            in order so long as both its atoms are available '''
        newbonds.sort(key=lambda x: x[1])
        logging.debug(f'*** Pruning {len(newbonds)} bonds...')
        atomset=list(set(list([x[0][0] for x in newbonds])+list([x[0][1] for x in newbonds])))
        resid_pairs=[]
        allowed_bond=[True for x in newbonds]
        for k,b in enumerate(newbonds):
            bb,p,t,prob=b
            i,j=bb
            i_resid=self.TopoCoord.get_gro_attribute_by_attributes('resNum',{'globalIdx':i})
            j_resid=self.TopoCoord.get_gro_attribute_by_attributes('resNum',{'globalIdx':j})
            # need to be careful about intramolecular bonds (capping)
            rp=(i_resid,j_resid)
            if not rp in resid_pairs:
                resid_pairs.append(rp)
                resid_pairs.append(rp[::-1])
            else:
                allowed_bond[k]=False
        # keep shortest bonds up to point atoms are all used up; do not repeat resid pairs
        # so that only one bond is allowed to connect any two residues
        keepbonds=[]
        disallowed=0
        for k,n in enumerate(newbonds):
            if not allowed_bond[k]:
                disallowed+=1
                continue
            b=n[0]
            if b[0] in atomset and b[1] in atomset:
                atomset.remove(b[0])
                atomset.remove(b[1])
                keepbonds.append((b,n[2],n[3]))
        logging.debug(f'*** accepted the {len(keepbonds)} shortest non-competing bonds')
        logging.debug(f'    {disallowed} bonds that repeat resid pairs thrown out.')

        ''' roll the dice '''
        if apply_probabilities:
            luckybonds=[]
            for kb in keepbonds:
                x=np.random.random()
                if x<kb[2]:
                    luckybonds.append(kb)
            logging.debug(f'{len(keepbonds)-len(luckybonds)} bonds rejected on probability.')
        else:
            luckybonds=keepbonds

        ''' apply the stated limit '''
        if abs_max>-1:
            if abs_max<len(luckybonds):
                luckybonds=luckybonds[:abs_max]
                logging.debug(f'Limiting to {abs_max} allowed bonds')

        kdf=pd.DataFrame({header[0]:[x[0][0] for x in luckybonds],
                          header[1]:[x[0][1] for x in luckybonds],
                          header[2]:[x[1] for x in luckybonds]})
        return kdf

    def initreport(self):
        print(self.cfg)
        print()
        print(self.software)

    def main(self,**kwargs):
        force_parameterization=kwargs.get('force_parameterization',False)
        force_checkin=kwargs.get('force_checkin',False)
        self.generate_molecules(
            force_parameterization=force_parameterization,  # force antechamber/GAFF parameterization
            force_checkin=force_checkin                     # force check-in to system libraries
        )
        self.initialize_topology()
        self.setup_liquid_simulation()
        self.do_liquid_simulation()
        self.CURE()
        # self.finalize()

def info():
    print('This is some information on your installed version of HTPolyNet')
    l=pfs.lib_setup()
    print(l.info())
    software.info()

def cli():
    """cli Command-line interface for executable (listed as entry point in setup.cfg)
    """
    parser=ap.ArgumentParser()
    parser.add_argument('command',type=str,default=None,help='command (info, parameterize, run)')
    parser.add_argument('config',type=str,default=None,help='input configuration file in YAML format')
    parser.add_argument('-lib',type=str,default=None,help='local user library')
    parser.add_argument('-log',type=str,default='htpolynet_runtime.log',help='log file')
    parser.add_argument('-restart',default=False,action='store_true',help='restart in latest proj dir')
    parser.add_argument('--force-parameterization',default=False,action='store_true',help='force GAFF parameterization of any input mol2 structures')
    parser.add_argument('--force-checkin',default=False,action='store_true',help='force check-in of any generated parameter files to the system library')
    parser.add_argument('--loglevel',type=str,default='info',help='Log level; info, debug')
    args=parser.parse_args()

    ''' set up logging '''
    loglevel=args.loglevel
    loglevel_numeric=getattr(logging, loglevel.upper())
    if os.path.exists(args.log):
        shutil.copyfile(args.log,args.log+'.bak')
    logging.basicConfig(filename=args.log,filemode='w',format='%(asctime)s %(message)s',level=loglevel_numeric)
    logging.info('HTPolyNet runtime begins.')
    ''' set up the project file system and access to HTPolyNet libraries '''
    userlib=None
    if args.lib!='':
        userlib=args.lib

    software.sw_setup()

    if args.command=='info':
        info()
    elif args.command=='parameterize':
        pfs.pfs_setup(root=os.getcwd(),topdirs=['molecules','systems','plots'],verbose=True,reProject=args.restart,userlibrary=userlib)
        a=HTPolyNet(cfgfile=args.config,restart=args.restart)
        a.generate_molecules(force_parameterization=True,force_checkin=args.force_checkin)
    elif args.command=='run':
        pfs.pfs_setup(root=os.getcwd(),topdirs=['molecules','systems','plots'],verbose=True,reProject=args.restart,userlibrary=userlib)
        a=HTPolyNet(cfgfile=args.config,restart=args.restart)
        a.main(force_checkin=args.force_checkin,force_parameterization=args.force_parameterization)
    else:
        print(f'HTPolyNet command {args.command} not recognized')

    logging.info('HTPolynet runtime ends.')
