from itertools import combinations_with_replacement, product
import os
from copy import deepcopy
import pandas as pd
import numpy as np
import logging

#from HTPolyNet.topology import Topology
#from HTPolyNet.coordinates import Coordinates
from HTPolyNet.topocoord import TopoCoord

from HTPolyNet.ambertools import GAFFParameterize
import HTPolyNet.projectfilesystem as pfs
from HTPolyNet.gromacs import grompp_and_mdrun, analyze_sea

def get_base_reactants(mname,mdict):
    mol=mdict[mname]
    if not mol.generator:
        return [mol]
    mine=[]
    for r in mol.generator.reactants.values():
        mine.extend(get_base_reactants(r,mdict))
    return mine

class Reaction:
    def __init__(self,jsondict):
        self.jsondict=jsondict
        self.name=jsondict.get('name','')
        self.atoms=jsondict.get('atoms',{})
        self.bonds=jsondict.get('bonds',{})
        self.reactants=jsondict.get('reactants',{})
        self.product=jsondict.get('product','')
        self.restrictions=jsondict.get('restrictions',{})
        self.stage=jsondict.get('stage','')
        self.probability=1.0

    def __str__(self):
        return f'Reaction "{self.name}"'

class Molecule:
    def __init__(self,name='',generator=None):
        self.name=name
        self.TopoCoord=TopoCoord()
        self.generator=generator
        self.sequence=[]
        self.origin=None

    # def __str__(self):
    #     restr=f'{self.name} '
    #     if not self.Topology:
    #         restr+=f'(empty topology) '
    #     if len(self.Coords)==0:
    #         restr+=f'(empty coords) '
    #     return restr+'\n'

    def set_origin(self,value):
        self.origin=value

    def get_origin(self):
        return self.origin

    # def num_atoms(self):
    #     if hasattr(self.Coords,'N'):
    #         return self.Coords.N
    #     else:
    #         return self.Coords.shape[0]

    def previously_parameterized(self):
        rval=True
        for ext in ['mol2','top','itp','gro']:
            rval=rval and pfs.exists(os.path.join('molecules/parameterized',f'{self.name}.{ext}'))
        return rval

    def parameterize(self,outname='',**kwargs):
        assert os.path.exists(f'{self.name}.mol2'),f'Cannot parameterize molecule {self.name} without {self.name}.mol2 as input'
        if outname=='':
            outname=f'{self.name}'
        GAFFParameterize(self.name,outname,**kwargs)
        self.load_top_gro(f'{outname}.top',f'{outname}.gro',mol2filename=f'{outname}.mol2')
        #assert self.cstale=='',f'Error: {self.cstale} coords are stale'

    def calculate_sea(self):
        ''' use a hot gromacs run to establish symmetry-equivalent atoms '''
        n=self.name
        boxsize=np.array(self.TopoCoord.maxspan())+2*np.ones(3)
        pfs.checkout('mdp/nvt-sea.mdp')
        for ex in ['top','itp','gro']:
            pfs.checkout(f'molecules/parameterized/{n}.{ex}')
        logging.info(f'Hot md running...output to {n}-sea')
        grompp_and_mdrun(gro=f'{n}',top=f'{n}',
                        mdp='nvt-sea',out=f'{n}-sea',boxSize=boxsize)
        sea_srs=analyze_sea(f'{n}-sea')
        self.set_gro_attribute('sea-idx',sea_srs)

    def minimize(self,outname='',**kwargs):
        if outname=='':
            outname=f'{self.name}'
        n=self.name
        boxsize=np.array(self.TopoCoord.maxspan())+2*np.ones(3)
        pfs.checkout('mdp/em-single-molecule.mdp')
        if 'checkout_required' in kwargs:
            for ex in ['top','itp','gro']:
                pfs.checkout(f'molecules/parameterized/{n}.{ex}')
        grompp_and_mdrun(gro=f'{n}',top=f'{n}',
                        mdp='em-single-molecule',out=f'{outname}',boxSize=boxsize)
        self.TopoCoord.read_gro(f'{n}.gro')

    def propagate_z(self,reactions,mdict):
        ''' Assign all z values in Coords.A dataframes for each molecule '''
        logging.debug(f'propagate_z called for {self.name}')
        adf=self.TopoCoord.gro_DataFrame('atoms')
        self.set_gro_attribute('z',0)
        if self.generator:
            R=self.generator
            logging.debug(f'{self.name} was generated by {R.name}')
            resids=list(set(adf['resNum']))
            resnames=[]
            logging.debug(f'{self.name} has resids {resids}')
            for resid in resids:
                resnames.append(list(set(adf[adf['resNum']==resid]['resName']))[0])
            logging.debug(f'{self.name} has resnames {resnames}')
            for resid,resname in zip(resids,resnames):
                logging.debug(f'Product {self.name} taking z\'s from residue {resname}')
                mol=mdict[resname]
                radf=mol.TopoCoord.gro_DataFrame('atoms')
                zs=radf[radf['z']>0]
                for i,r in zs.iterrows():
                    atomName=r['atomName']
                    resNum=r['resNum']
                    resName=r['resName']
                    z=r['z']
                    self.TopoCoord.set_gro_attribute_by_attributes('z',z,{'atomName':atomName,'resName':resName})
            ''' correct from self's bondlist '''
#            bondlist=self.TopoCoord.Topology.bondlist
            reactive_atoms_idx=list(adf[adf['z']>0]['globalIdx'])
            # logging.debug(f'reactive_atoms_idx {reactive_atoms_idx}')
            for i in range(len(reactive_atoms_idx)):
                ix=reactive_atoms_idx[i]
                for j in range(i,len(reactive_atoms_idx)):
                    jx=reactive_atoms_idx[j]
                    iz=self.TopoCoord.get_gro_attribute_by_attributes('z',{'globalIdx':ix})
                    jz=self.TopoCoord.get_gro_attribute_by_attributes('z',{'globalIdx':jx})
                    if self.TopoCoord.are_bonded(ix,jx):
                        self.TopoCoord.set_gro_attribute_by_attributes('z',iz-1,{'globalIdx':ix})
                        self.TopoCoord.set_gro_attribute_by_attributes('z',jz-1,{'globalIdx':jx})
            # logging.debug(f'after propagate_z product {self.name}:\n{self.Coords.A.to_string()}')
        else:  # this molecule is not a product -- was generated using an input mol2
            ''' find any reaction in which this is a reactant as long as it is not a product '''
            atoms=[]
            for R in reactions:
                if self.name in R.reactants.values():
                    ridx=[k for k,v in R.reactants.items() if v==self.name][0]
                    for a in R.atoms.values(): # find all reactive atoms in this reactant
                        aa=deepcopy(a)
                        if aa['reactant']==ridx:  # this is an atom in this molecule
                            aa['reactant']=R.reactants[ridx]
                            if not aa in atoms:
                                atoms.append(aa)
            logging.debug(f'atoms in reactions for which {self.name} is a reactant:')
            logging.debug(f'{atoms}')
            for a in atoms:
                z=a['z']  # this is the z value listed in the cfg file
                atomName=a['atom']
                resNum=a['resid']
                resName=a['reactant']
                if mdict[resName].generator:
                    logging.debug(f'{self.name} is not a precursor -- it is generated by {mdict[resName].generator.name}')
                assert resName==self.name
                Aidx=self.TopoCoord.get_gro_attribute_by_attributes('globalIdx',{'atomName':atomName,'resName':resName,'resNum':resNum})
                self.TopoCoord.set_gro_attribute_by_attributes('z',z,{'globalIdx':Aidx})
        # logging.debug(f'after propagate_z on {self.name}:\n{self.Coords.A.to_string()}')

    def generate(self,outname='',available_molecules={},**kwargs):
        logging.info(f'Generating Molecule {self.name}')
        if outname=='':
            outname=f'{self.name}'
        if self.generator:
            R=self.generator
            assert type(R)==Reaction,'HTPolyNet only recognizes Reaction-type generators at the moment'
            logging.info(f'Using reaction {R.name} to generate {self.name}.mol2.')
            # this molecule is to be generated using a reaction
            # check to make sure this reactions reactants are among the available molecules
            can_react=all([a in available_molecules for a in R.reactants.values()])
            if not can_react:
                raise Exception(f'Cannot generate {self.name} because required reactants have not been generated')
            # local copies of all reactant molecules
            reactants={}
            for n,r in R.reactants.items():
                reactants[n]=deepcopy(available_molecules[r])

            # can we merge all reactants?
            # base=reactants[0]
            # shifts=[(0,0,0)]  # atom, bond, resid
            # for r in reactants[1:]:
            #     shifts.append(base.merge(r))
            # base.detect_sequence()


            # TODO: need to fix this so that all bonds of reaction are created at once, rather 
            # than sequentially
            bases=[]
            bonds=[]
            for b in R.bonds:
                # every bond names exactly two atoms, A and B
                # here we associate the identifiers A and B with
                # their entry in the atoms dictionary for this reaction
                A,B=[R.atoms[i] for i in b['atoms']]
                mA,mB=[reactants[a['reactant']] for a in [A,B]]
                assert not mA.TopoCoord.Topology.D['mol2_bonds'].empty
                assert not mB.TopoCoord.Topology.D['mol2_bonds'].empty
                aan=A['atom']
                ban=B['atom']
                arn=A['resid']
                brn=B['resid']
                Aidx=mA.TopoCoord.get_gro_attribute_by_attributes('globalIdx',{'atomName':aan,'resNum':arn})
                Bidx=mB.TopoCoord.get_gro_attribute_by_attributes('globalIdx',{'atomName':ban,'resNum':brn})
                logging.info(f'{mB.name} attaches to {mA.name} at {Aidx}({arn}:{aan}) from {Bidx}({brn}:{ban})')
                Aidx,Bidx=b
                Aidx,Bidx=mA.new_bond(mB,at_idx=Aidx,from_idx=Bidx)
                aan=mA.TopoCoord.get_gro_attribute_by_attributes('atomName',{'globalIdx':Aidx})
                arn=mA.TopoCoord.get_gro_attribute_by_attributes('resNum',{'globalIdx':Aidx})
                ban=mA.TopoCoord.get_gro_attribute_by_attributes('atomName',{'globalIdx':Bidx})
                brn=mA.TopoCoord.get_gro_attribute_by_attributes('resNum',{'globalIdx':Bidx})
                logging.info(f'Due to post-bonding reindexing, the two bonded atoms are now {mA.name}-R{arn}-{aan}({Aidx}) and {mB.name}-R{brn}-{ban}({Bidx})')
                if len(bases)==0 or mA not in bases:
                    bases.append(mA)
            assert len(bases)==1,f'Error: Reaction {R.name} results in more than one molecular fragment product'
            base=bases[0]
            self.merge(base)
            self.TopoCoord.write_mol2(filename=f'{self.name}.mol2',molname=self.name)
        else:
            logging.info(f'Using input molecules/inputs/{self.name}.mol2 as a generator.')
            pfs.checkout(f'molecules/inputs/{self.name}.mol2')
            # self.sequence.append(self.name)

        self.parameterize(outname,**kwargs)
        # identify new transferable topological units (angles, dihedrals)
        self.minimize(outname,**kwargs)
        # assign sequence
        self.detect_sequence()

    def detect_sequence(self):
        adf=self.TopoCoord.gro_DataFrame('atoms')
        self.sequence=[]
        current_resid=0
        for i,r in adf.iterrows():
            ri=r['resNum']
            rn=r['resName']
            if ri!=current_resid:
                current_resid=ri
                self.sequence.append(rn)
        logging.debug(f'{self.name} sequence: {self.sequence}')

    def label_ring_atoms(self,cycles):
        adf=self.TopoCoord.gro_DataFrame('atoms')
        self.TopoCoord.set_gro_attribute('cycle-idx',np.zeros(adf.shape[0]).astype(int))
        cidx=1
        for l,cl in cycles.items():
            for c in cl:
                for idx in c:
                    self.TopoCoord.set_gro_attribute_by_attributes('cycle-idx',cidx,{'globalIdx':idx})
                cidx+=1
        # logging.debug(f'label_ring_atoms for {self.name}:\n{adf.to_string()}')

    def get_resname(self,internal_resid):
        # logging.debug(f'{self.name} sequence: {self.sequence}')
        return self.sequence[internal_resid-1]

    def inherit_sea_from_reactants(self,molecules,sea_list):
        if self.name in sea_list:
            logging.debug(f'No need to inherit sea for {self.name}')
            return
        adf=self.TopoCoord.gro_DataFrame('atoms')
        # logging.debug(f'Inherit sea for {self.name}; Atoms data frame initially:\n{adf.to_string()}')
        self.set_gro_attribute('sea-idx',np.arange(adf.shape[0]))
        donors=get_base_reactants(self.name,molecules)
        logging.debug(f'Inherit sea: {self.name} base reactants {", ".join([d.name for d in donors])}')
        seaidx_shift=0
        for D in donors:
            if not D.name in sea_list:
                continue
            dadf=D.TopoCoord.gro_DataFrame('atoms')
            logging.debug(f' from Donor {D.name} seaidx_shift {seaidx_shift}:')
            # logging.debug(f'Here is the whole {D.name}:\n{D.Coords.A.to_string()}')
            recv=adf[adf['resName']==D.name]
            resids=list(set(recv['resNum']))
            logging.debug(f'  resids in {self.name} of {D.name} are {resids}')
            for rid in resids:
                logging.debug(f'    resid {rid}')
                recvr=recv[recv['resNum']==rid]
                for i,r in recvr.iterrows():
                    aidx=r['globalIdx']
                    donor_seaidx=D.TopoCoord.get_gro_attribute_by_attributes('sea-idx',{'atomName':r['atomName']})
                    self.TopoCoord.set_gro_attribute_by_attributes('sea-idx',donor_seaidx+seaidx_shift,{'globalIdx':aidx})
                logging.debug(f'     adding {max(recvr["sea-idx"])} to seaidx_shift {seaidx_shift}')
                seaidx_shift+=max(dadf['sea-idx'])
        # logging.debug(f'Molecule {self.name} after inheriting sea:\n'+self.Coords.A.to_string())

    # def read_topology(self,filename):
    #     assert os.path.exists(filename),f'Topology file {filename} not found.'
    #     if not self.TopoCoord.Topology.empty:
    #         logging.warning(f'Overwriting topology of monomer {self.name} from file {filename}')
    #     sv=pd.DataFrame
    #     if 'mol2_bonds' in self.TopoCoord.Topology.D:
    #         sv=self.TopoCoord.Topology.D['mol2_bonds'].copy()
    #     self.TopoCoord.read_top(filename)
    #     if not sv.empty:
    #         self.TopoCoord.Topology.D['mol2_bonds']=sv
    #         self.TopoCoord.Topology.bond_source_check()

    # def read_coords(self,filename):
    #     assert os.path.exists(filename),f'Coordinate file {filename} not found.'
    #     if not self.Coords.empty:
    #         logging.warning(f'Overwriting coordinates of monomer {self.name} from file {filename}')
    #     basename,ext=os.path.splitext(filename)
    #     if ext=='.mol2':
    #         self.TopoCoord.read_mol2(filename)
    #     elif ext=='.gro':
    #         self.TopoCoord.read_gro(filename)
    #     else:
    #         raise Exception(f'Coordinate filename extension {ext} is not recognized.')

    def merge(self,other):
        self.TopoCoord.merge(other.TopoCoord)

    def load_top_gro(self,topfilename,grofilename,mol2filename=''):
        self.TopoCoord=TopoCoord(topfilename=topfilename,grofilename=grofilename,mol2filename=mol2filename)

    def analyze_sea_topology(self):
        self.TopoCoord.analyze_sea_topology()

    def set_gro_attribute(self,attribute,srs):
        self.TopoCoord.set_gro_attribute(attribute,srs)

    def read_gro_attributes(self,grxfilename,attribute_list=[]):
        self.TopoCoord.read_gro_attributes(grxfilename,attribute_list=attribute_list)

    def write_gro_attributes(self,attribute_list,grxfilename):
        self.TopoCoord.write_gro_attributes(attribute_list,grxfilename)

    # def update_topology(self,t):
    #     self.Topology.merge(t)

    # def update_coords(self,c):
    #     self.Coords.copy_coords(c)

    def new_bond(self,other,at_idx=-1,from_idx=-1):
        if self!=other:
            hxi,hxj=self.transrot(other,at_idx,from_idx)
            idx_shift=self.TopoCoord.num_atoms()
            from_idx+=idx_shift
            hxj+=idx_shift
            idx_scratch0=[hxi,hxj]
            self.merge(other)
        bond=(at_idx,from_idx)
        idx_scratch=self.TopoCoord.make_bonds([bond])
        if self!=other:
            logging.debug(f'Making {self.name}: transrot wants to delete {idx_scratch0} and make_bonds wants {idx_scratch}')
            idx_mapper=self.TopoCoord.delete_atoms(idx_scratch0)
        else:
            idx_mapper=self.TopoCoord.delete_atoms(idx_scratch)
        return idx_mapper[at_idx],idx_mapper[from_idx]

    # def add_bonds(self,pairs=[]):
    #     self.Topology.add_bonds(pairs,enumerate_others=False)

    # def delete_atoms(self,idx=[],return_idx_of=[]):
    #     new_idx=self.Topology.delete_atoms(idx,return_idx_of=return_idx_of)
    #     self.Coords.delete_atoms(idx)
    #     return new_idx

    def transrot(self,other,at_idx,from_idx):
        if self==other:
            return
        logging.debug(f'Transrot for attaching {other.name} to {self.name}')
        myTC=self.TopoCoord
        myA=myTC.gro_DataFrame('atoms')
        otTC=other.TopoCoord
        otA=otTC.gro_DataFrame('atoms')
        mypartners=myTC.partners_of(at_idx)
        otpartners=otTC.partners_of(from_idx)
        # logging.info(f'Partners of {at_idx} {mypartners}')
        # logging.info(f'Partners of {from_idx} {otpartners}')
        myHpartners={k:v for k,v in zip(mypartners,[myA[myA['globalIdx']==i]['atomName'].values[0] for i in mypartners]) if v.startswith('H')}
        otHpartners={k:v for k,v in zip(otpartners,[otA[otA['globalIdx']==i]['atomName'].values[0] for i in otpartners]) if v.startswith('H')}
        myHighestH={k:v for k,v in myHpartners.items() if v==max([k for k in myHpartners.values()])}
        otHighestH={k:v for k,v in otHpartners.items() if v==max([k for k in otHpartners.values()])}
        assert len(myHighestH)==1
        assert len(otHighestH)==1
        # logging.debug(f'Highest-named H partner of {at_idx} is {myHighestH}')
        # logging.debug(f'Highest-named H partner of {from_idx} is {otHighestH}')
        assert len(myHpartners)>0,f'Error: atom {at_idx} does not have a deletable H atom!'
        assert len(otHpartners)>0,f'Error: atom {from_idx} does not have a deletable H atom!'

        Ri=myTC.get_R(at_idx)
        Rj=otTC.get_R(from_idx)
        overall_maximum=(-1.e9,-1,-1)
        totc={}
        for myH,myHnm in myHpartners.items():  # keys are globalIdx's, values are names
            totc[myH]={}
            Rh=myTC.get_R(myH)
            Rih=Ri-Rh
            Rih*=1.0/np.linalg.norm(Rih)
            for otH,otHnm in otHpartners.items():
                # logging.debug(f'Considering {myH} {otH}')
                totc[myH][otH]=deepcopy(otTC)
                Rk=totc[myH][otH].get_R(otH)
                # logging.debug(f'   otH {otH} Rk {Rk}')
                Rkj=Rk-Rj
                Rkj*=1.0/np.linalg.norm(Rkj)
                #Rhk=Rh-Rk
                #rhk=np.linalg.norm(Rhk)
                cp=np.cross(Rkj,Rih)
                c=np.dot(Rkj,Rih)
                v=np.array([[0,-cp[2],cp[1]],[cp[2],0,-cp[0]],[-cp[1],cp[0],0]])
                v2=np.dot(v,v)
                I=np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]])
                # R is the rotation matrix that will rotate donb to align with accb
                R=I+v+v2/(1.+c)
                # logging.debug(f'R:\n{R}')
                # rotate translate all donor atoms!
                totc[myH][otH].rotate(R)
                Rk=totc[myH][otH].get_R(otH)
                # overlap the other H atom with self's
                # reactive atom by translation
                Rik=Ri-Rk
                totc[myH][otH].translate(Rik)
                totc[myH][otH].write_mol2(f'{other.name}-{myH}-{otH}.mol2')
                minD=myTC.minimum_distance(totc[myH][otH],self_excludes=[myH],other_excludes=[otH])
                # logging.debug(f'minD {minD}')
                if minD>overall_maximum[0]:
                    overall_maximum=(minD,myH,otH)
        minD,myH,otH=overall_maximum
        myHnm=myHpartners[myH]
        otHnm=otHpartners[otH]
        # logging.debug(f'Taking {myHnm}({myH}) and {otHnm}({otH})')
        otTC.copy_coords(totc[myH][otH])
        # change H atom names so that it looks like the highest-name-value one was deleted
        myTC.swap_atom_names(myH,list(myHighestH.keys())[0])
        otTC.swap_atom_names(otH,list(otHighestH.keys())[0])
        return myH,otH

    def atoms_w_same_attribute_as(self,find_dict={},same_attribute='',return_attribute=''):
        att_val=self.TopoCoord.get_gro_attribute_by_attributes(same_attribute,find_dict)
        return self.TopoCoord.get_gro_attributelist_by_attributes(return_attribute,{same_attribute:att_val})