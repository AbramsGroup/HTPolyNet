from itertools import combinations_with_replacement, product
from copy import deepcopy
import pandas as pd
import logging
from HTPolyNet.topology import Topology
from HTPolyNet.coordinates import Coordinates

class Atom:
    def __init__(self,datadict):
        self.monomer=datadict['monomer']
        self.name=datadict['name']
        # z: maximum number of bonds this atom will form
        # in a crosslinking reaction
        self.z=int(datadict.get('z',0))
    def __str__(self):
        return f'{self.monomer}_{self.name}({self.z})'
    def to_yaml(self):
        return r'{'+f'monomer: {self.monomer}, name: {self.name}, z: {self.z}'+r'}'

# class CappingBond:
#     boc={1:'-',2:'=',3:'â‰¡'}
#     def __init__(self,jsondict):
#         self.pairnames=jsondict["pair"]
#         self.bondorder=jsondict.get("order",1)
#         self.deletes=jsondict.get("deletes",[])
#     def to_yaml(self):
#         return r'{'+f'pair: {self.pairnames}, order: {self.bondorder}, deletes: {self.deletes}'+r'}'
#     def __str__(self):
#         s=self.pairnames[0]+CappingBond.boc[self.bondorder]+self.pairnames[1]
#         if len(self.deletes)>0:
#             s+=' D['+','.join(self.deletes)+']'
#         return s


class Monomer:
    def __init__(self,name=''):
        self.name=name
        self.reactive_atoms=[]
        self.Topology=Topology()
        self.Coords=Coordinates()

    def add_reactive_atom(self,ra):
        # add this reactive atom if its z is greater than any z
        # for an ra with the same name
        found=False
        for i in range(len(self.reactive_atoms)):
            if self.reactive_atoms[i].name==ra.name:
                if ra.z>self.reactive_atoms[i].z:
                    logging.info(f'Overwriting zmax of {ra.name}')
                    self.reactive_atoms[i].z=ra.z
                    found=True
        if not found:
            logging.info(f'adding reactive atom {ra.name}(zmax={ra.z}) to {self.name}')
            self.reactive_atoms.append(ra)

    def update_atom_specs(self,newmol2,oldmol2):
        ''' Atom specifications from the configuration file refer to atom names in the
            user-provided mol2 files.  After processing via ambertools, the output mol2
            files have renamed atoms (potentially) in the same order as the atoms in the
            user-provided mol3.  This method updates the user-provided atom specifications
            so that they reflect the atom names generated by ambertools. This should not
            be necessary if antechamber obeys the atom ordering in the input mol2 file. '''
        oa=oldmol2.D['atoms']
        na=newmol2.D['atoms']
        for n,d in self.reactive_atoms.items():
            idx=oa[oa['atomName']==n]['globalIdx'].values[0]
            nn=na[na['globalIdx']==idx]['atomName'].values[0]
            t=d
            self.reactive_atoms[n]=None
            self.reactive_atoms[nn]=t
        for c in self.capping_bonds:
            p=c.pairnames
            newpairnames=[]
            for n in p:
                idx=oa[oa['atomName']==n]['globalIdx'].values[0]
                nn=na[na['globalIdx']==idx]['atomName'].values[0]
                newpairnames.append(nn)
            c.pairnames=newpairnames

    def __str__(self):
        s=self.name+'\n'
        for r,a in self.reactive_atoms.items():
            s+=f'   reactive atom: {r}:'+str(a)+'\n'
        # for c in self.capping_bonds:
        #     s+='   cap: '+str(c)+'\n'
        return s

class Molecule:
    def __init__(self,name='',parents=None):
        self.name=name
        self.parents=parents
        self.Topology=Topology()  # a Topology instance
        self.Coords=Coordinates()    # a Coordinates instance

class Reaction:
    ''' reactions may only be initialized after monomers '''
    def __init__(self,jsondict,monomer_list):
        self.name=jsondict.get('name','unnamed reaction')
        self.atoms=jsondict.get('atoms','empty reaction')
        self.bonds=jsondict.get('bonds','empty reaction')
        self.template=jsondict.get('template','empty reaction')
        self.molecules={}
        for i,at in self.atoms.items():
            assert at['monomer'] in monomer_list,f'Reaction {self.name} references non-existent monomer {at["monomer"]}'
            monomer_list[at['monomer']].add_reactive_atom(Atom(at['atom'],at['z']))

    def __str__(self):
        return 'Reaction: '+'+'.join(self.reactants)+' : '+str(self.probability)

def get_conn(mol):
    conn=[]
    for mrname,mr in mol.reactive_atoms.items():
        ''' check to see if this atom's symmetry partners are already on the list '''
        donotadd=False
        adf=mol.Coords['active'].D['atoms']
        if 'sea-idx' in adf:
            isea=adf[adf['atomName']==mrname]['sea-idx'].values[0]
            logging.info(f'get_conn: looking for other atoms with sea-idx = {isea}')
            for s in adf[adf['sea-idx']==isea]['atomName']:
                logging.info(f'...found {s}')
                if s in conn:
                    donotadd=True
        if not donotadd:
            conn.append(mrname)
    return conn

def get_oligomers(m,n):
    ''' m and n are Monomer instances (defined in here) '''
    if not isinstance(m,Monomer) or not isinstance(n,Monomer):
        raise Exception(f'react_mol2 needs Monomers not {type(m)} and {type(n)}')
    if not 'active' in m.Topology or not 'active' in n.Topology:
        raise Exception('react_mol2 needs Monomers with active topologies')
    if not 'active' in m.Coords or not 'active' in n.Coords:
        raise Exception('react_mol2 needs Monomers with active coordinates')

    oligdict=_oligomerize(m,n)
    # check to see if we need to consider n as a basemol
    # we do if any reactive atom on n has z>1
    nbase=any([n.reactive_atoms[i].z>1 for i in get_conn(n)])
    if nbase:
        oligdict.update(_oligomerize(n,m))
    return oligdict

def _oligomerize(basemol,othermol):
    oligdict={}
    logging.info(f'react_mol2: basemol {basemol.name} and othermol {othermol.name}')
    # list of all asymmetric reactive atoms on base
    basera=get_conn(basemol)
    # number of connections for each of those reactive atoms
    baseconn=[basemol.reactive_atoms[i].z for i in basera]
    # list of all asymmetric reactive atoms on other
    otherra=get_conn(othermol)
    # options for a connection on basemol are empty ('') or any one of 
    # asymmetric atoms on other
    otherra=['']+otherra
    # enumerate all symmetry-unique configurations of oligomers
    # on *each* reactive atom on basemol *independently*, for all
    # connections on each reactive atom
    basearr=[]
    for z in baseconn:
        # this reactive atom has z connections, each of which can be
        # 'occupied' by one member of otherra in all possible combinations
        basearr.append(list(combinations_with_replacement(otherra,z)))
    # for n,c in zip(basera,basearr):
    #     print(f'{n} can have following connection configurations:',c)
    # enumerate all unique configurations of connections on all reactive
    # atoms.  This is relevant if there is more than one asymmetric 
    # reactive atom on basemol.
    o=product(*basearr)
    # the first one is one where all connections on all reactive atoms
    # of basemol are empty, so skip it
    next(o)
    for oligo in o:
        # logging.debug('making oligo',oligo)
        # make working copy of basemol coordinates
        wc=deepcopy(basemol.Coords['active'])
        stoich=[(basemol,1)]
        oname=basemol.name
        for c,b in zip(oligo,basera):
            # print(f'establishing connection(s) to atom {b} of {basemol.name}:')
            nconn=len([x for x in c if x!=''])
            if nconn>0:
                oname+=f'@{b}-'+','.join([f'{othermol.name}#{a}' for a in c if a!=''])
            oc=0
            for a in c:
                # print(f'  to atom {a} of {othermol.name}')
                if a != '':
                    owc=deepcopy(othermol.Coords['active'])
                    oc+=1
                    # bring copy of coords from othermol into 
                    # working copy of basemol
                    wc.bond_to(owc,acc=b,don=a)
            if oc>0:
                stoich.append((othermol,oc))
        # print('-> prefix',oname)
        # wc.write_mol2(f'OLIG-{oname}.mol2')
        oligdict[oname]=Oligomer(coord=wc,stoich=stoich)

    return oligdict