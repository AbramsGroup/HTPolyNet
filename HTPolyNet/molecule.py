from itertools import combinations_with_replacement, product

class ReactiveAtom:
    def __init__(self,datadict,name=''):
        self.name=name
        # z: maximum number of bonds this atom will form
        # in a crosslinking reaction
        self.z=int(datadict.get("z",1))
        # ht: a Head or Tail designation; Heads can only 
        # react with Tails, and vice versa, if specified
        self.ht=datadict.get("ht",None)
        # sym: list of other reactive atoms in the
        # owning monomer that are in the same symmetry class
        # THIS MUST BE USER-SPECIFIED 
        self.sym=datadict.get("sym",[])
    def __str__(self):
        return f'{self.name}: ({self.z})({self.ht})({self.sym})'
    def to_yaml(self):
        return r'{'+f'z: {self.z}, ht: {self.ht}, sym: {self.sym}'+r'}'
        
def boc(b):
    if b==1:
        return '-'
    elif b==2:
        return '='
    elif b==3:
        return 'â‰¡'
    else:
        return ''

class CappingBond:
    def __init__(self,jsondict):
        self.pairnames=jsondict["pair"]
        self.bondorder=jsondict.get("order",1)
        self.deletes=jsondict.get("deletes",[])
    def to_yaml(self):
        return r'{'+f'pair: {self.pairnames}, order: {self.bondorder}, deletes: {self.deletes}'+r'}'
    def __str__(self):
        s=self.pairnames[0]+boc(self.bondorder)+self.pairnames[1]
        if len(self.deletes)>0:
            s+=' D['+','.join(self.deletes)+']'
        return s

class Monomer:
    def __init__(self,jsondict,name=''):
        self.name=jsondict.get("name",name)
        self.Topology={}
        self.Topology["active"]=None
        self.Coords={}
        self.Coords["active"]=None
        self.reactive_atoms={name:ReactiveAtom(data,name=name) for name,data in jsondict["reactive_atoms"].items()}
        if "capping_bonds" in jsondict:
            self.capping_bonds=[CappingBond(data) for data in jsondict["capping_bonds"]]
            self.Topology["inactive"]=None
            self.Coords["inactive"]=None
        else:
            self.capping_bonds=[]

    def update_atom_specs(self,newmol2,oldmol2):
        ''' Atom specifications from the configuration file refer to atom names in the
            user-provided mol2 files.  After processing via ambertools, the output mol2
            files have renamed atoms (potentially) in the same order as the atoms in the
            user-provided mol3.  This method updates the user-provided atom specifications
            so that they reflect the atom names generated by ambertools. '''
        oa=oldmol2.D['atoms']
        na=newmol2.D['atoms']
        for n,d in self.reactive_atoms.items():
            idx=oa[oa['atomName']==n]['globalIdx'].values[0]
            nn=na[na['globalIdx']==idx]['atomName'].values[0]
            t=d
            self.reactive_atoms[n]=None
            self.reactive_atoms[nn]=t
        for c in self.capping_bonds:
            p=c.pairnames
            newpairnames=[]
            for n in p:
                idx=oa[oa['atomName']==n]['globalIdx'].values[0]
                nn=na[na['globalIdx']==idx]['atomName'].values[0]
                newpairnames.append(nn)
            c.pairnames=newpairnames

    def __str__(self):
        s=self.name+'\n'
        for r,a in self.reactive_atoms.items():
            s+=f'   reactive atom: {r}:'+str(a)+'\n'
        for c in self.capping_bonds:
            s+='   cap: '+str(c)+'\n'
        return s

class Reaction:
    def __init__(self,jsondict):
        self.reactants=jsondict.get("reactants",[])
        self.probability=jsondict.get("probability",1.0)
    def __str__(self):
        return 'Reaction: '+'+'.join(self.reactants)+' : '+str(self.probability)

def get_conn(mol):
    conn=[]
    for mrname,mr in mol.reactive_atoms.items():
        ''' check to see if this atom's symmetry partners are already on the list '''
        donotadd=False
        for s in mr.sym:
            if s in conn:
                donotadd=True
        if not donotadd:
            conn.append(mrname)
    return conn

# def nextconn(partners,conns):
#     hic=conns[-1]
#     for i in range(len(partners)):
#         if partners[i]!=hic:
#             break
#     else:
#         return False
#     partners[i]=conns[0] if partners[i]==[] else conns[conns.index(partners[i])+1]
#     print('inside',partners)
#     return True

def react_mol2(m,n,minimize=True):
    ''' m and n are Monomer instances (defined in configuration.py) '''
    if not isinstance(m,Monomer) or not isinstance(n,Monomer):
        raise Exception(f'react_mol2 needs Monomers not {type(m)} and {type(n)}')
    if not 'active' in m.Topology or not 'active' in n.Topology:
        raise Exception('react_mol2 needs Monomers with active topologies')
    if minimize and (not 'active' in m.Coords or not 'active' in n.Coords):
        raise Exception('react_mol2 needs Monomers with active coordinates')

    print(f'react_mol2: {m.name} and {n.name}')
    for basemol,othermol in zip([m,n],[n,m]):
        basera=get_conn(basemol)
        baseconn=[basemol.reactive_atoms[i].z for i in basera]
        otherra=get_conn(othermol)
        # otherconn=[othermol.reactive_atoms[i].z for i in otherra]
        otherra=['']+otherra
        basearr=[]
        for b,z in zip(basera,baseconn):
            basearr.append(list(combinations_with_replacement(otherra,z)))
        print(*basearr)
        o=product(*basearr)
        next(o)
        for oligo in o:
            print('making oligo',oligo)

    return []