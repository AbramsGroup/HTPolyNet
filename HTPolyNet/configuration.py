# -*- coding: utf-8 -*-
"""

read cfg file
@author: huang, abrams

"""
import json
import yaml
import logging
import numpy as np
from copy import deepcopy
from itertools import product

from HTPolyNet.molecule import Molecule, Reaction

# def getOrDie(D,k,basetype=None,subtype=str,source='config'):
#     '''
#     Strict assignment provider from dictionary 'D' at key 'k'.
#     If key k is in dict D, it is cast to type:subtype and returned
#     otherwise, an error is raised
#     '''
#     s=D.get(k,f'Error: Keyword {k} not found in {source}')
#     if not 'Error:' in s:
#         if basetype==list:
#             # print(k,s,type(s))
#             if type(s)==list:
#                 r=list(map(subtype,s))
#             else:
#                 raise KeyError(f'Value at keyword {k} is not type {basetype}.')
#         elif basetype!=list: # ignore subtype
#             if basetype==None:
#                 r=s
#             else:
#                 r=basetype(s)
#     else:
#         raise KeyError(s)
#     return r

class Configuration:
    def __init__(self):
        self.cfgFile = ''
        self.Title = ''
        ''' List of (Molecule, count) '''
        self.initial_composition = []
        ''' Dictionary of name:Molecule '''
        self.molecules = {}
        ''' List of molecules for which symmetry-equivalence is requested '''
        self.use_sea=[]
        ''' List of Reaction instances '''
        self.reactions = []
        ''' all other parameters in cfg file '''
        self.parameters = {}

    @classmethod
    def read(cls,filename):
        extension=filename.split('.')[-1]
        if extension=='json':
            return cls.read_json(filename)
        elif extension=='yaml' or extension=='yml':
            return cls.read_yaml(filename)
        else:
            raise Exception(f'Unknown config file extension {extension}')

    @classmethod
    def read_json(cls,filename):
        inst=cls()
        inst.cfgFile=filename
        with open(filename,'r') as f:
            inst.basedict=json.load(f)
        inst.parse()
        return inst

    @classmethod
    def read_yaml(cls,filename):
        inst=cls()
        inst.cfgFile=filename
        with open(filename,'r') as f:
            inst.basedict=yaml.safe_load(f)
        inst.parse()
        return inst
    
    def parse(self):
        privileged_keys=['reactions','Title','use_sea','initial_composition']
        self.Title=self.basedict.get('Title','No Title Provided')
        ''' reactions must declare molecules '''
        self.reactions=[Reaction(r) for r in self.basedict['reactions']]
        ''' add all products to molecules list '''
        for R in self.reactions:
            ''' any reaction product must be generated by that reaction '''
            if not R.product in self.molecules:
                self.molecules[R.product]=Molecule(R.product,generator=R)
        for R in self.reactions:
            for rkey,r in R.reactants.items():
                ''' reactants do not get assigned generators if they are *only* reactants '''
                if not r in self.molecules:
                    self.molecules[r]=Molecule(r)
                else:
                    logging.info(f'Reactant {r} in reaction {R.name} is already on the global Molecules list')
                    if self.molecules[r].generator:
                        logging.info(f'({r} is a product of reaction {self.molecules[r].generator.name}')
        self.initial_composition=self.basedict.get('initial_composition',[])
        ''' any molecules lists in the initial composition
        may not have been declared in reactions '''
        for item in self.initial_composition:
            m=item['molecule']
            if m not in self.molecules:
                self.molecules[m]=Molecule(m)

        self.use_sea=self.basedict.get('use_sea',[])
        for m in self.use_sea:
            if not m in self.molecules:
                logging.error(f'Configuration {self.cfgFile} references undeclared molecule {m} in use_sea')
                logging.error(f'Molecules must be declared in reactions or initial_composition')
                raise Exception('Configuration error')

        self.privileged_items={}
        for k in privileged_keys:
            self.privileged_items[k]=self.basedict[k]
            del self.basedict[k]

        self.parameters=self.basedict
        return self

    def symmetry_expand_reactions(self):
        extra_reactions=[]
        for R in self.reactions:
            sym_partners={}
            for atom in R.atoms.values():
                atomName=atom['atom']
                resNum=atom['resid']
                molecule=self.molecules[R.reactants[atom['reactant']]]
                # logging.debug('\n'+molecule.Coords.A.to_string())
                logging.debug(f'Symmetry_expand: Reaction {R.name} atomName {atomName} resNum {resNum} molname {molecule.name}')
                #product=self.molecules[R['product']]
                Asea=molecule.Coords.get_atom_attribute('sea-idx',{'atomName':atomName,'resNum':resNum})
                Aclu=molecule.Coords.get_atoms_w_attribute('atomName',{'sea-idx':Asea,'resNum':resNum})
                Aclu=np.delete(Aclu,np.where(Aclu==atomName))
                sp=[atomName]
                for aa in Aclu:
                    sp.append(aa)
                sym_partners[atomName]=sp
            if len(R.reactants)>1: # not intramolecular; make all combinations
                logging.debug(f'sending to product: {[x for x in sym_partners.values()]}')
                P=product(*[x for x in sym_partners.values()])
                O=next(P)
            else: # intramolecular; keep partners together
                logging.debug(f'sym_partners.values() {sym_partners.values()}')
                P=[p for p in zip(*[x for x in sym_partners.values()])]
                O=P[0]
                P=P[1:]
            logging.debug(f'Original atoms for symmetry expansion: {O}')
            idx=1
            for p in P:
                logging.debug(f'Replicating {R.name} using {p}')
                newR=deepcopy(R)
                newR.name+=f'-{idx}'
                newR.product+=f'-{idx}'
                idx+=1
                for a,o in zip(p,O):
                    for atom,oatom in zip(newR.atoms,R.atoms):
                        if R.atoms[oatom]['atom']==o:
                            newR.atoms[atom]['atom']=a
                extra_reactions.append(newR)

        for nR in extra_reactions:
            logging.debug(f'symmetry-derived reaction {nR.name} atoms {nR.atoms}')
        self.reactions.extend(extra_reactions)

    def calculate_maximum_conversion(self):
        # TODO: fix this fuckin thing
        M=0
        atomset=[]
        for R in self.reactions:
            for b in R.bonds:
                A,B=b['atoms']
                a,b=R.atoms[A],R.atoms[B]
                a['resName']=R.reactants[a['reactant']]
                del a['reactant']
                b['resName']=R.reactants[b['reactant']]
                del b['reactant']
                if not a in atomset:
                    atomset.append(a)
        logging.debug(f'atomset: {atomset}')

        #         za,zb=R.atoms[A]['z'],R.atoms[B]['z']
        #         rA,rB=R.reactants[a['reactant']],R.reactants[b['reactant']]
        #         if rA!=rB: # ignore intramolecular reactions
        #             nrA=nrB=0
        #             for m in self.initial_composition:
        #                 if m['molecule']==rA:
        #                     nrA=m['count']
        #                 elif m['molecule']==rB:
        #                     nrB=m['count']
        #             nza=nrA*za
        #             nzb=nrB*zb
        #             if not a in zBank:
        #                 zBank[a]=0
        #             zBank[a]+=nza
        #             if not b in zBank:
        #                 zBank[b]=0
        #             zBank[b]+=nzb
                    
        #             nza_avail=min(nza,zBank[a])
        #             nzb_avail=min(nzb,zBank[b])
        #             b['maxconv']=np.min([nza_avail,nzb_avail])
        #             logging.debug(f'bonds possible for {R.name}{b}: {b["maxconv"]}')
        #             M+=b['maxconv']
        #             zBank[a]-=nza_avail
        #             zBank[b]-=nza_avail
        #             bal=nrA*Az-nrB*Bz
        #             if bal>0:
        #                 b['limiting-reactant']=rB
        #             elif bal<0:
        #                 b['limiting-reactant']=rA
        #             else:
        #                 b['limiting-reactant']=None
        # return M
