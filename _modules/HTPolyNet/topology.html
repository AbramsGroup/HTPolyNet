<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTPolyNet.topology &#8212; HTPolyNet 1.0.9 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=0abd802e"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for HTPolyNet.topology</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: topology</span>
<span class="sd">   :synopsis: Class for managing gromacs .top file data</span>
<span class="sd">   </span>
<span class="sd">.. moduleauthor: Cameron F. Abrams, &lt;cfa22@drexel.edu&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">physical_constants</span>
<span class="kn">from</span> <span class="nn">networkx.readwrite</span> <span class="kn">import</span> <span class="n">json_graph</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.bondlist</span> <span class="kn">import</span> <span class="n">Bondlist</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.ring</span> <span class="kn">import</span> <span class="n">Ring</span><span class="p">,</span> <span class="n">RingList</span>

<span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">_PAD_</span><span class="o">=-</span><span class="mf">99.99</span>

<div class="viewcode-block" id="typeorder">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.typeorder">[docs]</a>
<span class="k">def</span> <span class="nf">typeorder</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;typeorder correctly order the tuple of atom types for particular</span>
<span class="sd">        interaction types to maintain sorted type dataframes</span>

<span class="sd">    :param a: tuple of atom indicies/types from a [ bond ], [ pair ], [ angle ], or [ dihedral ] record</span>
<span class="sd">    :type a: tuple</span>
<span class="sd">    :return: same atom indices/types correctly ordered to allow for easy searching/sorting</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="nb">tuple</span><span class="p">,</span> <span class="s1">&#39;error: typeorder() requires a tuple argument&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># bond</span>
        <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span> <span class="c1"># angle</span>
        <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span> <span class="c1"># dihedral</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">else</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<span class="n">idxorder</span><span class="o">=</span><span class="n">typeorder</span>  <span class="c1"># same syntax to order global atom indices in an interaction index</span>

<div class="viewcode-block" id="repeat_check">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.repeat_check">[docs]</a>
<span class="k">def</span> <span class="nf">repeat_check</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;repeat_check Check for repeated index tuples</span>

<span class="sd">    :param t: list of index tuples</span>
<span class="sd">    :type t: list</span>
<span class="sd">    :param msg: optional message, defaults to &#39;&#39;</span>
<span class="sd">    :type msg: str, optional</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
            <span class="k">assert</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="sa">f</span><span class="s1">&#39;Error: repeated index in </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s1">-tuple </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1">: t(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">)=</span><span class="si">{</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s1">&#39;</span></div>


<div class="viewcode-block" id="df_typeorder">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.df_typeorder">[docs]</a>
<span class="k">def</span> <span class="nf">df_typeorder</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">typs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;df_typeorder type-orders the atom type attributes in each row of dataframe df</span>

<span class="sd">    :param df: a Topology type-directive dataframe; [ atomtypes ], [ bondtypes ], etc.</span>
<span class="sd">    :type df: pandas.DataFrame</span>
<span class="sd">    :param typs: list of type-attribute names; typically [&#39;i&#39;,&#39;j&#39;,...]</span>
<span class="sd">    :type typs: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">typs</span><span class="p">]</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">typs</span><span class="p">]))</span></div>


<span class="n">_GromacsIntegers_</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;nr&#39;</span><span class="p">,</span><span class="s1">&#39;atnum&#39;</span><span class="p">,</span><span class="s1">&#39;resnr&#39;</span><span class="p">,</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">,</span><span class="s1">&#39;#mols&#39;</span><span class="p">,</span><span class="s1">&#39;nrexcl&#39;</span><span class="p">,</span><span class="s1">&#39;funct&#39;</span><span class="p">,</span><span class="s1">&#39;func&#39;</span><span class="p">,</span><span class="s1">&#39;nbfunc&#39;</span><span class="p">,</span><span class="s1">&#39;comb-rule&#39;</span><span class="p">)</span>
<span class="n">_GromacsFloats_</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;charge&#39;</span><span class="p">,</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span><span class="s1">&#39;chargeB&#39;</span><span class="p">,</span><span class="s1">&#39;massB&#39;</span><span class="p">,</span><span class="o">*</span><span class="nb">tuple</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;c</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]),</span>
                 <span class="s1">&#39;b0&#39;</span><span class="p">,</span><span class="s1">&#39;kb&#39;</span><span class="p">,</span><span class="s1">&#39;th0&#39;</span><span class="p">,</span><span class="s1">&#39;cth&#39;</span><span class="p">,</span><span class="s1">&#39;rub&#39;</span><span class="p">,</span><span class="s1">&#39;kub&#39;</span><span class="p">,</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span><span class="s1">&#39;kd&#39;</span><span class="p">,</span><span class="s1">&#39;pn&#39;</span><span class="p">,</span><span class="s1">&#39;fudgeLJ&#39;</span><span class="p">,</span><span class="s1">&#39;fudgeQQ&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="typedata">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.typedata">[docs]</a>
<span class="k">def</span> <span class="nf">typedata</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">s</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">_GromacsIntegers_</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">_GromacsFloats_</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>


<span class="n">_GromacsExtensiveDirectives_</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span><span class="s1">&#39;pairs&#39;</span><span class="p">,</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span>
<span class="n">_NonGromacsExtensiveDirectives_</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span>
<span class="n">_GromacsTopologyDirectiveOrder_</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;defaults&#39;</span><span class="p">,</span><span class="s1">&#39;atomtypes&#39;</span><span class="p">,</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">,</span><span class="s1">&#39;angletypes&#39;</span><span class="p">,</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">,</span><span class="s1">&#39;moleculetype&#39;</span><span class="p">,</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span><span class="s1">&#39;pairs&#39;</span><span class="p">,</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">,</span><span class="s1">&#39;system&#39;</span><span class="p">,</span><span class="s1">&#39;molecules&#39;</span><span class="p">]</span>
<span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;atoms&#39;</span><span class="p">:[</span><span class="s1">&#39;nr&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span> <span class="s1">&#39;resnr&#39;</span><span class="p">,</span> <span class="s1">&#39;residue&#39;</span><span class="p">,</span> <span class="s1">&#39;atom&#39;</span><span class="p">,</span> <span class="s1">&#39;cgnr&#39;</span><span class="p">,</span> <span class="s1">&#39;charge&#39;</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span><span class="p">,</span><span class="s1">&#39;typeB&#39;</span><span class="p">,</span> <span class="s1">&#39;chargeB&#39;</span><span class="p">,</span> <span class="s1">&#39;massB&#39;</span><span class="p">],</span>
    <span class="s1">&#39;pairs&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">,</span> <span class="s1">&#39;funct&#39;</span><span class="p">,</span> <span class="s1">&#39;c0&#39;</span><span class="p">,</span> <span class="s1">&#39;c1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;bonds&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">,</span> <span class="s1">&#39;funct&#39;</span><span class="p">,</span> <span class="s1">&#39;c0&#39;</span><span class="p">,</span> <span class="s1">&#39;c1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;angles&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">,</span> <span class="s1">&#39;ak&#39;</span><span class="p">,</span> <span class="s1">&#39;funct&#39;</span><span class="p">,</span> <span class="s1">&#39;c0&#39;</span><span class="p">,</span> <span class="s1">&#39;c1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;dihedrals&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">,</span> <span class="s1">&#39;ak&#39;</span><span class="p">,</span> <span class="s1">&#39;al&#39;</span><span class="p">,</span> <span class="s1">&#39;funct&#39;</span><span class="p">,</span> <span class="s1">&#39;c0&#39;</span><span class="p">,</span> <span class="s1">&#39;c1&#39;</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span><span class="p">,</span> <span class="s1">&#39;c3&#39;</span><span class="p">,</span> <span class="s1">&#39;c4&#39;</span><span class="p">,</span> <span class="s1">&#39;c5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;atomtypes&#39;</span><span class="p">:[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;atnum&#39;</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;charge&#39;</span><span class="p">,</span> <span class="s1">&#39;ptype&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">],</span>
    <span class="s1">&#39;moleculetype&#39;</span><span class="p">:[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;nrexcl&#39;</span><span class="p">],</span>
    <span class="s1">&#39;bondtypes&#39;</span><span class="p">:[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;func&#39;</span><span class="p">,</span><span class="s1">&#39;b0&#39;</span><span class="p">,</span><span class="s1">&#39;kb&#39;</span><span class="p">],</span>
    <span class="s1">&#39;angletypes&#39;</span><span class="p">:[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;func&#39;</span><span class="p">,</span><span class="s1">&#39;th0&#39;</span><span class="p">,</span><span class="s1">&#39;cth&#39;</span><span class="p">,</span><span class="s1">&#39;rub&#39;</span><span class="p">,</span><span class="s1">&#39;kub&#39;</span><span class="p">],</span>
    <span class="s1">&#39;dihedraltypes&#39;</span><span class="p">:[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;l&#39;</span><span class="p">,</span><span class="s1">&#39;func&#39;</span><span class="p">,</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span><span class="s1">&#39;kd&#39;</span><span class="p">,</span><span class="s1">&#39;pn&#39;</span><span class="p">],</span>
    <span class="s1">&#39;system&#39;</span><span class="p">:[</span><span class="s1">&#39;Name&#39;</span><span class="p">],</span>
    <span class="s1">&#39;molecules&#39;</span><span class="p">:[</span><span class="s1">&#39;Compound&#39;</span><span class="p">,</span><span class="s1">&#39;#mols&#39;</span><span class="p">],</span>
    <span class="s1">&#39;defaults&#39;</span><span class="p">:[</span><span class="s1">&#39;nbfunc&#39;</span><span class="p">,</span><span class="s1">&#39;comb-rule&#39;</span><span class="p">,</span><span class="s1">&#39;gen-pairs&#39;</span><span class="p">,</span><span class="s1">&#39;fudgeLJ&#39;</span><span class="p">,</span><span class="s1">&#39;fudgeQQ&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">_GromacsTopologyHashables_</span><span class="o">=</span><span class="p">{</span> <span class="c1"># attributes/columns that should always have values, no NaNs; these are how each item is sorted</span>
    <span class="s1">&#39;atoms&#39;</span><span class="p">:[</span><span class="s1">&#39;nr&#39;</span><span class="p">],</span>
    <span class="s1">&#39;pairs&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">],</span>
    <span class="s1">&#39;bonds&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">],</span>
    <span class="s1">&#39;angles&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">,</span> <span class="s1">&#39;ak&#39;</span><span class="p">],</span>
    <span class="s1">&#39;dihedrals&#39;</span><span class="p">:[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span> <span class="s1">&#39;aj&#39;</span><span class="p">,</span> <span class="s1">&#39;ak&#39;</span><span class="p">,</span> <span class="s1">&#39;al&#39;</span><span class="p">,],</span>
    <span class="s1">&#39;atomtypes&#39;</span><span class="p">:[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
    <span class="s1">&#39;bondtypes&#39;</span><span class="p">:[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">],</span>
    <span class="s1">&#39;angletypes&#39;</span><span class="p">:[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">],</span>
    <span class="s1">&#39;dihedraltypes&#39;</span><span class="p">:[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;l&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">_GromacsTopologyDirectiveDefaults_</span><span class="o">=</span><span class="p">{</span>
    <span class="s1">&#39;system&#39;</span><span class="p">:[</span><span class="s1">&#39;A_generic_system&#39;</span><span class="p">],</span>
    <span class="s1">&#39;molecules&#39;</span><span class="p">:[</span><span class="s1">&#39;None&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="s1">&#39;moleculetype&#39;</span><span class="p">:[</span><span class="s1">&#39;None&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="s1">&#39;defaults&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.83333333</span><span class="p">]</span>
<span class="p">}</span>

<div class="viewcode-block" id="select_topology_type_option">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.select_topology_type_option">[docs]</a>
<span class="k">def</span> <span class="nf">select_topology_type_option</span><span class="p">(</span><span class="n">options</span><span class="p">,</span><span class="n">typename</span><span class="o">=</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">,</span><span class="n">rule</span><span class="o">=</span><span class="s1">&#39;stiffest&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;select_topology_type_option select from a list of topological interaction options of type typename using the provided rule</span>

<span class="sd">    :param options: list of parameterization options for a particular interaction</span>
<span class="sd">    :type options: list</span>
<span class="sd">    :param typename: string designation of interaction type, defaults to &#39;dihedraltypes&#39;</span>
<span class="sd">    :type typename: str, optional</span>
<span class="sd">    :param rule: string describing the selection rule, defaults to &#39;stiffest&#39;</span>
<span class="sd">    :type rule: str, optional</span>
<span class="sd">    :return: the selection parameterization option</span>
<span class="sd">    :rtype: element of options (dict)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hashables</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
    <span class="n">headers</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">:</span>
        <span class="n">headers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rule</span><span class="o">==</span><span class="s1">&#39;stiffest&#39;</span> <span class="ow">or</span> <span class="n">rule</span><span class="o">==</span><span class="s1">&#39;softest&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">typename</span><span class="o">==</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">:</span>
            <span class="n">parindex</span><span class="o">=</span><span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;kb&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">typename</span><span class="o">==</span><span class="s1">&#39;angletypes&#39;</span><span class="p">:</span>
            <span class="n">parindex</span><span class="o">=</span><span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;cth&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">typename</span><span class="o">==</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">:</span>
            <span class="n">parindex</span><span class="o">=</span><span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;kd&#39;</span><span class="p">)</span>
    <span class="n">sorted_options</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">options</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">parindex</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">rule</span><span class="o">==</span><span class="s1">&#39;stiffest&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_options</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">rule</span><span class="o">==</span><span class="s1">&#39;softest&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sorted_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="Topology">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology">[docs]</a>
<span class="k">class</span> <span class="nc">Topology</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Class for handling gromacs top data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">system_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;__init__ Constructor for Topology class</span>

<span class="sd">        :param system_name: optional name of system, defaults to &#39;&#39;</span>
<span class="sd">        :type system_name: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; D: a dictionay keyed on Gromacs topology directives with values that are lists of</span>
<span class="sd">               one or more pandas dataframes corresponding to sections &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">_GromacsTopologyDirectiveDefaults_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">hdr</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">dfdict</span><span class="o">=</span><span class="p">{</span><span class="n">kk</span><span class="p">:[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">kk</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span><span class="n">v</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">dfdict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:[</span><span class="n">system_name</span><span class="p">]})</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; bondlist: a class that owns a dictionary keyed on atom global index with values that are lists of global atom indices bound to the key &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residue_network</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">=</span><span class="n">RingList</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="o">=</span><span class="kc">True</span>

<div class="viewcode-block" id="Topology.read_top">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.read_top">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_top</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">pad</span><span class="o">=</span><span class="n">_PAD_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_top Reads a Gromacs-style topology file &#39;filename&#39; and returns a dictionary keyed on directive names.</span>
<span class="sd">        Each value in the dictionary is a pandas dataframe.  Each</span>
<span class="sd">        dataframe represents an individual section found with its directive in the file, with columns corresponding to the fields in the section.  Note that the we allow for input topology/itp files to have two &#39;dihedrals&#39; and &#39;dihedraltypes&#39; sections; these</span>
<span class="sd">        are merged in the result.</span>

<span class="sd">        :param filename: name of gromacs top file to read</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :raises KeyError: If an unrecognized topology directive is encountered, program exits on error</span>
<span class="sd">        :return: a Topology instance</span>
<span class="sd">        :rtype: Topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Error: </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1"> not found.&#39;</span>
        <span class="n">inst</span><span class="o">=</span><span class="bp">cls</span><span class="p">()</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span>
        <span class="n">dirname</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">includes</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)</span>
            <span class="n">stanzas</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stanzas</span><span class="p">:</span>
                <span class="n">directive</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">contentlines</span><span class="o">=</span><span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">))]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">directive</span> <span class="ow">in</span> <span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unrecognized topology directive &quot;</span><span class="si">{</span><span class="n">directive</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
                <span class="n">header</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span>
                <span class="n">series</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">header</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">contentlines</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#include&#39;</span><span class="p">):</span>
                        <span class="n">tokens</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                        <span class="n">inst</span><span class="o">.</span><span class="n">includes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
                        <span class="k">continue</span>
                    <span class="c1"># ignore anything after a &#39;;&#39;</span>
                    <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">directive</span><span class="o">!=</span><span class="s1">&#39;system&#39;</span><span class="p">:</span>  <span class="c1"># no need to split line</span>
                        <span class="n">tokens</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tokens</span><span class="o">=</span><span class="p">[</span><span class="n">line</span><span class="p">]</span>
                    <span class="n">padded</span><span class="o">=</span><span class="p">[</span><span class="n">typedata</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span><span class="n">header</span><span class="p">)]</span>
                    <span class="c1"># pad row so that it is same length as series</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)):</span>
                        <span class="n">padded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pad</span><span class="p">)</span>
                    <span class="c1"># logger.debug(f&#39;padded row: {padded}&#39;)</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">padded</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Error: Padding solution does not work! </span><span class="si">{</span><span class="n">directive</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">padded</span><span class="p">)</span><span class="si">}</span><span class="s1">!=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">header</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">header</span><span class="p">,</span><span class="n">padded</span><span class="p">):</span>
                        <span class="n">series</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">tdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">directive</span><span class="o">==</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">directive</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                        <span class="c1"># logger.info(f&#39;Found second set of {len(tdf)} [ dihedraltypes ] in {inst.filename}; merging into set of {len(inst.D[&quot;dihedraltypes&quot;])} types already read in...&#39;)</span>
                        <span class="c1"># we have already read-in a dihedraltypes section</span>
                        <span class="c1"># so let&#39;s append this one</span>
                        <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">],</span><span class="n">tdf</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
                        <span class="c1"># logger.info(f&#39;    -&gt; now there are {len(inst.D[&quot;dihedraltypes&quot;])} dihedral types.&#39;)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">=</span><span class="n">tdf</span>
                <span class="k">elif</span> <span class="n">directive</span><span class="o">==</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">:</span>
                    <span class="c1"># if there is already a dihedrals section, assume</span>
                    <span class="k">if</span> <span class="n">directive</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                        <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">],</span><span class="n">tdf</span><span class="p">],</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">=</span><span class="n">tdf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">=</span><span class="n">tdf</span>
            <span class="c1"># we must assume the &#39;atoms&#39; are sorted by global index; however, all other</span>
            <span class="c1"># sections need not be sorted.  For convenience, we will keep them sorted by</span>
            <span class="c1"># atom indices or atom type name, where appropriate.</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;read from </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;atomtypes&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atomtypes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atomtypes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="o">.</span><span class="n">fromDataFrame</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;bondtypes&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">df_typeorder</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">],</span><span class="n">typs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">])</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;pairs&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;pairtypes&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">df_typeorder</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairtypes&#39;</span><span class="p">],</span><span class="n">typs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">])</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairtypes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairtypes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;angles&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;angletypes&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">df_typeorder</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angletypes&#39;</span><span class="p">],</span><span class="n">typs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">])</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angletypes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angletypes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;dihedrals&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;dihedraltypes&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">df_typeorder</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">],</span><span class="n">typs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;l&#39;</span><span class="p">])</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;k&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;l&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">includes</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">Topology</span><span class="o">.</span><span class="n">read_top</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirname</span><span class="p">,</span><span class="n">f</span><span class="p">)))</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">empty</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">return</span> <span class="n">inst</span></div>


<div class="viewcode-block" id="Topology.bond_source_check">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.bond_source_check">[docs]</a>
    <span class="k">def</span> <span class="nf">bond_source_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bond_source_check Checks to ensure the &#39;bonds&#39; dataframe and &#39;mol2_bonds&#39; dataframe contain the same bonds.  A mol2 dataframe is only created when a mol2 file is read by the Coordinates module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">and</span> <span class="s1">&#39;mol2_bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="c1"># logger.debug(f&#39;Consistency check between gromacs-top bonds and mol2-bonds requested.&#39;)</span>
            <span class="n">grobonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span>
            <span class="n">bmi</span><span class="o">=</span><span class="n">grobonds</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span>
            <span class="n">mol2bonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span>
            <span class="n">mbmi</span><span class="o">=</span><span class="n">mol2bonds</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span>
            <span class="n">check</span><span class="o">=</span><span class="nb">all</span><span class="p">([</span><span class="n">x</span><span class="o">==</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bmi</span><span class="p">,</span><span class="n">mbmi</span><span class="p">)])</span>
            <span class="c1"># logger.debug(f&#39;Result: {check}&#39;)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Gromacs/Mol2 bond inconsistency detected&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;GROMACS:&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">grobonds</span><span class="p">[[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;MOL2:&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">mol2bonds</span><span class="p">[[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bmi</span><span class="p">,</span><span class="n">mbmi</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.shiftatomsidx">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.shiftatomsidx">[docs]</a>
    <span class="k">def</span> <span class="nf">shiftatomsidx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idxshift</span><span class="p">,</span><span class="n">directive</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;shiftatomsidx shifts all atoms indexes in topology directive dataframe</span>

<span class="sd">        :param idxshift: integer index shift</span>
<span class="sd">        :type idxshift: int</span>
<span class="sd">        :param directive: name of gromacs topology directive (&#39;atoms&#39;,&#39;bonds&#39;,&#39;pairs&#39;,&#39;angles&#39;,&#39;dihedrals&#39;)</span>
<span class="sd">        :type directive: string</span>
<span class="sd">        :param rows: row boundaries, defaults to []</span>
<span class="sd">        :type rows: list, optional</span>
<span class="sd">        :param idxlabels: names of columns that contain atom indexes, defaults to []</span>
<span class="sd">        :type idxlabels: list, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">directive</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">idxlabels</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">rows</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cols</span><span class="p">]</span><span class="o">+=</span><span class="n">idxshift</span></div>


<div class="viewcode-block" id="Topology.detect_rings">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.detect_rings">[docs]</a>
    <span class="k">def</span> <span class="nf">detect_rings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;detect_rings detect unique rings in the topology</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">=</span><span class="n">RingList</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">chordless_cycles</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ring</span><span class="p">(</span><span class="n">c</span><span class="p">))</span></div>


<div class="viewcode-block" id="Topology.read_tpx">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.read_tpx">[docs]</a>
    <span class="k">def</span> <span class="nf">read_tpx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Error: </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1"> not found.&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;[&#39;</span><span class="p">)</span>
            <span class="n">stanzas</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;[&#39;</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stanzas</span><span class="p">:</span>
                <span class="n">directive</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">contentlines</span><span class="o">=</span><span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">))]</span>
                <span class="k">if</span> <span class="n">directive</span><span class="o">==</span><span class="s1">&#39;rings&#39;</span><span class="p">:</span>
                    <span class="c1"># each line is a space-delimited list of global atom indices that identifies one ring</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">=</span><span class="n">RingList</span><span class="p">([])</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">contentlines</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ring</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;tpx directive </span><span class="si">{</span><span class="n">directive</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1"> is not recognized.&#39;</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Topology.write_tpx">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.write_tpx">[docs]</a>
    <span class="k">def</span> <span class="nf">write_tpx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;[ rings ]</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">idx</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.rep_ex">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.rep_ex">[docs]</a>
    <span class="k">def</span> <span class="nf">rep_ex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replicate extensive topology components (atoms, pairs, bonds, angles, dihedrals)</span>

<span class="sd">        :param count: number of replicas to generate, defaults to 0</span>
<span class="sd">        :type count: int, optional</span>
<span class="sd">        :raises Exception: Dies if self is missing an atoms dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">count</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">counts</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_GromacsExtensiveDirectives_</span><span class="p">}</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_NonGromacsExtensiveDirectives_</span><span class="p">})</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_GromacsExtensiveDirectives_</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                    <span class="n">counts</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_NonGromacsExtensiveDirectives_</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                        <span class="n">counts</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idxshift</span><span class="o">=</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Error: expected an &quot;atoms&quot; dataframe&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_GromacsExtensiveDirectives_</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]]</span><span class="o">*</span><span class="n">count</span><span class="p">,</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">new_rings</span><span class="o">=</span><span class="n">RingList</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">count</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;resnr&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;pairs&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shiftatomsidx</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">,</span><span class="n">rows</span><span class="o">=</span><span class="p">[(</span><span class="n">c</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]),((</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">counts</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">])],</span><span class="n">idxlabels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">])</span>
                <span class="n">new_ringblock</span><span class="o">=</span><span class="n">RingList</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="p">:</span>
                    <span class="n">new_ringblock</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">idxshift</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
                <span class="n">new_rings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_ringblock</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_rings</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="o">.</span><span class="n">fromDataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Topology.from_ex">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.from_ex">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ex</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;from_ex make a new Topology instance by copying only the extensive dataframes</span>
<span class="sd">            from an existing topology, plust the bondlist and ringlist</span>

<span class="sd">        :param other: the other topology</span>
<span class="sd">        :type other: Topology</span>
<span class="sd">        :return: a new Topology generated by the extensive dataframes of other</span>
<span class="sd">        :rtype: Topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; &#39;&#39;&#39;</span>
        <span class="n">inst</span><span class="o">=</span><span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">_GromacsExtensiveDirectives_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="o">.</span><span class="n">fromDataFrame</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">rings</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">rings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inst</span></div>


<div class="viewcode-block" id="Topology.write_top">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.write_top">[docs]</a>
    <span class="k">def</span> <span class="nf">write_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write topology to a gromacs-format top file</span>

<span class="sd">        :param filename: name of top file to write</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This is required as of pandas v 2.2.0 to suppress an annoying warning</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">set_option</span><span class="p">(</span><span class="s1">&#39;future.no_silent_downcasting&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;writing </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;; Gromacs-format topology written by HTPolyNet</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s1">&#39;defaults&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="s1">&#39;Error: no [ defaults ] in topology?&#39;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_GromacsTopologyDirectiveOrder_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="c1"># columns=_GromacsTopologyDirectiveHeaders_[k]</span>
                <span class="c1"># replace pads with NA so that no bytes are written by to_csv for these fields</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">_PAD_</span><span class="p">,</span><span class="n">pd</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;[ </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> ]</span><span class="se">\n</span><span class="s1">; &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_GromacsTopologyHashables_</span><span class="p">:</span>
                    <span class="n">odf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">odf</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">doublequote</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">doublequote</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">NA</span><span class="p">,</span><span class="n">_PAD_</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;; end</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.null_check">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.null_check">[docs]</a>
    <span class="k">def</span> <span class="nf">null_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Paranoid checking for NaNs in dataframe locations that SHOULD NEVER HAVE NANS</span>

<span class="sd">        :param msg: a nice message, defaults to &#39;&#39;</span>
<span class="sd">        :type msg: str, optional</span>
<span class="sd">        :raises Exception: exits if a NaN is found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_GromacsTopologyDirectiveOrder_</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_GromacsTopologyHashables_</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">check</span><span class="o">=</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span>
                        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s1"> null in </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;NaN error&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.total_charge">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.total_charge">[docs]</a>
    <span class="k">def</span> <span class="nf">total_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute and return total system charge</span>

<span class="sd">        :return: charge</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Topology.adjust_charges">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.adjust_charges">[docs]</a>
    <span class="k">def</span> <span class="nf">adjust_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="p">[],</span><span class="n">desired_charge</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">overcharge_threshhold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust atom partial charges a tiny bit so that total system charge is zero</span>

<span class="sd">        :param desired_charge: target system charge, defaults to 0.0</span>
<span class="sd">        :type desired_charge: float, optional</span>
<span class="sd">        :param overcharge_threshhold: threshold overcharge that triggers a message, defaults to 0.1</span>
<span class="sd">        :type overcharge_threshhold: float, optional</span>
<span class="sd">        :param msg: A message to write if pre-adjusted system charge is too high, defaults to &#39;&#39;</span>
<span class="sd">        :type msg: str, optional</span>
<span class="sd">        :return: self topology</span>
<span class="sd">        :rtype: Topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">apparent_charge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">total_charge</span><span class="p">()</span>
        <span class="n">overcharge</span><span class="o">=</span><span class="n">apparent_charge</span><span class="o">-</span><span class="n">desired_charge</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjusting charges of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="si">}</span><span class="s1"> atoms due to overcharge of </span><span class="si">{</span><span class="n">overcharge</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">overcharge</span><span class="p">)</span><span class="o">&gt;</span><span class="n">overcharge_threshhold</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">cpa</span><span class="o">=-</span><span class="n">overcharge</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Adjustment is </span><span class="si">{</span><span class="n">cpa</span><span class="si">:</span><span class="s1">.4e</span><span class="si">}</span><span class="s1"> per atom&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">cpa</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;New total charge after adjustment: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">total_charge</span><span class="p">()</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

        
<div class="viewcode-block" id="Topology.total_mass">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.total_mass">[docs]</a>
    <span class="k">def</span> <span class="nf">total_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;gromacs&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns total mass of all atoms in the Topology.</span>

<span class="sd">        :param units: unit system designation; if &#39;SI&#39; returns kg, defaults to &#39;gromacs&#39;</span>
<span class="sd">        :type units: str, optional</span>
<span class="sd">        :return: mass (in amu if units is &#39;gromacs&#39; or kg if units is &#39;SI&#39;)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fac</span><span class="o">=</span><span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">units</span><span class="o">==</span><span class="s1">&#39;SI&#39;</span><span class="p">:</span>
            <span class="n">fac</span><span class="o">=</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;atomic mass constant&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="n">M_amu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mass </span><span class="si">{</span><span class="n">M_amu</span><span class="si">}</span><span class="s1"> fac </span><span class="si">{</span><span class="n">fac</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">M_amu</span><span class="o">*</span><span class="n">fac</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>


<div class="viewcode-block" id="Topology.atomcount">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.atomcount">[docs]</a>
    <span class="k">def</span> <span class="nf">atomcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;atomcount Returns the total number of atoms</span>

<span class="sd">        :return: number of atoms</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="mi">0</span></div>

    
<div class="viewcode-block" id="Topology.add_restraints">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.add_restraints">[docs]</a>
    <span class="k">def</span> <span class="nf">add_restraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairdf</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">kb</span><span class="o">=</span><span class="mf">300000.</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add type-6 (non-topoogical) bonds to help drag atoms destined to be bonded</span>
<span class="sd">        closer together in a series of dragging simulations</span>

<span class="sd">        :param pairdf: dataframe of pairs [&#39;ai&#39;,&#39;aj&#39;]</span>
<span class="sd">        :type pairdf: pandas DataFrame</span>
<span class="sd">        :param typ: bond type, defaults to 6</span>
<span class="sd">        :type typ: int, optional</span>
<span class="sd">        :param kb: bond spring constant (kJ/mol/nm^2), defaults to 300000</span>
<span class="sd">        :type kb: float, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bmi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">pairdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]))</span>
            <span class="n">b0</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bmi</span><span class="p">:</span>
                <span class="n">h</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
                <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">,</span><span class="n">typ</span><span class="p">,</span><span class="n">b0</span><span class="p">,</span><span class="n">kb</span><span class="p">]</span>  <span class="c1"># this new bond will have override parameters</span>
                <span class="n">bonddict</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">data</span><span class="p">)}</span>
                <span class="n">bdtoadd</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bonddict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">],</span><span class="n">bdtoadd</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.remove_restraints">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.remove_restraints">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_restraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairdf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all bonds represented in in pairdf.</span>
<span class="sd">        These are interpreted as non-topological</span>
<span class="sd">        restraints, so deleting these &#39;bonds&#39; does </span>
<span class="sd">        not influence angles or dihedrals</span>

<span class="sd">        :param pairdf: dataframe of pairs [&#39;ai&#39;,&#39;aj&#39;]</span>
<span class="sd">        :type pairdf: pandas DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
        <span class="n">to_drop</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">pairdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]))</span>
            <span class="n">to_drop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">aj</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">to_drop</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.add_bonds">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.add_bonds">[docs]</a>
    <span class="k">def</span> <span class="nf">add_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairs</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;add_bonds Adds bonds indicated in list pairs to the topology</span>

<span class="sd">        :param pairs: list of pairs of atom indexes, defaults to []</span>
<span class="sd">        :type pairs: list, optional</span>
<span class="sd">        :raises Exception: dies if an existing bond is in the list of pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(&#39;begins&#39;)</span>
        <span class="n">at</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">ij</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;j&#39;</span><span class="p">])</span>
        <span class="c1">#mb=self.D[&#39;mol2_bonds&#39;]</span>
        <span class="n">bmi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="n">pmi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="n">newbonds</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="c1"># logger.debug(f&#39;{b}&#39;)</span>
            <span class="c1"># assert type(b[0])==int</span>
            <span class="n">bondtuple</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">order</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">(</span><span class="n">bondtuple</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            if this bond is not in the topology, then add it</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bmi</span><span class="p">:</span>
                <span class="n">newbonds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">))</span>
                <span class="c1"># logger.debug(f&#39;asking types of {ai} and {aj}; at.shape {at.shape}&#39;)</span>
                <span class="n">it</span><span class="o">=</span><span class="n">at</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ai</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">jt</span><span class="o">=</span><span class="n">at</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">aj</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
                <span class="n">idx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">((</span><span class="n">it</span><span class="p">,</span><span class="n">jt</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ij</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                    <span class="n">bt</span><span class="o">=</span><span class="n">ij</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="s1">&#39;func&#39;</span><span class="p">]</span>  <span class="c1"># why don&#39;t i need need values[0]</span>
                    <span class="n">kb</span><span class="o">=</span><span class="n">ij</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="s1">&#39;kb&#39;</span><span class="p">]</span>
                    <span class="n">b0</span><span class="o">=</span><span class="n">ij</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="s1">&#39;b0&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no bondtype </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> found; using placeholder parameters&#39;</span><span class="p">)</span>
                    <span class="n">bt</span><span class="o">=</span><span class="mi">1</span>
                    <span class="n">b0</span><span class="o">=</span><span class="mf">0.15</span>
                    <span class="n">kb</span><span class="o">=</span><span class="mi">999999</span>
                    <span class="c1"># raise Exception(f&#39;no bondtype {idx} found.&#39;)</span>
<span class="w">                </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                add a new bond!</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="n">h</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
                <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">,</span><span class="n">bt</span><span class="p">,</span><span class="n">b0</span><span class="p">,</span><span class="n">kb</span><span class="p">]</span>  <span class="c1"># this new bond will have override parameters</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;Error: not enough data for new bond?&#39;</span>
                <span class="n">bonddict</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">data</span><span class="p">)}</span>
                <span class="n">bdtoadd</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bonddict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">],</span><span class="n">bdtoadd</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># logger.info(f&#39;add_bond:\n{bdtoadd.to_string()}&#39;)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;just added </span><span class="si">{</span><span class="n">bonddict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;mol2_bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]),</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># assume single bond</span>
                    <span class="n">bonddict</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">,</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;order&#39;</span><span class="p">],</span><span class="n">data</span><span class="p">)}</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">],</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">bonddict</span><span class="p">)),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># remove this pair from pairs if it&#39;s in there (it won&#39;t be)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">pmi</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: new bond </span><span class="si">{</span><span class="n">ai</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">aj</span><span class="si">}</span><span class="s1"> was evidently in the [ pairs ]!&#39;</span><span class="p">)</span>
                    <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
                    <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">d</span><span class="p">[(</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span><span class="o">.</span><span class="n">index</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Dropping [ pair ]:</span><span class="se">\n</span><span class="si">{</span><span class="n">d</span><span class="p">[</span><span class="n">indexes_to_drop</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">                if it is, do nothing; it will be templated; if mol2_bonds are present (usually</span>
<span class="sd">                because a Topology is part of a molecule being parameterized), update the order</span>
<span class="sd">                of the bond.</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="k">if</span> <span class="s1">&#39;mol2_bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                    <span class="n">mb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span>
                    <span class="n">bi</span><span class="o">=</span><span class="p">(</span><span class="n">mb</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mb</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">)</span>
                    <span class="n">mb</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">bi</span><span class="p">,</span><span class="s1">&#39;order&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">order</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        update the bondlist</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">newbonds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">newbonds</span><span class="p">)</span><span class="si">}</span><span class="s1"> new bonds&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="Topology.delete_atoms">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.delete_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="p">[],</span><span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">return_idx_of</span><span class="o">=</span><span class="p">[],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete atoms from topology</span>

<span class="sd">        :param idx: list of atom indexes to delete, defaults to []</span>
<span class="sd">        :type idx: list, optional</span>
<span class="sd">        :param reindex: reindex atoms after deleting, defaults to True</span>
<span class="sd">        :type reindex: bool, optional</span>
<span class="sd">        :param return_idx_of: list of old indices to report new indices of, defaults to []</span>
<span class="sd">        :type return_idx_of: list, optional</span>
<span class="sd">        :return: old-index-to-new-index mapper</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#logger.debug(f&#39;Delete atoms: {idx}&#39;)</span>
        <span class="n">paranoid_about_pairs</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;paranoid_about_pairs&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;beginning of delete atoms&#39;</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;idx {idx}&#39;)</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">new_idx</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">nr</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">total_missing_charge</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_drop</span><span class="p">][</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_drop</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> [ atoms ]; charge to make up: </span><span class="si">{</span><span class="n">total_missing_charge</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span><span class="c1">#:\n{d.loc[indexes_to_drop].to_string()}&#39;)</span>
        <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mapper</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
            <span class="n">oldGI</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">mapper</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oldGI</span><span class="p">,</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">])}</span>
            <span class="c1"># logger.debug(f&#39;mapper {mapper}&#39;)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]),</span><span class="sa">f</span><span class="s1">&#39;Error: Some deleted atoms in mapper.&#39;</span>
            <span class="n">k</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;null in mapper keys&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;null in mapper values&#39;</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;delete_atoms: mapper {mapper}&#39;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_idx_of</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="c1"># logger.info(f&#39;Asking for updated global indexes of {return_idx_of}&#39;)</span>
                <span class="n">new_idx</span><span class="o">=</span><span class="p">[</span><span class="n">mapper</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">return_idx_of</span><span class="p">]</span>
            <span class="c1">#d[&#39;nr_shift&#39;]=d[&#39;nr&#39;]-oldGI  # probably not necessary</span>
        <span class="n">ptt</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">,</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ptt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
                <span class="c1"># logger.debug(f&#39;delete atom: {pt} df prior to deleting&#39;)</span>
                <span class="c1"># logger.debug(d.to_string())</span>
                <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">d</span><span class="p">[(</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span><span class="o">.</span><span class="n">index</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_drop</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> [ </span><span class="si">{</span><span class="n">pt</span><span class="si">}</span><span class="s1"> ]&#39;</span><span class="p">)</span>
                <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
                    <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="p">]),</span><span class="sa">f</span><span class="s1">&#39;Error: deleted atom survived in </span><span class="si">{</span><span class="n">pt</span><span class="si">}</span><span class="s1"> ai&#39;</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="p">]),</span><span class="sa">f</span><span class="s1">&#39;Error: deleted atom survived in </span><span class="si">{</span><span class="n">pt</span><span class="si">}</span><span class="s1"> aj&#39;</span>
                    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="p">]),</span><span class="sa">f</span><span class="s1">&#39;Error: surviving </span><span class="si">{</span><span class="n">pt</span><span class="si">}</span><span class="s1"> atom ai old idx not in mapper&#39;</span>
                    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="p">]),</span><span class="sa">f</span><span class="s1">&#39;Error: surviving </span><span class="si">{</span><span class="n">pt</span><span class="si">}</span><span class="s1"> atom aj old idx not in mapper&#39;</span>
                    <span class="c1">#logger.debug(f&#39;delete atom: {pt} df prior to reindexing&#39;)</span>
                    <span class="c1">#logger.debug(d.to_string())</span>
                    <span class="c1"># pairs deleted here were deleted because either ai or aj was among </span>
                    <span class="c1"># the atoms to delete.  We assert than any dihedral for which</span>
                    <span class="c1"># the i atom is ai and l atom is aj will necessarily be deleted </span>
                    <span class="c1"># below.  The only other pairs that should be deleted would</span>
                    <span class="c1"># be ones in which the dihedral j or k atom is among those to be </span>
                    <span class="c1"># deleted.  </span>
                    <span class="k">if</span> <span class="n">pt</span><span class="o">!=</span><span class="s1">&#39;pairs&#39;</span><span class="p">:</span> <span class="c1"># don&#39;t remap these yet; need to delete pairs that</span>
                        <span class="c1"># might arise from dihedrals that are deleted.</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
                        <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pt</span><span class="o">==</span><span class="s1">&#39;bonds&#39;</span><span class="p">:</span>
                        <span class="c1"># logger.debug(f&#39;Updating bondlist using (first 10 shown)\n{d.head(10).to_string()}&#39;)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="o">.</span><span class="n">fromDataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pt</span><span class="o">==</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">:</span>
                        <span class="n">nBonds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">pt</span><span class="p">][</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nBonds</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span>
        <span class="c1"># assert d.ai.dtype==int,f&#39;pre-delete lost angle ai dtype {d.ai.dtype}&#39;</span>
        <span class="c1"># assert d.aj.dtype==int,f&#39;pre-delete lost angle aj dtype {d.aj.dtype}&#39;</span>
        <span class="c1"># assert d.ak.dtype==int,f&#39;pre-delete lost angle ak dtype {d.ak.dtype}&#39;</span>
        <span class="c1"># logger.debug(f&#39;ai {d.ai.isin(idx).to_string()}&#39;)</span>
        <span class="c1"># logger.debug(f&#39;aj {d.aj.isin(idx).to_string()}&#39;)</span>
        <span class="c1"># logger.debug(f&#39;ak {d.ak.isin(idx).to_string()}&#39;)</span>
        <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">d</span><span class="p">[(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;ak&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span><span class="o">.</span><span class="n">index</span>
        <span class="c1"># extras=d[d[&#39;ak&#39;].isin(idx)].index</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span><span class="si">}</span><span class="s1"> [ angles ]&#39;</span><span class="p">)</span>
        <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;drop {list(sorted(list(set(indexes_to_drop))))}&#39;)</span>
        <span class="c1"># logger.debug(f&#39;keep {indexes_to_keep}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">dtype</span><span class="o">==</span><span class="nb">int</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;post-delete lost angle ai dtype </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">dtype</span><span class="o">==</span><span class="nb">int</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;post-delete lost angle aj dtype </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">dtype</span><span class="o">==</span><span class="nb">int</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;post-delete lost angle ak dtype </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;inside delete atoms before angles reindex&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="p">]),</span><span class="s1">&#39;Error: deleted atom survived in angle ai&#39;</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="p">]),</span><span class="s1">&#39;Error: deleted atom survived in angle aj&#39;</span>
            <span class="n">zombie_tags</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">zombie_tags</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Zombie ak angles:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s2">&quot;angles&quot;</span><span class="p">][</span><span class="n">zombie_tags</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">zombie_tags</span><span class="p">),</span><span class="s1">&#39;Error: deleted atom survived in angle ak&#39;</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="p">]),</span><span class="s1">&#39;Error: surviving angle atom ai old idx not in mapper&#39;</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="p">]),</span><span class="s1">&#39;Error: surviving angle atom aj old idx not in mapper&#39;</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mapper</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="p">]),</span><span class="s1">&#39;Error: surviving angle atom ak old idx not in mapper&#39;</span>
            <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;inside delete atoms after angles reindex&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span>
        <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">d</span><span class="p">[(</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">al</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_drop</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> [ dihedrals ]&#39;</span><span class="p">)</span>
        <span class="c1"># if the atoms we have deleted are truly just H&#39;s, then there will be no other</span>
        <span class="c1"># spurious pairs after all dihedrals containing deleted atoms are deleted.</span>
        <span class="c1"># However, we may want to still search for such pairs, so let&#39;s leave this</span>
        <span class="c1"># as an option:</span>
        <span class="k">if</span> <span class="n">paranoid_about_pairs</span><span class="p">:</span>
            <span class="n">dp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
            <span class="n">ddp</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indexes_to_drop</span><span class="p">]</span>  <span class="c1"># these are dihedrals marked for deletion</span>
            <span class="c1"># determine pairs deriving from these dihedrals and delete them!</span>
            <span class="n">pai</span><span class="o">=</span><span class="n">ddp</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">pal</span><span class="o">=</span><span class="n">ddp</span><span class="o">.</span><span class="n">al</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">dd</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">pi</span><span class="p">,</span><span class="n">pl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pai</span><span class="p">,</span><span class="n">pal</span><span class="p">):</span>
                <span class="n">dwpi</span><span class="o">=</span><span class="n">dp</span><span class="p">[((</span><span class="n">dp</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">pi</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dp</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">pl</span><span class="p">))</span><span class="o">|</span><span class="p">((</span><span class="n">dp</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">pl</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dp</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">pi</span><span class="p">))]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
                <span class="n">dd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dwpi</span><span class="p">)</span>
            <span class="n">ptk</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">dp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">dwpi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dwpi</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;  -&gt; and deleting </span><span class="si">{</span><span class="n">dp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">dwpi</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> [ pairs ] from those dihedrals&#39;</span><span class="p">)</span>
            <span class="c1"># Note that we expect this to be zero if we are only deleting H&#39;s, since</span>
            <span class="c1"># an H can never be a &#39;j&#39; or &#39;k&#39; in a dihedral!</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dp</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ptk</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span>
            <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">al</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">al</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
            <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">tp</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">pdrops</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="nb">min</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">]),</span><span class="nb">max</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tp</span><span class="p">:</span>
                    <span class="n">tp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pdrops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">pdrops</span><span class="p">)</span><span class="si">}</span><span class="s1"> duplicate 1-4 pair descriptors -- this is likely due to a bug somewhere&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">pdrops</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;end of delete atoms&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;finished.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_idx_of</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_idx</span>
        <span class="k">return</span> <span class="n">mapper</span></div>

        
    <span class="k">def</span> <span class="nf">_myconcat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[],</span><span class="n">idxshift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">drop_duplicates</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directive</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">directive</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="c1"># shift atom indices</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxlabel</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">idxshift</span>
            <span class="k">if</span> <span class="n">drop_duplicates</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">],</span><span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">],</span><span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">directive</span><span class="p">]</span>

<div class="viewcode-block" id="Topology.merge">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.merge">[docs]</a>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge topologies</span>

<span class="sd">        :param other: a topology</span>
<span class="sd">        :type other: Topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(&#39;Topology.merge begins&#39;)</span>
        <span class="c1"># look for duplicated types between self and other.  If any are found, delete those types from other and copy their parameters into the explicit interactions they correspond to.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_ex</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merge_types</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>

        <span class="c1"># logger.debug(&#39;Topology.merge ends&#39;)</span>

    <span class="c1"># def handle_duplicate_types(self,other,copy_directive=&#39;other_to_self&#39;,typename=&#39;&#39;,funcidx=4):</span>
<span class="c1">#         if not typename in self.D or not typename in other.D:</span>
<span class="c1">#             return</span>
<span class="c1">#         stdf=self.D[typename]</span>
<span class="c1">#         otdf=other.D[typename]</span>
<span class="c1">#         hashables=_GromacsTopologyHashables_[typename]</span>
<span class="c1">#         headers=_GromacsTopologyDirectiveHeaders_[typename].copy()</span>
<span class="c1">#         logger.debug(f&#39;{hashables} {headers}&#39;)</span>
<span class="c1">#         for i in hashables:</span>
<span class="c1">#             headers.remove(i)</span>
<span class="c1">#         common=[]</span>
<span class="c1">#         fi=headers.index(&#39;func&#39;)</span>
<span class="c1">#         copy_idx_pairs=[]</span>
<span class="c1">#         for idx,r in otdf.iterrows():</span>
<span class="c1">#             typidx=typeorder(tuple([r[i] for i in hashables]))</span>
<span class="c1">#             idata=[r[i] for i in headers]</span>
<span class="c1">#             for jdx,q in stdf.iterrows():</span>
<span class="c1">#                 typjdx=typeorder(tuple([q[i] for i in hashables]))</span>
<span class="c1">#                 jdata=[q[i] for i in headers]</span>
<span class="c1">#                 if typidx==typjdx and idata==jdata:</span>
<span class="c1">#                     common.append(typidx)</span>
<span class="c1">#             for jdx,q in stdf.iterrows():</span>
<span class="c1">#                 typjdx=typeorder(tuple([q[i] for i in hashables]))</span>
<span class="c1">#                 jdata=[q[i] for i in headers]</span>
<span class="c1">#                 if typidx==typjdx and idata!=jdata and not typidx in common and idata[fi]==funcidx and jdata[fi]==funcidx:</span>
<span class="c1">#                     logger.debug(f&#39;duplicate {typename} {typidx}&#39;)</span>
<span class="c1">#                     logger.debug(f&#39;o {idx} {idata}&#39;)</span>
<span class="c1">#                     logger.debug(f&#39;s {jdx} {jdata}&#39;)</span>
<span class="c1">#                     if not (idx,jdx) in copy_idx_pairs:</span>
<span class="c1">#                         copy_idx_pairs.append((idx,jdx))</span>
<span class="c1">#         if copy_directive==&#39;other_to_self&#39; and len(copy_idx_pairs)&gt;0:</span>
<span class="c1">#             for o,s in copy_idx_pairs:</span>
<span class="c1">#                 self.D[typename].iloc[s]=other.D[typename].iloc[o]</span>
<span class="c1">#         elif copy_directive==&#39;self_to_other&#39; and len(copy_idx_pairs)&gt;0:</span>
<span class="c1">#             for o,s in copy_idx_pairs:</span>
<span class="c1">#                 other.D[typename].iloc[o]=self.D[typename].iloc[s]</span>
<span class="c1">#           # logger.debug(f&#39;{typidx}&#39;)</span>
<span class="c1"># #        pass</span>
<div class="viewcode-block" id="Topology.report_type">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.report_type">[docs]</a>
    <span class="k">def</span> <span class="nf">report_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">typidx_q</span><span class="p">,</span><span class="n">typename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">funcidx</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">typename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">stdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">hashables</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">headers</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">:</span>
            <span class="n">headers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">fi</span><span class="o">=</span><span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;func&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">stdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">typidx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">]))</span>
            <span class="n">idata</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">typidx</span><span class="o">==</span><span class="n">typidx_q</span> <span class="ow">and</span> <span class="n">idata</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">==</span><span class="n">funcidx</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    &#39;bonds&#39;:        [&#39;ai&#39;, &#39;aj&#39;, &#39;funct&#39;, &#39;c0&#39;, &#39;c1&#39;],</span>
<span class="sd">    &#39;bondtypes&#39;:    [ &#39;i&#39;,  &#39;j&#39;, &#39;func&#39;,  &#39;b0&#39;, &#39;kb&#39;],</span>
<span class="sd">    &#39;angles&#39;:       [&#39;ai&#39;, &#39;aj&#39;, &#39;ak&#39;, &#39;funct&#39;, &#39;c0&#39;,  &#39;c1&#39;],</span>
<span class="sd">    &#39;angletypes&#39;:   [ &#39;i&#39;,  &#39;j&#39;,  &#39;k&#39;, &#39;func&#39;,  &#39;th0&#39;, &#39;cth&#39;, &#39;rub&#39;, &#39;kub&#39;],</span>
<span class="sd">    &#39;dihedrals&#39;:    [&#39;ai&#39;, &#39;aj&#39;, &#39;ak&#39;, &#39;al&#39;, &#39;funct&#39;, &#39;c0&#39;,    &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;c4&#39;, &#39;c5&#39;],</span>
<span class="sd">    &#39;dihedraltypes&#39;:[ &#39;i&#39;,  &#39;j&#39;,  &#39;k&#39;,  &#39;l&#39;, &#39;func&#39;,  &#39;phase&#39;, &#39;kd&#39;, &#39;pn&#39;],</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="Topology.reset_override_from_type">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.reset_override_from_type">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_override_from_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">interactionname</span><span class="p">,</span><span class="n">typename</span><span class="p">,</span><span class="n">inst_idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">typename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">typ_hashables</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">stdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">typ_hashables</span><span class="p">)</span>
        <span class="n">sidf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span>
        <span class="n">typ_headers</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ins_hashables</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span>
        <span class="n">ins_headers</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">typidx</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inst_idx</span><span class="p">]</span>
        <span class="n">typidx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">typidx</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">typ_hashables</span><span class="p">:</span>
            <span class="n">typ_headers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ins_hashables</span><span class="p">:</span>
            <span class="n">ins_headers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">iidx</span><span class="o">=</span><span class="n">idxorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inst_idx</span><span class="p">))</span>
        <span class="n">idx</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">sidf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">jdx</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ins_hashables</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">iidx</span><span class="o">==</span><span class="n">jdx</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">=</span><span class="n">i</span>
                <span class="k">break</span>
        <span class="k">assert</span> <span class="n">idx</span><span class="o">!=-</span><span class="mi">1</span>
        <span class="n">num_data</span><span class="o">=</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">typ_headers</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ins_headers</span><span class="p">)])</span>
        <span class="n">typ_headers</span><span class="o">=</span><span class="n">typ_headers</span><span class="p">[:</span><span class="n">num_data</span><span class="p">]</span>
        <span class="n">ins_headers</span><span class="o">=</span><span class="n">ins_headers</span><span class="p">[:</span><span class="n">num_data</span><span class="p">]</span>
        <span class="n">typrec</span><span class="o">=</span><span class="n">stdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">typidx</span><span class="p">][</span><span class="n">typ_headers</span><span class="p">]</span>
        <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">ins_headers</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Resetting override in </span><span class="si">{</span><span class="n">interactionname</span><span class="si">}</span><span class="s1"> for </span><span class="si">{</span><span class="n">inst_idx</span><span class="si">}</span><span class="s1"> from&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;to&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">cols</span><span class="p">]</span><span class="o">=</span><span class="n">typrec</span>
        <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">interactionname</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">cols</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span></div>

        

<div class="viewcode-block" id="Topology.reset_type">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.reset_type">[docs]</a>
    <span class="k">def</span> <span class="nf">reset_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">typename</span><span class="p">,</span><span class="n">typidx_t</span><span class="p">,</span><span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">typename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">stdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">hashables</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">headers</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">:</span>
            <span class="n">headers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span>
        <span class="n">idxs</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">stdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">typidx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">typidx</span><span class="o">==</span><span class="n">typidx_t</span><span class="p">:</span>
                <span class="n">idxs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Resetting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span><span class="si">}</span><span class="s1"> entries </span><span class="si">{</span><span class="n">headers</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">values</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">cols</span><span class="p">]</span><span class="o">=</span><span class="n">values</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">headers</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.report_duplicate_types">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.report_duplicate_types">[docs]</a>
    <span class="k">def</span> <span class="nf">report_duplicate_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">typename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">funcidx</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">typename</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">typename</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">stdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">otdf</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">hashables</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span>
        <span class="n">headers</span><span class="o">=</span><span class="n">_GromacsTopologyDirectiveHeaders_</span><span class="p">[</span><span class="n">typename</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># logger.debug(f&#39;{hashables} {headers}&#39;)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">:</span>
            <span class="n">headers</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">common</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">fi</span><span class="o">=</span><span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;func&#39;</span><span class="p">)</span>
        <span class="n">true_duplicate_types</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">otdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">typidx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">]))</span>
            <span class="n">idata</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="n">stdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">typjdx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">]))</span>
                <span class="n">jdata</span><span class="o">=</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">typidx</span><span class="o">==</span><span class="n">typjdx</span> <span class="ow">and</span> <span class="n">idata</span><span class="o">==</span><span class="n">jdata</span><span class="p">:</span>
                    <span class="n">common</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typidx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">otdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">typidx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">]))</span>
            <span class="n">idata</span><span class="o">=</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span><span class="n">q</span> <span class="ow">in</span> <span class="n">stdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">typjdx</span><span class="o">=</span><span class="n">typeorder</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">hashables</span><span class="p">]))</span>
                <span class="n">jdata</span><span class="o">=</span><span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">typidx</span><span class="o">==</span><span class="n">typjdx</span> <span class="ow">and</span> <span class="n">idata</span><span class="o">!=</span><span class="n">jdata</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">typidx</span> <span class="ow">in</span> <span class="n">common</span> <span class="ow">and</span> <span class="n">idata</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">==</span><span class="n">funcidx</span> <span class="ow">and</span> <span class="n">jdata</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">==</span><span class="n">funcidx</span><span class="p">:</span>
                    <span class="c1"># logger.debug(f&#39;duplicate {typename} {typidx}&#39;)</span>
                    <span class="n">true_duplicate_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typidx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">true_duplicate_types</span></div>


<div class="viewcode-block" id="Topology.dup_check">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.dup_check">[docs]</a>
    <span class="k">def</span> <span class="nf">dup_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">die</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check for duplicate type-like topology records</span>

<span class="sd">        :param die: flag telling HTPolyNet to exit if duplicate found, defaults to True</span>
<span class="sd">        :type die: bool, optional</span>
<span class="sd">        :raises Exception: Exception raised if duplicate found and die is True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atomtypes&#39;</span><span class="p">,</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">,</span><span class="s1">&#39;angletypes&#39;</span><span class="p">]</span>
        <span class="n">Not</span><span class="o">=</span><span class="s1">&#39; not&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">die</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Checking for duplicate </span><span class="si">{</span><span class="n">L</span><span class="si">}</span><span class="s1">; will</span><span class="si">{</span><span class="n">Not</span><span class="si">}</span><span class="s1"> die if found.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
            <span class="n">i</span><span class="o">=</span><span class="n">_GromacsTopologyHashables_</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; checking for types with duplicate atom-type indices &#39;&#39;&#39;</span>
            <span class="n">dups</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dups</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Duplicate </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1"> with different parameters detected</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">dups</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">die</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;duplicate topology types with different parameters detected&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.merge_types">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.merge_types">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge type-like topology dataframes from other to self</span>

<span class="sd">        :param other: topology containing attribute D, a dictionary of dataframes</span>
<span class="sd">        :type other: Topology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># self.handle_duplicate_types(other,typename=&#39;dihedraltypes&#39;,funcidx=4,drop_directive=&#39;drop_from_self&#39;)</span>
        <span class="n">L</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atomtypes&#39;</span><span class="p">,</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">,</span><span class="s1">&#39;angletypes&#39;</span><span class="p">,</span><span class="s1">&#39;dihedraltypes&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="n">t</span><span class="p">,</span><span class="n">drop_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.merge_ex">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.merge_ex">[docs]</a>
    <span class="k">def</span> <span class="nf">merge_ex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;   extensive merging...&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; merge EXTENSIVE quantities &#39;&#39;&#39;</span>
        <span class="n">idxshift</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span>
        <span class="n">rdxshift</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;atoms&#39;</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">rdxshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;atoms&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">],</span><span class="n">idxshift</span><span class="o">=</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">],</span><span class="n">idxshift</span><span class="o">=</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;mol2_bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="ow">and</span> <span class="s1">&#39;mol2_bonds&#39;</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">bondIdx</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">],</span><span class="n">idxshift</span><span class="o">=</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;pairs&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">],</span><span class="n">idxshift</span><span class="o">=</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">],</span><span class="n">idxshift</span><span class="o">=</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_myconcat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">directive</span><span class="o">=</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">,</span><span class="n">idxlabel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">],</span><span class="n">idxshift</span><span class="o">=</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;merging </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">rings</span><span class="p">)</span><span class="si">}</span><span class="s1"> rings into base list of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="p">)</span><span class="si">}</span><span class="s1"> with idxshift </span><span class="si">{</span><span class="n">idxshift</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">idxshift</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">rings</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.get_atom_attribute">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.get_atom_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atom_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">attribute</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return value of attribute of atom idx</span>

<span class="sd">        :param idx: global atom index</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :param attribute: atom attribute name</span>
<span class="sd">        :type attribute: str</span>
<span class="sd">        :return: atom attribute value</span>
<span class="sd">        :rtype: varies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span></div>


<div class="viewcode-block" id="Topology.get_atomtype">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.get_atomtype">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atomtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get atom type of atom with global index idx</span>

<span class="sd">        :param idx: atom global index</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :return: atom typ</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="c1">#        logger.debug(f&#39;Asking get_atomtype for type of atom with index {idx}&#39;)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span></div>


<div class="viewcode-block" id="Topology.build_interresidue_graph">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.build_interresidue_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">build_interresidue_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">ri</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">ri_at_idx</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ri</span><span class="p">][</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">residues</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">ri_partners</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">rn</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">skip</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">rj_at_idx</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">rn</span><span class="p">][</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">ri_at_idx</span><span class="p">,</span><span class="n">rj_at_idx</span><span class="p">):</span>
                <span class="c1"># logger.debug(f&#39;### {i} in {self.bondlist.partners_of(j)}?&#39;)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">rn</span> <span class="ow">in</span> <span class="n">ri_partners</span><span class="p">:</span>
                        <span class="n">ri_partners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rn</span><span class="p">)</span>
                        <span class="n">skip</span><span class="o">=</span><span class="kc">True</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">skip</span><span class="p">:</span> <span class="k">continue</span>
        <span class="c1"># logger.debug(f&#39;rn partners {ri_partners}&#39;)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rj</span> <span class="ow">in</span> <span class="n">ri_partners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_interresidue_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">rj</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.local_resid_cluster">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.local_resid_cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">local_resid_cluster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ri</span><span class="p">):</span>
        <span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="c1"># logger.debug(str(self.bondlist))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_interresidue_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">ri</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span></div>


<div class="viewcode-block" id="Topology.make_resid_graph">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.make_resid_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">make_resid_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">json_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">N</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residue_network</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">residues</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;residue&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rn</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="n">rs</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;residue&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">rn</span><span class="p">][</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">residue_network</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">rs</span><span class="p">,</span><span class="n">resName</span><span class="o">=</span><span class="n">rn</span><span class="p">)</span>
        
        <span class="n">resnrs</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">resnrs</span><span class="p">:</span>
            <span class="c1"># atom global indexes in this resnr</span>
            <span class="n">ats</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">connectors</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">ats</span><span class="p">:</span>
                <span class="n">an</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">natsrn</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">an</span><span class="p">)][</span><span class="s1">&#39;resnr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">natsrn</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">natsrn</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">!=</span><span class="n">i</span><span class="p">:</span>  <span class="c1"># this is an inter-residue connection</span>
                            <span class="n">connectors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">connectors</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">c</span>
                <span class="n">bondtype</span><span class="o">=</span><span class="s2">&quot;cross&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">residue_network</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">residue_network</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">bondtype</span><span class="o">=</span><span class="n">bondtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="n">the_data</span><span class="o">=</span><span class="n">json_graph</span><span class="o">.</span><span class="n">node_link_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">residue_network</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">the_data</span><span class="p">)</span><span class="o">==</span><span class="nb">dict</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: node_link_data returns a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">the_data</span><span class="p">)</span><span class="si">}</span><span class="s1"> but should return a dict&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing graph node_link_data to </span><span class="si">{</span><span class="n">json_file</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">the_data_str</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">the_data</span><span class="p">)</span>
            <span class="n">the_data_str</span><span class="o">=</span><span class="n">the_data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;True&#39;</span><span class="p">,</span><span class="s1">&#39;&quot;True&quot;&#39;</span><span class="p">)</span>
            <span class="n">the_data_str</span><span class="o">=</span><span class="n">the_data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;False&#39;</span><span class="p">,</span><span class="s1">&#39;&quot;False&quot;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;&#39;&quot;</span> <span class="ow">in</span> <span class="n">the_data_str</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;json_graph.node_link_data produces single-quoted dict keys -- this is not JSON standard&#39;</span><span class="p">)</span>
                <span class="n">json_compatible_string</span><span class="o">=</span><span class="n">the_data_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">the_data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_compatible_string</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;json.loads fails to encode string:</span><span class="se">\n</span><span class="si">{</span><span class="n">json_compatible_string</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span> <span class="p">(</span><span class="n">json_file</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">the_data</span><span class="p">,</span><span class="n">f</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing resid graph to JSON not currently supported&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">the_data</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Topology.copy_bond_parameters">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.copy_bond_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">copy_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bonds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate and return a copy of a bonds dataframe that contains all bonds</span>
<span class="sd">           listed in bonds</span>

<span class="sd">        :param bonds: dataframe of bonds managed by runtime, &#39;ai&#39;,&#39;aj&#39;,&#39;reactantName&#39;</span>
<span class="sd">        :type bonds: pandas.DataFrame</span>
<span class="sd">        :return: [ bonds ] dataframe extracted from system with all parameters</span>
<span class="sd">        :rtype: pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;c0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()))</span>
        <span class="n">saveme</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bonds</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">))</span>
            <span class="n">subframe</span><span class="o">=</span><span class="n">bdf</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">subframe</span><span class="p">:</span>
                    <span class="n">subframe</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">_PAD_</span>
            <span class="k">if</span> <span class="n">saveme</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">saveme</span><span class="o">=</span><span class="n">subframe</span>
            <span class="k">else</span><span class="p">:</span>
            <span class="c1"># logger.debug(f&#39;copy parameters for ai {ai} aj {aj}&#39;)</span>
                <span class="n">saveme</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">saveme</span><span class="p">,</span><span class="n">subframe</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># logger.info(f&#39;saved bond override params\n{saveme.to_string()}&#39;)</span>
        <span class="k">return</span> <span class="n">saveme</span></div>


<div class="viewcode-block" id="Topology.attenuate_bond_parameters">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.attenuate_bond_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">attenuate_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bondsdf</span><span class="p">,</span><span class="n">stage</span><span class="p">,</span><span class="n">max_stages</span><span class="p">,</span><span class="n">minimum_distance</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">init_colname</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alter the kb and b0 parameters for new crosslink bonds according to the values prior to </span>
<span class="sd">            relaxation (stored in lengths), their equilibrium values, and the ratio stage/max_stages.</span>
<span class="sd">            Let stage/max_stages be x, and 1/max_stages &lt;= x &lt;= 1.  The spring constant for each</span>
<span class="sd">            bond is multiplied by x and the distance is 1 xth of the way from its maximum value </span>
<span class="sd">            to its equilibrium value.</span>

<span class="sd">        :param bonds: dataframe of bonds managed by runtime, &#39;ai&#39;,&#39;aj&#39;,&#39;reactantName&#39;</span>
<span class="sd">        :type bonds: pandas.DataFrame</span>
<span class="sd">        :param stage: index of stage in the series of post-bond-formation relaxation (&quot;R&quot; of SCUR)</span>
<span class="sd">        :type stage: int</span>
<span class="sd">        :param max_stages: total number of relaxation stages for this iteration</span>
<span class="sd">        :type max_stages: int</span>
<span class="sd">        :param minimum_distance: minimum bondlegth allowed, overriding type-specific b0 (if greater than 0)</span>
<span class="sd">        :type lengths: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
        <span class="n">factor</span><span class="o">=</span><span class="p">(</span><span class="n">stage</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">max_stages</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attenuating </span><span class="si">{</span><span class="n">bondsdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bond</span><span class="si">{</span><span class="s2">&quot;s&quot;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">bondsdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="si">}</span><span class="s1"> in stage </span><span class="si">{</span><span class="n">stage</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">max_stages</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">jdx</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">bondsdf</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">init_colname</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bondsdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">))</span>
            <span class="n">rij</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span>
            <span class="n">b0</span><span class="p">,</span><span class="n">kb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bond_parameters</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">minimum_distance</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
                <span class="n">b0</span><span class="o">=</span><span class="n">minimum_distance</span>
            <span class="n">new_b0</span><span class="o">=</span><span class="n">rij</span><span class="o">-</span><span class="n">factor</span><span class="o">*</span><span class="p">(</span><span class="n">rij</span><span class="o">-</span><span class="n">b0</span><span class="p">)</span>
            <span class="n">new_kb</span><span class="o">=</span><span class="n">kb</span><span class="o">*</span><span class="n">factor</span>
            <span class="c1"># logger.debug(f&#39;bond attenuation target for {ai}-{aj}:\nb0 {b0:.5f} kb {kb:.2f}; using b0 {new_b0:.5f} kb {new_kb:.2f}&#39;)</span>
            <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c0&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_b0</span>
            <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">new_kb</span></div>


<div class="viewcode-block" id="Topology.get_bond_parameters">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.get_bond_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets b0 and kb for bond between atoms with global indexes ai and aj</span>

<span class="sd">        :param ai: global atom index</span>
<span class="sd">        :type ai: int</span>
<span class="sd">        :param aj: global atom index</span>
<span class="sd">        :type aj: int</span>
<span class="sd">        :return: b0, kb -- equilibrium bond length and spring constant</span>
<span class="sd">        :rtype: 2-tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">((</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">))</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">bdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
        <span class="n">tdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">]</span>
        <span class="n">b0</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kb</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">kb</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; no overrides for this bond, so take from types &#39;&#39;&#39;</span>
            <span class="n">it</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">jt</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">it</span><span class="p">,</span><span class="n">jt</span><span class="o">=</span><span class="n">typeorder</span><span class="p">((</span><span class="n">it</span><span class="p">,</span><span class="n">jt</span><span class="p">))</span>
            <span class="n">b0</span><span class="o">=</span><span class="n">tdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">it</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">jt</span><span class="p">),</span><span class="s1">&#39;b0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">kb</span><span class="o">=</span><span class="n">tdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">it</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tdf</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">jt</span><span class="p">),</span><span class="s1">&#39;kb&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">b0</span><span class="p">,</span><span class="n">kb</span></div>


<div class="viewcode-block" id="Topology.restore_bond_parameters">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.restore_bond_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">restore_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy data from all bonds in dataframe df to global dataframe</span>

<span class="sd">        :param df: dataframe of bonds [&#39;ai&#39;,&#39;aj&#39;,&#39;c0&#39;,&#39;c1&#39;]</span>
<span class="sd">        :type df: pandas DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span>
            <span class="n">c0</span><span class="p">,</span><span class="n">c1</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">c0</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">c1</span>
            <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c0&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">c0</span>
            <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">c1</span></div>


<div class="viewcode-block" id="Topology.attenuate_pair_parameters">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topology.Topology.attenuate_pair_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">attenuate_pair_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairsdf</span><span class="p">,</span><span class="n">stage</span><span class="p">,</span><span class="n">max_stages</span><span class="p">,</span><span class="n">draglimit_nm</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alter the kb and b0 parameters for new pre-crosslink pairs according </span>
<span class="sd">            to the values prior to dragging (stored in pairdf[&#39;initial_distances&#39;]), </span>
<span class="sd">            the desired lower limit of interatomic distance &#39;draglimit_nm&#39;, </span>
<span class="sd">            and the ratio stage/max_stages.</span>
<span class="sd">            </span>
<span class="sd">        :param pairdf: pairs dataframe ([&#39;ai&#39;],[&#39;aj&#39;],[&#39;initial_distance&#39;])</span>
<span class="sd">        :type pairdf: pandas.DataFrame</span>
<span class="sd">        :param stage: index of stage in the series of pre-bond-formation dragging</span>
<span class="sd">        :type stage: int</span>
<span class="sd">        :param max_stages: total number of drag stages for this iteration</span>
<span class="sd">        :type max_stages: int</span>
<span class="sd">        :param draglimit_nm: lower limit of interatomic distance requested from drag</span>
<span class="sd">        :type draglimit_nm: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
        <span class="n">ess</span><span class="o">=</span><span class="s1">&#39;s&#39;</span> <span class="k">if</span> <span class="n">pairsdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">factor</span><span class="o">=</span><span class="p">(</span><span class="n">stage</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">max_stages</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attenuating </span><span class="si">{</span><span class="n">pairsdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> pair</span><span class="si">{</span><span class="n">ess</span><span class="si">}</span><span class="s1"> in stage </span><span class="si">{</span><span class="n">stage</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">max_stages</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairsdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">idxorder</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">))</span>
            <span class="n">b0</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">initial_distance</span>
            <span class="n">kb</span><span class="o">=</span><span class="n">pdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c0&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">draglimit_nm</span><span class="o">-</span><span class="n">factor</span><span class="o">*</span><span class="p">(</span><span class="n">b0</span><span class="o">-</span><span class="n">draglimit_nm</span><span class="p">)</span>
            <span class="n">pdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ai</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aj</span><span class="p">),</span><span class="s1">&#39;c1&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">kb</span><span class="o">*</span><span class="n">factor</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">HTPolyNet</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation and Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-tutorials/index.html">Example Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/index.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTPolyNetPackage.html">HTPolyNet package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Cameron Abrams, Ming Huang.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>