
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTPolyNet.utils &#8212; HTPolyNet 1.0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for HTPolyNet.utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: utils</span>
<span class="sd">   :synopsis: various utility methods for plotting and postprocessing</span>
<span class="sd">   </span>
<span class="sd">.. moduleauthor: Cameron F. Abrams, &lt;cfa22@drexel.edu&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.coordinates</span> <span class="kn">import</span> <span class="n">Coordinates</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.topocoord</span> <span class="kn">import</span> <span class="n">TopoCoord</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.gromacs</span> <span class="kn">import</span> <span class="n">gmx_energy_trace</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">physical_constants</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="density_from_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.density_from_gro">[docs]</a><span class="k">def</span> <span class="nf">density_from_gro</span><span class="p">(</span><span class="n">gro</span><span class="p">,</span><span class="n">mollib</span><span class="o">=</span><span class="s1">&#39;./lib/molecules/parameterized&#39;</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;SI&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;density_from_gro computes density from a Gromacs gro file</span>

<span class="sd">    :param gro: name of gro file</span>
<span class="sd">    :type gro: str</span>
<span class="sd">    :param mollib: location of parameterized molecular templates, defaults to &#39;./lib/molecules/parameterized&#39;</span>
<span class="sd">    :type mollib: str, optional</span>
<span class="sd">    :param units: string indicating unit system, defaults to &#39;SI&#39;</span>
<span class="sd">    :type units: str, optional</span>
<span class="sd">    :return: density</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span><span class="o">=</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="n">gro</span><span class="p">)</span>
    <span class="n">resnames</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]))</span>
    <span class="n">templates</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">from_top_gro</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mollib</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">),</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mollib</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">resnames</span><span class="p">}</span>
    <span class="n">mass</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="n">counts</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">nm</span><span class="p">,</span><span class="n">T</span> <span class="ow">in</span> <span class="n">templates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nm</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">nm</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">an</span> <span class="ow">in</span> <span class="n">T</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]:</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">nm</span><span class="p">][</span><span class="n">an</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">these</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">C</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">nm</span><span class="p">][</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">these</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">nm</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">nm</span><span class="p">,</span><span class="n">adict</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">T</span><span class="o">=</span><span class="n">templates</span><span class="p">[</span><span class="n">nm</span><span class="p">]</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">aname</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">adict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">mass</span><span class="o">+=</span><span class="n">c</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aname</span><span class="p">][</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">volume</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
    <span class="n">fac</span><span class="o">=</span><span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">units</span><span class="o">==</span><span class="s1">&#39;SI&#39;</span><span class="p">:</span>
        <span class="n">mfac</span><span class="o">=</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;atomic mass constant&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lfac</span><span class="o">=</span><span class="mf">1.e-9</span>
        <span class="n">vfac</span><span class="o">=</span><span class="n">lfac</span><span class="o">**</span><span class="mi">3</span>
        <span class="n">fac</span><span class="o">=</span><span class="n">mfac</span><span class="o">/</span><span class="n">vfac</span>
    <span class="k">return</span> <span class="n">fac</span><span class="o">*</span><span class="n">mass</span><span class="o">/</span><span class="n">volume</span></div>

<span class="sd">&quot;&quot;&quot; These globals are used in traversing a project directory to extract data from edr files &quot;&quot;&quot;</span>
<span class="n">_system_dirs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;densification&#39;</span><span class="p">,</span><span class="s1">&#39;precure&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;iter-</span><span class="si">{iter:d}</span><span class="s1">&#39;</span><span class="p">,</span><span class="s1">&#39;capping&#39;</span><span class="p">,</span><span class="s1">&#39;postcure&#39;</span><span class="p">]</span>
<span class="n">_postsim_dirs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;anneal&#39;</span><span class="p">,</span><span class="s1">&#39;equilibrate&#39;</span><span class="p">]</span>
<span class="n">_measurement_dirs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Tg&#39;</span><span class="p">,</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
<span class="n">_md_ensembles</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;nvt&#39;</span><span class="p">:[</span><span class="s1">&#39;Temperature&#39;</span><span class="p">,</span><span class="s1">&#39;Potential&#39;</span><span class="p">],</span><span class="s1">&#39;npt&#39;</span><span class="p">:[</span><span class="s1">&#39;Temperature&#39;</span><span class="p">,</span><span class="s1">&#39;Potential&#39;</span><span class="p">,</span><span class="s1">&#39;Density&#39;</span><span class="p">],</span><span class="s1">&#39;default&#39;</span><span class="p">:[</span><span class="s1">&#39;Temperature&#39;</span><span class="p">,</span><span class="s1">&#39;Potential&#39;</span><span class="p">]}</span>
<span class="n">_indir_pfx</span><span class="o">=</span><span class="p">{}</span>
<span class="n">_indir_pfx</span><span class="p">[</span><span class="s1">&#39;densification&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;densified-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;densified-repeat-</span><span class="si">{repeat:d}</span><span class="s1">-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="n">_indir_pfx</span><span class="p">[</span><span class="s1">&#39;precure&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;preequilibration-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;annealed&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;postequilibration-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="n">_indir_pfx</span><span class="p">[</span><span class="s1">&#39;iter-n&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;1-cure_drag-stage-</span><span class="si">{stage:d}</span><span class="s1">-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;3-cure_relax-stage-</span><span class="si">{stage:d}</span><span class="s1">-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;4-cure_equilibrate-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="n">_indir_pfx</span><span class="p">[</span><span class="s1">&#39;capping&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;7-cap_relax-stage-</span><span class="si">{stage:d}</span><span class="s1">-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;8-cap_equilibrate-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="n">_indir_pfx</span><span class="p">[</span><span class="s1">&#39;postcure&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="sa">r</span><span class="s1">&#39;preequilibration-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;annealed&#39;</span><span class="p">,</span><span class="sa">r</span><span class="s1">&#39;postequilibration-</span><span class="si">{ens:s}</span><span class="s1">&#39;</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">_concat_from_edr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">edr</span><span class="p">,</span><span class="n">names</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="p">[],</span><span class="n">add_if_missing</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;_concat_from_edr concentates rows onto dataframe df by reading data from an edr file</span>

<span class="sd">    :param df: a dataframe with data read in from edr files</span>
<span class="sd">    :type df: pandas.DataFrame</span>
<span class="sd">    :param edr: name of a new edr file to read from</span>
<span class="sd">    :type edr: str</span>
<span class="sd">    :param names: names of energy-like quantities to be read in; each must have a column in df already</span>
<span class="sd">    :type names: list of strings</span>
<span class="sd">    :param add: names and values to add to dataset, defaults to []</span>
<span class="sd">    :type add: list, optional</span>
<span class="sd">    :param add_if_missing: names and values to add if not found in edr file, defaults to [(&#39;Density&#39;,0.0)]</span>
<span class="sd">    :type add_if_missing: list, optional</span>
<span class="sd">    :return: a tuple of the dataframe and the scalar value of last time *before* this data increment is read in</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xshift</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span> <span class="n">xshift</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;time(ps)&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">df</span><span class="p">,</span><span class="n">xshift</span>
    <span class="c1"># print(f&#39;{add_if_missing}&#39;)</span>
    <span class="n">this_df</span><span class="o">=</span><span class="n">gmx_energy_trace</span><span class="p">(</span><span class="n">edr</span><span class="p">,</span><span class="n">names</span><span class="p">,</span><span class="n">xshift</span><span class="o">=</span><span class="n">xshift</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">add</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">m</span>
        <span class="n">this_df</span><span class="p">[</span><span class="n">nm</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">this_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span><span class="o">*</span><span class="n">val</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">add_if_missing</span><span class="p">:</span>
        <span class="n">nm</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="n">m</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nm</span> <span class="ow">in</span> <span class="n">this_df</span><span class="p">:</span>
            <span class="n">this_df</span><span class="p">[</span><span class="n">nm</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">this_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span><span class="o">*</span><span class="n">val</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">df</span><span class="p">,</span><span class="n">this_df</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span><span class="n">xshift</span>

<div class="viewcode-block" id="postsim_density_evolution"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.postsim_density_evolution">[docs]</a><span class="k">def</span> <span class="nf">postsim_density_evolution</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="n">append_dirname</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;postsim_density_evolution returns a single dataframe that is a concatenation of the csv files</span>
<span class="sd">    in the &#39;postsim&#39; subdirectories</span>

<span class="sd">    :param proj_dir: name of complete project directory</span>
<span class="sd">    :type proj_dir: str</span>
<span class="sd">    :return: the dataframe</span>
<span class="sd">    :rtype: pandas.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">):</span> <span class="k">return</span>
    <span class="n">sysd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="s1">&#39;postsim&#39;</span><span class="p">)</span>
    <span class="n">fn</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sysd</span><span class="si">}</span><span class="s1">/anneal/anneal.csv&#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sysd</span><span class="si">}</span><span class="s1">/equilibrate/equilibrate.csv&#39;</span><span class="p">]</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">lt</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fn</span><span class="p">:</span>
        <span class="n">t</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;shifting by </span><span class="si">{</span><span class="n">lt</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">t</span><span class="p">[</span><span class="s1">&#39;time(ps)&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">lt</span>
        <span class="n">lt</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;time(ps)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">df</span><span class="p">,</span><span class="n">t</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">append_dirname</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="p">:</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">proj_dir</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="density_evolution"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.density_evolution">[docs]</a><span class="k">def</span> <span class="nf">density_evolution</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;density_evolution returns a single dataframe containing density, temperture, number of bonds vs time by reading all edrs in the correct order from a complete project directory</span>

<span class="sd">    :param proj_dir: name of complete project directory</span>
<span class="sd">    :type proj_dir: str</span>
<span class="sd">    :return: the dataframe</span>
<span class="sd">    :rtype: pandas.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">):</span> <span class="k">return</span>
    <span class="n">sysd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="s1">&#39;systems&#39;</span><span class="p">)</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="n">xshift</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="n">transition_times</span><span class="o">=</span><span class="p">[</span><span class="n">xshift</span><span class="p">]</span>
    <span class="n">interval_labels</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">markers</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">nbonds</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">subd</span> <span class="ow">in</span> <span class="n">_system_dirs</span><span class="p">:</span>
        <span class="c1"># print(f&#39;subd {subd}&#39;)</span>
        <span class="k">if</span> <span class="n">subd</span><span class="o">==</span><span class="sa">r</span><span class="s1">&#39;iter-</span><span class="si">{iter:d}</span><span class="s1">&#39;</span> <span class="ow">or</span> <span class="n">subd</span><span class="o">==</span><span class="s1">&#39;capping&#39;</span> <span class="ow">or</span> <span class="n">subd</span><span class="o">==</span><span class="s1">&#39;densification&#39;</span><span class="p">:</span>
            <span class="c1"># loooking for iterations</span>
            <span class="c1"># print(iter_mark0)</span>
            <span class="nb">iter</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">iter_subd_rel</span><span class="o">=</span><span class="n">subd</span> <span class="k">if</span> <span class="n">subd</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;capping&#39;</span><span class="p">,</span><span class="s1">&#39;densification&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">subd</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="o">=</span><span class="nb">iter</span><span class="p">)</span>
            <span class="n">iter_subd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sysd</span><span class="p">,</span><span class="n">iter_subd_rel</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading edrs in </span><span class="si">{</span><span class="n">iter_subd_rel</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="sa">r</span><span class="s1">&#39;iter&#39;</span> <span class="ow">in</span> <span class="n">subd</span><span class="p">:</span>
                    <span class="n">markers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;time(ps)&#39;</span><span class="p">])</span>
                <span class="n">dirkey</span><span class="o">=</span><span class="s1">&#39;iter-n&#39;</span> <span class="k">if</span> <span class="n">subd</span><span class="o">==</span><span class="sa">r</span><span class="s1">&#39;iter-</span><span class="si">{iter:d}</span><span class="s1">&#39;</span> <span class="k">else</span> <span class="n">subd</span>
                <span class="k">if</span> <span class="n">subd</span><span class="o">==</span><span class="sa">r</span><span class="s1">&#39;iter-</span><span class="si">{iter:d}</span><span class="s1">&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="s1">&#39;2-cure_update-bonds.csv&#39;</span><span class="p">)):</span>
                        <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="s1">&#39;2-cure_update-bonds.csv&#39;</span><span class="p">),</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                        <span class="n">nbonds</span><span class="o">+=</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="s1">&#39;6-cap_update-bonds.csv&#39;</span><span class="p">)):</span>
                            <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="s1">&#39;6-cap_update-bonds.csv&#39;</span><span class="p">),</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">nbonds</span><span class="o">+=</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># print(f&#39;iter_subd {iter_subd} dirkey {dirkey}&#39;)</span>
                <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">_indir_pfx</span><span class="p">[</span><span class="n">dirkey</span><span class="p">]:</span>
                    <span class="c1"># print(f&#39;pfx {pfx}&#39;)</span>
                    <span class="k">if</span> <span class="sa">r</span><span class="s1">&#39;stage&#39;</span> <span class="ow">in</span> <span class="n">pfx</span> <span class="ow">or</span> <span class="sa">r</span><span class="s1">&#39;repeat&#39;</span> <span class="ow">in</span> <span class="n">pfx</span><span class="p">:</span>
                        <span class="n">stg</span><span class="o">=</span><span class="mi">1</span>
                        <span class="n">stg_present</span><span class="o">=</span><span class="nb">any</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stage</span><span class="o">=</span><span class="n">stg</span><span class="p">,</span><span class="n">repeat</span><span class="o">=</span><span class="n">stg</span><span class="p">,</span><span class="n">ens</span><span class="o">=</span><span class="n">x</span><span class="p">))</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_md_ensembles</span><span class="p">])</span>
                        <span class="c1"># print(f&#39;{iter_subd} {stg} {pfx} stg_present {stg_present}&#39;)</span>
                        <span class="k">while</span> <span class="n">stg_present</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">ens</span><span class="p">,</span><span class="n">qtys</span> <span class="ow">in</span> <span class="n">_md_ensembles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">edr_pfx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stage</span><span class="o">=</span><span class="n">stg</span><span class="p">,</span><span class="n">repeat</span><span class="o">=</span><span class="n">stg</span><span class="p">,</span><span class="n">ens</span><span class="o">=</span><span class="n">ens</span><span class="p">))</span>
                                <span class="n">gro</span><span class="o">=</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.gro&#39;</span>
                                <span class="c1"># print(edr_pfx,os.path.exists(edr_pfx+r&#39;.edr&#39;))</span>
                                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">):</span>
                                    <span class="n">density</span><span class="o">=</span><span class="mf">0.0</span>
                                    <span class="k">if</span> <span class="n">ens</span><span class="o">!=</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gro</span><span class="p">):</span>
                                            <span class="n">density</span><span class="o">=</span><span class="n">density_from_gro</span><span class="p">(</span><span class="n">gro</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="s1">&#39;molecules/parameterized&#39;</span><span class="p">))</span>
                                            <span class="c1"># print(f&#39;density from gro {density}&#39;)</span>
                                    <span class="n">df</span><span class="p">,</span><span class="n">xshift</span><span class="o">=</span><span class="n">_concat_from_edr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">edr_pfx</span><span class="p">,</span><span class="n">qtys</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;nbonds&#39;</span><span class="p">,</span><span class="n">nbonds</span><span class="p">)],</span><span class="n">add_if_missing</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="n">density</span><span class="p">)])</span>
                                    <span class="n">transition_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xshift</span><span class="p">)</span>
                                    <span class="n">interval_labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edr_pfx</span><span class="p">])</span>
                            <span class="n">stg</span><span class="o">+=</span><span class="mi">1</span>
                            <span class="n">stg_present</span><span class="o">=</span><span class="nb">any</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stage</span><span class="o">=</span><span class="n">stg</span><span class="p">,</span><span class="n">repeat</span><span class="o">=</span><span class="n">stg</span><span class="p">,</span><span class="n">ens</span><span class="o">=</span><span class="n">x</span><span class="p">))</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_md_ensembles</span><span class="p">])</span>
                            <span class="c1"># print(f&#39;-&gt;{iter_subd} {stg} {pfx} stg_present {stg_present}&#39;)</span>
                    <span class="k">elif</span> <span class="sa">r</span><span class="s1">&#39;equil&#39;</span> <span class="ow">in</span> <span class="n">pfx</span> <span class="ow">or</span> <span class="sa">r</span><span class="s1">&#39;densif&#39;</span> <span class="ow">in</span> <span class="n">pfx</span><span class="p">:</span>
                        <span class="n">eq_present</span><span class="o">=</span><span class="nb">any</span><span class="p">([</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens</span><span class="o">=</span><span class="n">x</span><span class="p">))</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_md_ensembles</span><span class="p">])</span>
                        <span class="c1"># print(f&#39;{iter_subd} eq_present? {eq_present}&#39;)</span>
                        <span class="k">if</span> <span class="n">eq_present</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">ens</span><span class="p">,</span><span class="n">qtys</span> <span class="ow">in</span> <span class="n">_md_ensembles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">edr_pfx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">iter_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens</span><span class="o">=</span><span class="n">ens</span><span class="p">))</span>
                                <span class="n">gro</span><span class="o">=</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.gro&#39;</span>
                                <span class="c1"># print(edr_pfx,os.path.exists(edr_pfx+r&#39;.edr&#39;),ens,qtys)</span>
                                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">):</span>
                                    <span class="n">density</span><span class="o">=</span><span class="mf">0.0</span>
                                    <span class="k">if</span> <span class="n">ens</span><span class="o">!=</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gro</span><span class="p">):</span>
                                            <span class="n">density</span><span class="o">=</span><span class="n">density_from_gro</span><span class="p">(</span><span class="n">gro</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="s1">&#39;molecules/parameterized&#39;</span><span class="p">))</span>
                                    <span class="n">df</span><span class="p">,</span><span class="n">xshift</span><span class="o">=</span><span class="n">_concat_from_edr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">edr_pfx</span><span class="p">,</span><span class="n">qtys</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;nbonds&#39;</span><span class="p">,</span><span class="n">nbonds</span><span class="p">)],</span><span class="n">add_if_missing</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="n">density</span><span class="p">)])</span>
                                    <span class="n">transition_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xshift</span><span class="p">)</span>
                                    <span class="n">interval_labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edr_pfx</span><span class="p">])</span>
                <span class="nb">iter</span><span class="o">+=</span><span class="mi">1</span>       
                <span class="n">iter_subd_rel</span><span class="o">=</span><span class="n">subd</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="o">=</span><span class="nb">iter</span><span class="p">)</span>
                <span class="n">iter_subd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sysd</span><span class="p">,</span><span class="n">iter_subd_rel</span><span class="p">)</span> <span class="k">if</span> <span class="sa">r</span><span class="s1">&#39;iter&#39;</span> <span class="ow">in</span> <span class="n">subd</span> <span class="k">else</span> <span class="s1">&#39;I_BET_THIS_FILE_DNE&#39;</span>
            <span class="c1"># if r&#39;iter&#39; in subd: markers.append(df.iloc[-1][&#39;time (ps)&#39;])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this_subd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sysd</span><span class="p">,</span><span class="n">subd</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading edrs in </span><span class="si">{</span><span class="n">subd</span><span class="si">}</span><span class="s1">...&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">_indir_pfx</span><span class="p">[</span><span class="n">subd</span><span class="p">]:</span>
                <span class="c1"># print(f&#39;this_subd {this_subd} pfx {pfx}&#39;)</span>
                <span class="k">if</span> <span class="s1">&#39;ens&#39;</span> <span class="ow">in</span> <span class="n">pfx</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ens</span><span class="p">,</span><span class="n">qtys</span> <span class="ow">in</span> <span class="n">_md_ensembles</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">edr_pfx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">this_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens</span><span class="o">=</span><span class="n">ens</span><span class="p">))</span>
                        <span class="n">gro</span><span class="o">=</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.gro&#39;</span>
                        <span class="c1"># print(edr_pfx,os.path.exists(edr_pfx+r&#39;.edr&#39;))</span>
                        <span class="c1"># print(gro,os.path.exists(gro))</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">):</span>
                            <span class="n">density</span><span class="o">=</span><span class="mf">0.0</span>
                            <span class="k">if</span> <span class="n">ens</span><span class="o">==</span><span class="s1">&#39;nvt&#39;</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gro</span><span class="p">):</span>
                                <span class="n">density</span><span class="o">=</span><span class="n">density_from_gro</span><span class="p">(</span><span class="n">gro</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="s1">&#39;molecules/parameterized&#39;</span><span class="p">))</span>
                            <span class="n">df</span><span class="p">,</span><span class="n">xshift</span><span class="o">=</span><span class="n">_concat_from_edr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">edr_pfx</span><span class="p">,</span><span class="n">qtys</span><span class="p">,</span><span class="n">add</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;nbonds&#39;</span><span class="p">,</span><span class="n">nbonds</span><span class="p">)],</span><span class="n">add_if_missing</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="n">density</span><span class="p">)])</span>
                            <span class="n">transition_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xshift</span><span class="p">)</span>
                            <span class="n">interval_labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edr_pfx</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edr_pfx</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">this_subd</span><span class="p">,</span><span class="n">pfx</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ens</span><span class="o">=</span><span class="n">ens</span><span class="p">))</span>
                    <span class="n">gro</span><span class="o">=</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.gro&#39;</span>
                    <span class="c1"># print(edr_pfx,os.path.exists(edr_pfx+r&#39;.edr&#39;))</span>
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">edr_pfx</span><span class="o">+</span><span class="sa">r</span><span class="s1">&#39;.edr&#39;</span><span class="p">):</span>
                        <span class="n">density</span><span class="o">=</span><span class="mf">0.0</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">gro</span><span class="p">):</span>
                            <span class="n">density</span><span class="o">=</span><span class="n">density_from_gro</span><span class="p">(</span><span class="n">gro</span><span class="p">,</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">,</span><span class="s1">&#39;molecules/parameterized&#39;</span><span class="p">))</span>
                        <span class="n">df</span><span class="p">,</span><span class="n">xshift</span><span class="o">=</span><span class="n">_concat_from_edr</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">edr_pfx</span><span class="p">,</span><span class="n">_md_ensembles</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">],</span><span class="n">add</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;nbonds&#39;</span><span class="p">,</span><span class="n">nbonds</span><span class="p">)],</span><span class="n">add_if_missing</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="n">density</span><span class="p">)])</span>
                        <span class="n">transition_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xshift</span><span class="p">)</span>
                        <span class="n">interval_labels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">edr_pfx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">df</span><span class="p">,</span><span class="n">transition_times</span><span class="p">,</span><span class="n">markers</span><span class="p">,</span><span class="n">interval_labels</span></div>

<div class="viewcode-block" id="graph_from_bondsfile"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.graph_from_bondsfile">[docs]</a><span class="k">def</span> <span class="nf">graph_from_bondsfile</span><span class="p">(</span><span class="n">bondsfile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;graph_from_bondsfile generates a networkx Graph in which each node is a molecule (from &#39;mi&#39; and &#39;mj&#39; records in the bondsfile) and edges indicate two molecules are joined by a covalent bond</span>

<span class="sd">    :param bondsfile: name of bondsfile</span>
<span class="sd">    :type bondsfile: str</span>
<span class="sd">    :return: the graph</span>
<span class="sd">    :rtype: networkx.Graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">bondsfile</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">index_col</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;mi&#39;</span><span class="p">],</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;mj&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="mwbxl"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.mwbxl">[docs]</a><span class="k">def</span> <span class="nf">mwbxl</span><span class="p">(</span><span class="n">G</span><span class="p">:</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">,</span><span class="n">crosslinker</span><span class="o">=</span><span class="s1">&#39;GMA&#39;</span><span class="p">,</span><span class="n">monomer</span><span class="o">=</span><span class="s1">&#39;STY&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;mwbxl computes the histogram of monomer counts &#39;n&#39; between crosslinking sites using a molecular connectivity graph; used mainly for vinyl-based polymerizations</span>

<span class="sd">    :param G: molecular connectivity graph</span>
<span class="sd">    :type G: nx.Graph</span>
<span class="sd">    :param crosslinker: name of crosslinker molecule, defaults to &#39;GMA&#39;</span>
<span class="sd">    :type crosslinker: str, optional</span>
<span class="sd">    :param monomer: name of monomer, defaults to &#39;STY&#39;</span>
<span class="sd">    :type monomer: str, optional</span>
<span class="sd">    :return: a dataframe of &#39;n&#39; and &#39;count&#39;</span>
<span class="sd">    :rtype: pd.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xG</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># traverse edges and label hetero/homo participants</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;neighbor_count&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">xG</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">n</span><span class="p">[</span><span class="s1">&#39;neighbor_count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">m</span><span class="p">[</span><span class="s1">&#39;neighbor_count&#39;</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="s1">&#39;molecule_name&#39;</span><span class="p">]</span><span class="o">!=</span><span class="n">m</span><span class="p">[</span><span class="s1">&#39;molecule_name&#39;</span><span class="p">]:</span>
            <span class="n">n</span><span class="p">[</span><span class="s1">&#39;monomer_type&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;hetero&#39;</span>
            <span class="n">m</span><span class="p">[</span><span class="s1">&#39;monomer_type&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;hetero&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span><span class="p">[</span><span class="s1">&#39;monomer_type&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;homo&#39;</span>
            <span class="n">m</span><span class="p">[</span><span class="s1">&#39;monomer_type&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;homo&#39;</span>
    <span class="n">wipe_us</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="s1">&#39;molecule_name&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">crosslinker</span><span class="p">:</span>
            <span class="n">wipe_us</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">xG</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">wipe_us</span><span class="p">)</span>
    <span class="n">chaintype</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">ch</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">xG</span><span class="p">)</span>
    <span class="n">mwhist</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">nb</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ch</span><span class="p">:</span>
        <span class="n">nhetero</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="n">node</span><span class="o">=</span><span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;monomer_type&#39;</span><span class="p">,</span><span class="s1">&#39;none&#39;</span><span class="p">)</span><span class="o">==</span><span class="s1">&#39;hetero&#39;</span><span class="p">:</span>
                <span class="n">nhetero</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">nhetero</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">chaintype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;isolated&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nhetero</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">node</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">xG</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;neighbor_count&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">chaintype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;dangling&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;neighbor_count&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">chaintype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;bridging&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mwhist</span><span class="p">:</span>
                        <span class="n">mwhist</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span><span class="o">=</span><span class="mi">0</span>
                    <span class="n">mwhist</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chaintype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;dangling&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">nhetero</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">chaintype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;bridging&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mwhist</span><span class="p">:</span>
                <span class="n">mwhist</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">mwhist</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">nb</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">maxlen</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mwhist</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">mw</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">counts</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxlen</span><span class="p">):</span>
        <span class="n">cnt</span><span class="o">=</span><span class="n">mwhist</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="n">mw</span><span class="p">,</span><span class="s1">&#39;counts&#39;</span><span class="p">:</span><span class="n">counts</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="clusters"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.clusters">[docs]</a><span class="k">def</span> <span class="nf">clusters</span><span class="p">(</span><span class="n">G</span><span class="p">:</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;clusters performs a clustering analysis and returns a histgram of cluster sizes (in numbers of molecules) as a pandas DataFrame</span>

<span class="sd">    :param G: molecular connectivity graph</span>
<span class="sd">    :type G: nx.Graph</span>
<span class="sd">    :return: cluster size histogram</span>
<span class="sd">    :rtype: pd.DataFrame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counts</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">),</span><span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">counts</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">sizes</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">numbers</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;sizes&#39;</span><span class="p">:</span><span class="n">sizes</span><span class="p">,</span><span class="s1">&#39;counts&#39;</span><span class="p">:</span><span class="n">numbers</span><span class="p">})</span>
    <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;sizes&#39;</span><span class="p">,</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="compute_tg"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.utils.compute_tg">[docs]</a><span class="k">def</span> <span class="nf">compute_tg</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">r2_thresh</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span><span class="n">min_npoints</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="n">b</span>
    <span class="n">hot_par</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">cold_par</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_npoints</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span>
        <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">T</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span><span class="n">v</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
        <span class="n">sse</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="o">*</span><span class="n">popt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">sst</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">r2</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">sse</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">sst</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r2</span><span class="o">&lt;</span><span class="n">r2_thresh</span><span class="p">:</span>
            <span class="n">cold_par</span><span class="o">=</span><span class="n">popt</span>
            <span class="k">break</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_npoints</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span>
        <span class="n">popt</span><span class="p">,</span><span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">:],</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="p">:])</span>
        <span class="n">sse</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="o">*</span><span class="n">popt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">sst</span><span class="o">=</span><span class="p">(</span><span class="n">v</span><span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">r2</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="n">sse</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">sst</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r2</span><span class="o">&lt;</span><span class="n">r2_thresh</span><span class="p">:</span>
            <span class="n">hot_par</span><span class="o">=</span><span class="n">popt</span>
            <span class="k">break</span>
    <span class="n">Tg</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hot_par</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">cold_par</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">Tg</span><span class="o">=-</span><span class="p">(</span><span class="n">hot_par</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cold_par</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">hot_par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">cold_par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">Tg</span><span class="p">,</span><span class="n">cold_par</span><span class="p">,</span><span class="n">hot_par</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">HTPolyNet</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation and Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-tutorials/index.html">Example Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference-materials/index.html">Reference Materials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTPolyNetPackage.html">HTPolyNet package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Cameron Abrams, Ming Huang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>