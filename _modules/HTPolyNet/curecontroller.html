<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTPolyNet.curecontroller &#8212; HTPolyNet 1.0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for HTPolyNet.curecontroller</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: curecontroller</span>
<span class="sd">   :synopsis: Manages execution of the CURE algorithm</span>
<span class="sd">   </span>
<span class="sd">.. moduleauthor: Cameron F. Abrams, &lt;cfa22@drexel.edu&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.topocoord</span> <span class="kn">import</span> <span class="n">TopoCoord</span><span class="p">,</span> <span class="n">BTRC</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.gromacs</span> <span class="kn">import</span> <span class="n">gromacs_distance</span><span class="p">,</span> <span class="n">mdp_modify</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.configuration</span> <span class="kn">import</span> <span class="n">ReactionList</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.molecule</span> <span class="kn">import</span> <span class="n">MoleculeDict</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.reaction</span> <span class="kn">import</span> <span class="n">reaction_stage</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">HTPolyNet.projectfilesystem</span> <span class="k">as</span> <span class="nn">pfs</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.stringthings</span> <span class="kn">import</span> <span class="n">my_logger</span>
<span class="kn">import</span> <span class="nn">HTPolyNet.checkpoint</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.plot</span> <span class="kn">import</span> <span class="n">trace</span>

<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="cure_step"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.cure_step">[docs]</a><span class="k">class</span> <span class="nc">cure_step</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumerated CURE step</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cure_bondsearch</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">cure_drag</span><span class="o">=</span><span class="mi">1</span>
    <span class="n">cure_update</span><span class="o">=</span><span class="mi">2</span>
    <span class="n">cure_relax</span><span class="o">=</span><span class="mi">3</span>
    <span class="n">cure_equilibrate</span><span class="o">=</span><span class="mi">4</span>
    <span class="n">cap_bondsearch</span><span class="o">=</span><span class="mi">5</span>
    <span class="n">cap_update</span><span class="o">=</span><span class="mi">6</span>  <span class="c1"># dragging is not needed/allowed in capping since these are likely intramolecular bonds...</span>
    <span class="n">cap_relax</span><span class="o">=</span><span class="mi">7</span>
    <span class="n">cap_equilibrate</span><span class="o">=</span><span class="mi">8</span>
    <span class="n">finished</span><span class="o">=</span><span class="mi">9</span>
    <span class="n">unknown</span><span class="o">=</span><span class="mi">99</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
<div class="viewcode-block" id="cure_step.basename"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.cure_step.basename">[docs]</a>    <span class="k">def</span> <span class="nf">basename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;cap_&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;cap_&#39;</span><span class="p">):]</span>
        <span class="k">if</span> <span class="s1">&#39;cure_&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;cure_&#39;</span><span class="p">):]</span></div></div>

<div class="viewcode-block" id="CureState"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureState">[docs]</a><span class="k">class</span> <span class="nc">CureState</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;__init__ generates a new, initialized CureState object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desired_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_search_radius</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_radidx</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">unknown</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_stage</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="s1">&#39;relax&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">current_radidx</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_radius</span><span class="o">=</span><span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_file</span><span class="o">=</span><span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">_to_yaml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;../cure_state.yaml&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_to_yaml writes CureState object to YAML file</span>

<span class="sd">        :param filename: name of output YAML file, defaults to &#39;../cure_state.yaml&#39;</span>
<span class="sd">        :type filename: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="CureState.from_yaml"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureState.from_yaml">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_yaml</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;cure_state.yaml&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;from_yaml returns a new CureState object generated by reading in the YAML file</span>

<span class="sd">        :param filename: input file name, defaults to &#39;cure_state.yaml&#39;</span>
<span class="sd">        :type filename: str, optional</span>
<span class="sd">        :return: new CureState object returned by yaml.load</span>
<span class="sd">        :rtype: CureState</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">yaml_string</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">yaml_string</span><span class="p">,</span><span class="n">Loader</span><span class="o">=</span><span class="n">yaml</span><span class="o">.</span><span class="n">Loader</span><span class="p">)</span></div>

<div class="viewcode-block" id="CureState.reset"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureState.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reset resets this CureState object to begin a new CURE iteration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="o">=</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_bondsearch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="s1">&#39;relax&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_radidx</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_radius</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_file</span><span class="o">=</span><span class="s1">&#39;&#39;</span></div></div>

<div class="viewcode-block" id="CureController"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController">[docs]</a><span class="k">class</span> <span class="nc">CureController</span><span class="p">:</span>
    <span class="n">default_equilibration_sequence</span> <span class="o">=</span> <span class="p">[</span> <span class="p">{</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="s1">&#39;min&#39;</span> <span class="p">},</span> 
        <span class="p">{</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="s1">&#39;nvt&#39;</span><span class="p">,</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="mi">600</span><span class="p">,</span> <span class="s1">&#39;nsteps&#39;</span><span class="p">:</span> <span class="mi">1000</span> <span class="p">},</span>
        <span class="p">{</span> <span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="s1">&#39;npt&#39;</span><span class="p">,</span> <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="mi">600</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;nsteps&#39;</span><span class="p">:</span> <span class="mi">2000</span> <span class="p">}</span>
    <span class="p">]</span>
    <span class="n">curedict_defaults</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;bonds_file&#39;</span><span class="p">:</span> <span class="s1">&#39;bonds.csv&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;controls&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;max_conversion_per_iteration&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="s1">&#39;search_radius&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="s1">&#39;radial_increment&#39;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">,</span>
            <span class="s1">&#39;late_threshold&#39;</span><span class="p">:</span> <span class="mf">0.85</span><span class="p">,</span>
            <span class="s1">&#39;max_iterations&#39;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
            <span class="s1">&#39;desired_conversion&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="s1">&#39;ncpu&#39;</span> <span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
        <span class="p">},</span>
        <span class="s1">&#39;drag&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;limit&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s1">&#39;kb&#39;</span><span class="p">:</span> <span class="mf">300000.0</span><span class="p">,</span> <span class="c1"># kJ/mol/nm</span>
            <span class="s1">&#39;trigger_distance&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s1">&#39;nstages&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s1">&#39;increment&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s1">&#39;cutoff_pad&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
            <span class="s1">&#39;equilibration&#39;</span><span class="p">:</span> <span class="n">default_equilibration_sequence</span>
        <span class="p">},</span>
        <span class="s1">&#39;relax&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;nstages&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
            <span class="s1">&#39;increment&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s1">&#39;cutoff_pad&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span>
            <span class="s1">&#39;equilibration&#39;</span><span class="p">:</span> <span class="n">default_equilibration_sequence</span>
        <span class="p">},</span>
        <span class="s1">&#39;equilibrate&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="mi">300</span><span class="p">,</span>
            <span class="s1">&#39;pressure&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;nsteps&#39;</span><span class="p">:</span> <span class="mi">50000</span><span class="p">,</span>
            <span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="s1">&#39;npt&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;gromacs&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;rdefault&#39;</span><span class="p">:</span> <span class="mf">0.9</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">curedict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;__init__ generates a new CureController object populated from directives in curedict</span>

<span class="sd">        :param curedict: dictionary of cure directives, defaults to {}</span>
<span class="sd">        :type curedict: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">=</span><span class="n">CureState</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_are</span><span class="o">=</span><span class="s1">&#39;nonexistent!&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_failed</span><span class="o">=</span><span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">curedict_defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">curedict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># loads entire default if dict is just missing</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">==</span><span class="nb">dict</span><span class="p">:</span> <span class="c1"># assign subitem defaults if their keys are missing</span>
                <span class="k">for</span> <span class="n">kk</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">kk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">kk</span><span class="p">]</span><span class="o">=</span><span class="n">vv</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dragging_enabled</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;nstages&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;increment&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dragging_enabled</span><span class="o">=</span><span class="kc">True</span>

<div class="viewcode-block" id="CureController.setup"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController.setup">[docs]</a>    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">max_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">desired_nxlinkbonds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">max_search_radius</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;setup sets up this CureController object</span>

<span class="sd">        :param max_nxlinkbonds: maximum allowable number of bonds, defaults to 0</span>
<span class="sd">        :type max_nxlinkbonds: int, optional</span>
<span class="sd">        :param desired_nxlinkbonds: desired number of bonds, defaults to 0</span>
<span class="sd">        :type desired_nxlinkbonds: int, optional</span>
<span class="sd">        :param max_search_radius: maximum search radius (nm), defaults to 0.0</span>
<span class="sd">        :type max_search_radius: float, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span>
        <span class="n">st</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="o">=</span><span class="n">max_nxlinkbonds</span>
        <span class="n">st</span><span class="o">.</span><span class="n">desired_nxlinkbonds</span><span class="o">=</span><span class="n">desired_nxlinkbonds</span>
        <span class="n">st</span><span class="o">.</span><span class="n">max_search_radius</span><span class="o">=</span><span class="n">max_search_radius</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;controls&#39;</span><span class="p">]</span>
        <span class="n">st</span><span class="o">.</span><span class="n">max_radidx</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">st</span><span class="o">.</span><span class="n">max_search_radius</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;search_radius&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;radial_increment&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="CureController.do_iter"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController.do_iter">[docs]</a>    <span class="nd">@cp</span><span class="o">.</span><span class="n">enableCheckpoint</span>
    <span class="k">def</span> <span class="nf">do_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;do_iter performs one CURE iteration</span>

<span class="sd">        :param TC: TopoCoord object; all topological and coordinate information is in here</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param RL: ReactionList object; list of all reaction types</span>
<span class="sd">        :type RL: ReactionList</span>
<span class="sd">        :param MD: MoleculeDict object; dictionary of all molecules, keyed by name</span>
<span class="sd">        :type MD: MoleculeDict</span>
<span class="sd">        :param gromacs_dict: dictionary of custom gromacs parameters, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        :return: dictionary of resulting output file names</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_logger</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="si">}</span><span class="s1"> begins&#39;</span><span class="p">,</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">,</span><span class="n">fill</span><span class="o">=</span><span class="s1">&#39;~&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">grab_files</span><span class="p">()</span> <span class="c1"># copy files locally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_bondsearch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_bondsearch</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">RL</span><span class="p">,</span><span class="n">MD</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_preupdate_dragging</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_topology_update</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">MD</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_relax</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_equilibrate</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="si">}</span><span class="s1"> current conversion </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_curr_conversion</span><span class="p">()</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> or </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="si">}</span><span class="s1"> bonds&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="n">TC</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">!=</span><span class="s1">&#39;mol2&#39;</span><span class="p">}</span></div>

<div class="viewcode-block" id="CureController.do_capping"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController.do_capping">[docs]</a>    <span class="nd">@cp</span><span class="o">.</span><span class="n">enableCheckpoint</span>
    <span class="k">def</span> <span class="nf">do_capping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;do_capping manages generation of all capping bonds</span>

<span class="sd">        :param TC: TopoCoord object containing all topology and coordinate information</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param RL: ReactionList object containing all reaction types</span>
<span class="sd">        :type RL: ReactionList</span>
<span class="sd">        :param MD: MoleculeDict object containing all molecule information</span>
<span class="sd">        :type MD: MoleculeDict</span>
<span class="sd">        :param gromacs_dict: dictionary of custom gromacs parameters, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        :return: dictionary of resulting output files, keyed by extension (&#39;gro&#39;, &#39;top&#39;, &#39;grx&#39;)</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_cap_bondsearch</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">RL</span><span class="p">,</span><span class="n">MD</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_topology_update</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">MD</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_relax</span><span class="p">(</span><span class="n">TC</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_equilibrate</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="n">TC</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span><span class="o">!=</span><span class="s1">&#39;mol2&#39;</span><span class="p">}</span></div>

<div class="viewcode-block" id="CureController.is_cured"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController.is_cured">[docs]</a>    <span class="k">def</span> <span class="nf">is_cured</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;is_cured returns True if system is cured</span>

<span class="sd">        :return: True if system is cured; False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;search_failed? </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">search_failed</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cumxlinks </span><span class="si">{</span><span class="n">st</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="si">}</span><span class="s1"> maxxlinks </span><span class="si">{</span><span class="n">st</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="o">&gt;=</span><span class="n">st</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">finished</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">search_failed</span> <span class="ow">or</span> <span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="o">&gt;=</span><span class="n">st</span><span class="o">.</span><span class="n">desired_nxlinkbonds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finished</span><span class="p">:</span>
            <span class="n">st</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_bondsearch</span>
        <span class="k">return</span> <span class="n">finished</span></div>

    <span class="k">def</span> <span class="nf">_curr_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_curr_conversion returns current conversion expressed as a fraction of the maximum number of possible bonds</span>

<span class="sd">        :return: conversion</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cum_nxlinkbonds</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">max_nxlinkbonds</span>

<div class="viewcode-block" id="CureController.reset"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reset resets this CureController object by resetting its CureState, its bonds dataframe, and its search_failed member</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_are</span><span class="o">=</span><span class="s1">&#39;nonexistent!&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_failed</span><span class="o">=</span><span class="kc">False</span></div>

<div class="viewcode-block" id="CureController.next_iter"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.curecontroller.CureController.next_iter">[docs]</a>    <span class="k">def</span> <span class="nf">next_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;next_iter resets this CureController for the next CURE iteration</span>

<span class="sd">        :return: True if new iteration index exceeds the maximum number of iterations allowed by runtime</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="o">+</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="o">=</span><span class="n">i</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;controls&#39;</span><span class="p">][</span><span class="s1">&#39;max_iterations&#39;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_do_bondsearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">,</span><span class="n">reentry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_do_bondsearch manages the search for new bonds</span>

<span class="sd">        :param TC: TopoCoord object containing all topology and coordinate information</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param RL: ReactionList containing all reaction types</span>
<span class="sd">        :type RL: ReactionList</span>
<span class="sd">        :param MD: MoleculeDict object containing all molecular templates, keyed by name</span>
<span class="sd">        :type MD: MoleculeDict</span>
<span class="sd">        :param reentry: True if we are restarting a bondsearch in this directory, defaults to False</span>
<span class="sd">        :type reentry: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_bondsearch</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">opfx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfx</span><span class="p">()</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;controls&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;search_radius&#39;</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radidx</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;radial_increment&#39;</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Bond search using radius </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="si">}</span><span class="s1"> nm initiated&#39;</span><span class="p">)</span>
        <span class="n">curr_conversion</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_curr_conversion</span><span class="p">()</span>
        <span class="n">apply_probabilities</span><span class="o">=</span><span class="n">curr_conversion</span><span class="o">&lt;</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;late_threshold&#39;</span><span class="p">]</span>
        <span class="n">bond_limit</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;max_conversion_per_iteration&#39;</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="p">)</span>
        <span class="n">bond_target</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;desired_conversion&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">curr_conversion</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">max_nxlinkbonds</span><span class="p">)</span>
        <span class="n">bond_limit</span><span class="o">=</span><span class="nb">min</span><span class="p">([</span><span class="n">bond_limit</span><span class="p">,</span><span class="n">bond_target</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration limited to at most </span><span class="si">{</span><span class="n">bond_limit</span><span class="si">}</span><span class="s1"> new bonds&#39;</span><span class="p">)</span>
        <span class="c1"># TODO: new branch: multisearch:</span>
        <span class="c1"># calc and store distances once outside this loop</span>
        <span class="c1"># have a controller that runs loop until a select number</span>
        <span class="c1"># of bonds has been formed, or we&#39;ve maxed out the radius</span>
        <span class="c1"># raw_bdf=self.make_candidates(TC,RL,MD,...)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; execute search radius updating until at lesast one bond is identified &#39;&#39;&#39;</span>
        <span class="n">nbonds</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="n">nbonds</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radidx</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">max_radidx</span><span class="p">:</span>
            <span class="c1"># test_bdf=raw_bdf[raw_bdf[&#39;r&#39;]&lt;self.current_radius]</span>
            <span class="c1"># result_bdf=self.apply_filters(TC,RL,MD,...)</span>
            <span class="n">nbdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_searchbonds</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">RL</span><span class="p">,</span><span class="n">MD</span><span class="p">,</span><span class="n">stage</span><span class="o">=</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">,</span><span class="n">abs_max</span><span class="o">=</span><span class="n">bond_limit</span><span class="p">,</span><span class="n">apply_probabilities</span><span class="o">=</span><span class="n">apply_probabilities</span><span class="p">,</span><span class="n">reentry</span><span class="o">=</span><span class="n">reentry</span><span class="p">)</span>
            <span class="n">nbonds</span><span class="o">=</span><span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># nbonds+=result_bdf.shape[0]</span>
            <span class="c1"># if nbonds&lt;PARAMETER:</span>
            <span class="k">if</span> <span class="n">nbonds</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radidx</span><span class="o">+=</span><span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="o">+=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;radial_increment&#39;</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Radius increased to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="si">}</span><span class="s1"> nm&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbonds</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">ess</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">nbonds</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;s&#39;</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="si">}</span><span class="s1"> will generate </span><span class="si">{</span><span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> new bond</span><span class="si">{</span><span class="n">ess</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">pairs</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># empty placeholder</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; compute all lengths &#39;&#39;&#39;</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">)</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; register all new bonds &#39;&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_bonds</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">pairs</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-bonds.csv&#39;</span><span class="p">,</span><span class="n">bonds_are</span><span class="o">=</span><span class="s1">&#39;identified&#39;</span><span class="p">)</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; declare intention to go to dragging or topology-update &#39;&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_drag</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dragging_enabled</span> <span class="k">else</span> <span class="n">cure_step</span><span class="o">.</span><span class="n">cure_update</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">search_failed</span><span class="o">=</span><span class="kc">True</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; declare intention to proceed to bond capping &#39;&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_bondsearch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;next: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_preupdate_dragging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_do_preupdate_dragging manages the preupdate dragging CURE step</span>

<span class="sd">        :param TC: the global system topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param gromacs_dict: dictionary of optional gromacs directives, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_drag</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">nbdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span>
        <span class="k">assert</span> <span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">]</span>
        <span class="n">nogos</span><span class="o">=</span><span class="p">[</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dragging_enabled</span><span class="p">,</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">&lt;</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;trigger_distance&#39;</span><span class="p">]]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nogos</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="nb">any</span><span class="p">(</span><span class="n">nogos</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">nogos</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No dragging is necessary&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_distance_attenuation</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;drag&#39;</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;next: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_relax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_do_relax manages relaxation steps within the CURE algorithm</span>

<span class="sd">        :param TC: global topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param gromacs_dict: dictionary of optional gromacs directives, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_relax</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_relax</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">nbdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span>
        <span class="k">if</span> <span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># no bonds identified</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">==</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_relax</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_bondsearch</span> <span class="c1"># drop out of CURE loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">finished</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_distance_attenuation</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;relax&#39;</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">==</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_relax</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_equilibrate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_equilibrate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;next: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_do_topology_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_do_topology_update manages the topology update in CURE</span>

<span class="sd">        :param TC: global system topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param MD: dictionary of all molecular templates</span>
<span class="sd">        :type MD: MoleculeDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_update</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_update</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">opfx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfx</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Topology update&#39;</span><span class="p">)</span>
        <span class="n">bonds_df</span><span class="p">,</span><span class="n">pairs_df</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">update_topology_and_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="p">,</span><span class="n">template_dict</span><span class="o">=</span><span class="n">MD</span><span class="p">,</span><span class="n">write_mapper_to</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-idx-mapper.csv&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">bonds_df</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">pairs_df</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_bonds</span><span class="p">(</span><span class="n">bonds_df</span><span class="p">,</span><span class="n">pairs_df</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-bonds.csv&#39;</span><span class="p">,</span><span class="n">bonds_are</span><span class="o">=</span><span class="s1">&#39;unrelaxed&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">write_top</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">write_grx_attributes</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">.grx&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">==</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_relax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_relax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_do_equilibrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_do_equilibrate manages pre- and post-cure equilibration runs</span>

<span class="sd">        :param TC: global system topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param gromacs_dict: dictionary of optional gromacs directives, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_equilibrate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_equilibrate</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;equilibrate&#39;</span><span class="p">]</span>
        <span class="n">opfx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfx</span><span class="p">()</span>
        <span class="n">edr_list</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">equilibrate</span><span class="p">(</span><span class="n">deffnm</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">edict</span><span class="o">=</span><span class="n">d</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="n">gromacs_dict</span><span class="p">)</span> <span class="c1">#,plot_pfx=f&#39;iter-{self.state.iter}-{str(self.state.step)}&#39;)</span>
        <span class="n">ens</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;ensemble&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ens</span><span class="o">==</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span>
            <span class="n">plot_pfx</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;iter-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="n">edr_list</span><span class="p">,</span><span class="n">outfile</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pfs</span><span class="o">.</span><span class="n">proj</span><span class="p">(),</span><span class="sa">f</span><span class="s1">&#39;plots/</span><span class="si">{</span><span class="n">plot_pfx</span><span class="si">}</span><span class="s1">-density.png&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">==</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_equilibrate</span><span class="p">:</span>
            <span class="c1"># go to next iteration -- this whole method is skipped if nbonds==0 in relax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cure_bondsearch</span> <span class="c1"># if not self.search_failed else state.cap_bondsearch</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">==</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_equilibrate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">finished</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_do_cap_bondsearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_do_cap_bondsearch manages the post-cure capping reaction bond search</span>

<span class="sd">        :param TC: global system topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param RL: list of all reactions</span>
<span class="sd">        :type RL: ReactionList</span>
<span class="sd">        :param MD: dictionary of all molecular templates</span>
<span class="sd">        :type MD: MoleculeDict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">!=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_bondsearch</span><span class="p">:</span> <span class="k">return</span>
        <span class="n">opfx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfx</span><span class="p">()</span>
        <span class="c1"># multi: nbdf=self.make_cadidates(...,stage=&#39;cap&#39;)</span>
        <span class="n">nbdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_searchbonds</span><span class="p">(</span><span class="n">TC</span><span class="p">,</span><span class="n">RL</span><span class="p">,</span><span class="n">MD</span><span class="p">,</span><span class="n">stage</span><span class="o">=</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cap</span><span class="p">)</span>
        <span class="n">nbonds</span><span class="o">=</span><span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ess</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">nbonds</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;s&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Capping will generate </span><span class="si">{</span><span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> new bond</span><span class="si">{</span><span class="n">ess</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbonds</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">cwd</span><span class="o">=</span><span class="n">pfs</span><span class="o">.</span><span class="n">go_to</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;systems/capping&#39;</span><span class="p">)</span>
            <span class="n">pairs</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span> <span class="c1"># empty placeholder</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_bonds</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">pairs</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-bonds.csv&#39;</span><span class="p">,</span><span class="n">bonds_are</span><span class="o">=</span><span class="s1">&#39;identified&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">cap_update</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">=</span><span class="n">cure_step</span><span class="o">.</span><span class="n">finished</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_write_bonds_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bondsfile</span><span class="o">=</span><span class="s1">&#39;bonds.csv&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_write_bonds_df writes all bonds in the bonds dataframe to a CSV file</span>

<span class="sd">        :param bondsfile: name of csv file to write, defaults to &#39;bonds.csv&#39;</span>
<span class="sd">        :type bondsfile: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">bondsfile</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">doublequote</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_bonds_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bonds_file_override</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_read_bonds_df reads bonds into bonds dataframe from a CSV file</span>

<span class="sd">        :param bonds_file_override: name of file to read from (overrides default), defaults to &#39;&#39;</span>
<span class="sd">        :type bonds_file_override: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">infile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;bonds_file&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">bonds_file_override</span> <span class="k">else</span> <span class="n">bonds_file_override</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">infile</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;Error: </span><span class="si">{</span><span class="n">infile</span><span class="si">}</span><span class="s1"> not found&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;bonds_file&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">infile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bonds</span><span class="p">,</span><span class="n">pairs</span><span class="p">,</span><span class="n">bonds_file</span><span class="p">,</span><span class="n">bonds_are</span><span class="o">=</span><span class="s1">&#39;unrelaxed&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_register_bonds registers the bonds, 1-4 pairs from the input parameters</span>

<span class="sd">        :param bonds: dataframe of bonds</span>
<span class="sd">        :type bonds: pd.DataFrame</span>
<span class="sd">        :param pairs: dataframe of 1-4 pairs</span>
<span class="sd">        :type pairs: pd.DataFrame</span>
<span class="sd">        :param bonds_file: file to which bonds are written</span>
<span class="sd">        :type bonds_file: str</span>
<span class="sd">        :param bonds_are: a little flag to remind us the state of these bonds, defaults to &#39;unrelaxed&#39;</span>
<span class="sd">        :type bonds_are: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="o">=</span><span class="n">bonds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs_df</span><span class="o">=</span><span class="n">pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bonds_are</span><span class="o">=</span><span class="n">bonds_are</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">bonds_file</span><span class="o">=</span><span class="n">bonds_file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_bonds_df</span><span class="p">(</span><span class="n">bonds_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;bonds_file&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">bonds_file</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pfx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_pfx generates a little string that can be used as a state-specific filename prefix</span>

<span class="sd">        :return: the little string</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">_distance_attenuation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;drag&#39;</span><span class="p">,</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_distance_attenuation manages the progressive attenuation of bond parameters for new bonds</span>

<span class="sd">        :param TC: global system topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param mode: string indicating whether this is prebonding or postbonding attentuation; defaults to &#39;drag&#39; (prebonding); other option is &#39;relax&#39; (postbonding)</span>
<span class="sd">        :type mode: str, optional</span>
<span class="sd">        :param gromacs_dict: dictionary of optional gromacs directives, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;drag&#39;</span><span class="p">,</span><span class="s1">&#39;relax&#39;</span><span class="p">]</span>
        <span class="n">statename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="o">.</span><span class="n">basename</span><span class="p">()</span>
        <span class="n">opfx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_pfx</span><span class="p">()</span>
        <span class="n">nbdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">maxL</span><span class="p">,</span><span class="n">minL</span><span class="p">,</span><span class="n">meanL</span><span class="o">=</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lengths avg/min/max: </span><span class="si">{</span><span class="n">meanL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">minL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">maxL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">ess</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;s&#39;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Step &quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="p">)</span><span class="si">}</span><span class="s1">&quot; initiated on </span><span class="si">{</span><span class="n">nbdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> distance</span><span class="si">{</span><span class="n">ess</span><span class="si">}</span><span class="s1"> (max </span><span class="si">{</span><span class="n">maxL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm)&#39;</span><span class="p">)</span>
        <span class="n">roptions</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;gromacs&#39;</span><span class="p">][</span><span class="s1">&#39;rdefault&#39;</span><span class="p">],</span><span class="n">maxL</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;drag&#39;</span><span class="p">:</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">add_restraints</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;     Stage  Max-distance (nm)&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pmaxL</span><span class="p">,</span><span class="n">pminL</span><span class="p">,</span><span class="n">pmeanL</span><span class="o">=</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;1-4 distances lengths avg/min/max: </span><span class="si">{</span><span class="n">pmeanL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">pminL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">pmaxL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">roptions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pmaxL</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;     Stage  Max-distance (nm)  Max-1-4-distance (nm)&#39;</span><span class="p">)</span>
        <span class="n">rcommon</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">roptions</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stg_dict</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;equilibration&#39;</span><span class="p">]:</span>
            <span class="n">ensemble</span><span class="o">=</span><span class="n">stg_dict</span><span class="p">[</span><span class="s1">&#39;ensemble&#39;</span><span class="p">]</span>
            <span class="n">impfx</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">statename</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ensemble</span><span class="si">}</span><span class="s1">&#39;</span> <span class="c1"># e.g., drag-min, drag-nvt, drag-npt</span>
            <span class="n">pfs</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mdp/</span><span class="si">{</span><span class="n">impfx</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
            <span class="n">mdp_mods_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;rvdw&#39;</span><span class="p">:</span><span class="n">rcommon</span><span class="p">,</span><span class="s1">&#39;rcoulomb&#39;</span><span class="p">:</span><span class="n">rcommon</span><span class="p">,</span><span class="s1">&#39;rlist&#39;</span><span class="p">:</span><span class="n">rcommon</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">!=</span><span class="s1">&#39;min&#39;</span><span class="p">:</span>
                <span class="n">mdp_mods_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;gen-temp&#39;</span><span class="p">:</span><span class="n">stg_dict</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">],</span><span class="s1">&#39;ref_t&#39;</span><span class="p">:</span><span class="n">stg_dict</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">],</span><span class="s1">&#39;gen-vel&#39;</span><span class="p">:</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span><span class="s1">&#39;nsteps&#39;</span><span class="p">:</span><span class="n">stg_dict</span><span class="p">[</span><span class="s1">&#39;nsteps&#39;</span><span class="p">]})</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="o">==</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span>
                <span class="n">mdp_mods_dict</span><span class="p">[</span><span class="s1">&#39;ref_p&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">stg_dict</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span>
            <span class="n">mdp_modify</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">impfx</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">,</span><span class="n">mdp_mods_dict</span><span class="p">,</span><span class="n">add_if_missing</span><span class="o">=</span><span class="p">(</span><span class="n">ensemble</span><span class="o">!=</span><span class="s1">&#39;min&#39;</span><span class="p">))</span>
        <span class="n">this_nstages</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">maxL</span><span class="o">/</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;increment&#39;</span><span class="p">])</span>
        <span class="n">this_firststage</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">step</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">this_nstages</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">this_firststage</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">saveT</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">copy_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">this_firststage</span><span class="p">,</span><span class="n">this_nstages</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;drag&#39;</span><span class="p">:</span>
                <span class="n">TC</span><span class="o">.</span><span class="n">attenuate_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">this_nstages</span><span class="p">,</span><span class="n">minimum_distance</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;limit&#39;</span><span class="p">],</span><span class="n">init_colname</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">TC</span><span class="o">.</span><span class="n">attenuate_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">this_nstages</span><span class="p">,</span><span class="n">init_colname</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">)</span>
            <span class="n">stagepfx</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-stage-</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">write_top</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stagepfx</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">stg_dict</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;equilibration&#39;</span><span class="p">]:</span>
                <span class="n">ensemble</span><span class="o">=</span><span class="n">stg_dict</span><span class="p">[</span><span class="s1">&#39;ensemble&#39;</span><span class="p">]</span>
                <span class="n">impfx</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">statename</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ensemble</span><span class="si">}</span><span class="s1">&#39;</span> <span class="c1"># e.g., drag-min, drag-nvt, drag-npt</span>
                <span class="n">TC</span><span class="o">.</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">stagepfx</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ensemble</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">mdp</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">impfx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">gromacs_dict</span><span class="p">)</span>
                <span class="c1"># logger.debug(f&#39;{TC.files[&quot;gro&quot;]}&#39;)</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">restore_bond_parameters</span><span class="p">(</span><span class="n">saveT</span><span class="p">)</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">)</span>
            <span class="n">maxL</span><span class="p">,</span><span class="n">minL</span><span class="p">,</span><span class="n">meanL</span><span class="o">=</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">nbdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Distances avg/min/max: </span><span class="si">{</span><span class="n">meanL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">minL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">maxL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;drag&#39;</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s1">&gt;10d</span><span class="si">}</span><span class="s1">  </span><span class="si">{</span><span class="n">maxL</span><span class="si">:</span><span class="s1">&gt;17.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">TC</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">pdf</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">)</span>
                <span class="n">pmaxL</span><span class="p">,</span><span class="n">pminL</span><span class="p">,</span><span class="n">pmeanL</span><span class="o">=</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;current_lengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;1-4 distances lengths avg/min/max: </span><span class="si">{</span><span class="n">pmeanL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">pminL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">pmaxL</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">:</span><span class="s1">&gt;10d</span><span class="si">}</span><span class="s1">  </span><span class="si">{</span><span class="n">maxL</span><span class="si">:</span><span class="s1">&gt;17.3f</span><span class="si">}</span><span class="s1">  </span><span class="si">{</span><span class="n">pmaxL</span><span class="si">:</span><span class="s1">&gt;21.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;drag&#39;</span><span class="p">:</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">remove_restraints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bonds_df</span><span class="p">)</span>
        <span class="n">TC</span><span class="o">.</span><span class="n">write_top</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-complete.top&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_bonds</span><span class="p">(</span><span class="n">nbdf</span><span class="p">,</span><span class="n">pdf</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">opfx</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">-bonds.csv&#39;</span><span class="p">,</span><span class="n">bonds_are</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;relaxed&#39;</span> <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;relax&#39;</span> <span class="k">else</span> <span class="s1">&#39;dragged&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_stage</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">_to_yaml</span><span class="p">()</span>

    <span class="c1"># TODO: move to searchbonds.by; split into make_candidates() and apply_filters()</span>
    <span class="k">def</span> <span class="nf">_searchbonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">TC</span><span class="p">:</span><span class="n">TopoCoord</span><span class="p">,</span><span class="n">RL</span><span class="p">:</span><span class="n">ReactionList</span><span class="p">,</span><span class="n">MD</span><span class="p">:</span><span class="n">MoleculeDict</span><span class="p">,</span><span class="n">stage</span><span class="o">=</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">,</span><span class="n">abs_max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">apply_probabilities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">reentry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_searchbonds manages the search for bonds</span>

<span class="sd">        :param TC: global system topology and coordinates</span>
<span class="sd">        :type TC: TopoCoord</span>
<span class="sd">        :param RL: list of all reactions</span>
<span class="sd">        :type RL: ReactionList</span>
<span class="sd">        :param MD: dictionary of all molecular templates</span>
<span class="sd">        :type MD: MoleculeDict</span>
<span class="sd">        :param stage: which reaction stage, defaults to reaction_stage.cure, other choice is reaction_stage.cap</span>
<span class="sd">        :type stage: reaction_stage, optional</span>
<span class="sd">        :param abs_max: upper limit to number of new bonds allowed, defaults to 0, signifying no limit</span>
<span class="sd">        :type abs_max: int, optional</span>
<span class="sd">        :param apply_probabilities: if true, bond probabilities are applied, defaults to False</span>
<span class="sd">        :type apply_probabilities: bool, optional</span>
<span class="sd">        :param reentry: if true, existing linkcell data stored on disk is used, defaults to False</span>
<span class="sd">        :type reentry: bool, optional</span>
<span class="sd">        :return: the dataframe of proposed bonds</span>
<span class="sd">        :rtype: pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adf</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">gro_DataFrame</span><span class="p">(</span><span class="s1">&#39;atoms&#39;</span><span class="p">)</span>
        <span class="n">gro</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">]</span>
        <span class="n">ncpu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dicts</span><span class="p">[</span><span class="s1">&#39;controls&#39;</span><span class="p">][</span><span class="s1">&#39;ncpu&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">stage</span><span class="o">==</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">:</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">linkcell_initialize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="p">,</span><span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span><span class="n">force_repopulate</span><span class="o">=</span><span class="n">reentry</span><span class="p">)</span>
        <span class="n">raset</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># this view will be used for downselecting to potential A-B partners</span>
        <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">Rlist</span><span class="o">=</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">RL</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">stage</span><span class="o">==</span><span class="n">stage</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">probability</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">)]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reactioncount </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">Rlist</span><span class="p">)</span><span class="si">}</span><span class="s1"> atomscount </span><span class="si">{</span><span class="n">raset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Rlist</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reaction </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span><span class="si">}</span><span class="s1"> bond(s)&#39;</span><span class="p">)</span>
            <span class="n">prob</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">probability</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">R</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">A</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">bond</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">B</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">bond</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">order</span><span class="o">=</span><span class="n">bond</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
                <span class="n">aname</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span>
                <span class="n">areactantname_template</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;reactant&#39;</span><span class="p">]]</span>
                <span class="n">aresid_template</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span>
                <span class="n">aresname</span><span class="o">=</span><span class="n">MD</span><span class="p">[</span><span class="n">areactantname_template</span><span class="p">]</span><span class="o">.</span><span class="n">get_resname</span><span class="p">(</span><span class="n">aresid_template</span><span class="p">)</span>
                <span class="n">az</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
                <span class="n">bname</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span>
                <span class="n">breactantname_template</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">reactants</span><span class="p">[</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;reactant&#39;</span><span class="p">]]</span>
                <span class="n">bresid_template</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;resid&#39;</span><span class="p">]</span>
                <span class="n">bresname</span><span class="o">=</span><span class="n">MD</span><span class="p">[</span><span class="n">breactantname_template</span><span class="p">]</span><span class="o">.</span><span class="n">get_resname</span><span class="p">(</span><span class="n">bresid_template</span><span class="p">)</span>
                <span class="n">bz</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">stage</span><span class="o">==</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cap</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">areactantname_template</span><span class="o">==</span><span class="n">breactantname_template</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: capping reaction </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> lists a bond whose atoms are in different reactants&#39;</span>
                    <span class="k">assert</span> <span class="n">aresname</span><span class="o">==</span><span class="n">bresname</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: capping reaction </span><span class="si">{</span><span class="n">R</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> lists a bond whose atoms are in different residues&#39;</span>

                <span class="n">Aset</span><span class="o">=</span><span class="n">raset</span><span class="p">[(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aname</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">aresname</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">az</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;reactantName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">areactantname_template</span><span class="p">)]</span>
                <span class="n">Bset</span><span class="o">=</span><span class="n">raset</span><span class="p">[(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">bname</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">bresname</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">bz</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">raset</span><span class="p">[</span><span class="s1">&#39;reactantName&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">breactantname_template</span><span class="p">)]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Aset </span><span class="si">{</span><span class="n">Aset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> atoms&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Bset </span><span class="si">{</span><span class="n">Bset</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> atoms&#39;</span><span class="p">)</span>
                <span class="n">alist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Aset</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="n">Aset</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="n">Aset</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()))</span>
                <span class="n">blist</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Bset</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="n">Bset</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="n">Bset</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()))</span>
                <span class="n">all_possible_pairs</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span><span class="n">blist</span><span class="p">))</span>

                <span class="n">idf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;ai&#39;</span><span class="p">:</span>           <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;ri&#39;</span><span class="p">:</span>           <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;mi&#39;</span><span class="p">:</span>           <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;aj&#39;</span><span class="p">:</span>           <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;rj&#39;</span><span class="p">:</span>           <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;mj&#39;</span><span class="p">:</span>           <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;prob&#39;</span><span class="p">:</span>         <span class="p">[</span><span class="n">prob</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;reactantName&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">R</span><span class="o">.</span><span class="n">product</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span>  <span class="n">all_possible_pairs</span><span class="p">],</span>
                                  <span class="s1">&#39;order&#39;</span><span class="p">:</span>        <span class="p">[</span><span class="n">order</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">all_possible_pairs</span><span class="p">]})</span>
                <span class="k">if</span> <span class="n">stage</span><span class="o">==</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">:</span>
                    <span class="c1"># exclude atom pairs that have same resid or molid</span>
                    <span class="n">idf</span><span class="o">=</span><span class="n">idf</span><span class="p">[(</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;ri&#39;</span><span class="p">]</span><span class="o">!=</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;rj&#39;</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;mi&#39;</span><span class="p">]</span><span class="o">!=</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;mj&#39;</span><span class="p">])]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Examining </span><span class="si">{</span><span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bond-candidates of order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">ess</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;s&#39;</span>
                        <span class="n">bondtestoutcomes</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">BTRC</span><span class="p">}</span>
                        <span class="n">p</span><span class="o">=</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">ncpu</span><span class="p">)</span>
                        <span class="n">idf_split</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">idf</span><span class="p">,</span><span class="n">ncpu</span><span class="p">)</span>
                        <span class="n">packets</span><span class="o">=</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">idf_split</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncpu</span><span class="p">)]</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Decomposed dataframe lengths: </span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">idf_split</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="n">results</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">gromacs_distance</span><span class="p">,</span><span class="n">gro</span><span class="o">=</span><span class="n">gro</span><span class="p">,</span><span class="n">new_column_name</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">),</span><span class="n">packets</span><span class="p">)</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                        <span class="c1"># reassemble final dataframe:</span>
                        <span class="c1"># logger.debug(f&#39;Checking dataframe lengths: {&quot;, &quot;.join([str(x.shape[0]) for x in results])}&#39;)</span>
                        <span class="n">idf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># gromacs_distance(idf,gro,new_column_name=&#39;r&#39;) # use &quot;gmx distance&quot; to very quickly get all lengths</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bond-candidate length</span><span class="si">{</span><span class="n">ess</span><span class="si">}</span><span class="s1"> avg/min/max: </span><span class="si">{</span><span class="n">idf</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="si">:</span><span class="s1">0.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">idf</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s1">0.3f</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">idf</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">:</span><span class="s1">0.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="n">idf</span><span class="o">=</span><span class="n">idf</span><span class="p">[</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">ess</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;s&#39;</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bond-candidate</span><span class="si">{</span><span class="n">ess</span><span class="si">}</span><span class="s1"> with lengths below </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">current_radius</span><span class="si">}</span><span class="s1"> nm&#39;</span><span class="p">)</span>
                        <span class="n">p</span><span class="o">=</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">ncpu</span><span class="p">)</span>
                        <span class="n">idf_split</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">idf</span><span class="p">,</span><span class="n">ncpu</span><span class="p">)</span>
                        <span class="c1"># logger.debug(f&#39;Decomposed dataframe lengths: {&quot;, &quot;.join([str(x.shape[0]) for x in idf_split])}&#39;)</span>
                        <span class="n">results</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">TC</span><span class="o">.</span><span class="n">bondtest_df</span><span class="p">),</span><span class="n">idf_split</span><span class="p">)</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
                        <span class="c1"># reassemble final dataframe:</span>
                        <span class="c1"># logger.debug(f&#39;Checking dataframe lengths: {&quot;, &quot;.join([str(x.shape[0]) for x in results])}&#39;)</span>
                        <span class="n">idf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">,</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">idf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Bond-candidate test outcomes:&#39;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">bondtestoutcomes</span><span class="p">:</span>
                                <span class="n">bondtestoutcomes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">idf</span><span class="p">[</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;   </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">bondtestoutcomes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="n">idf</span><span class="o">=</span><span class="n">idf</span><span class="p">[</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">BTRC</span><span class="o">.</span><span class="n">passed</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">stage</span><span class="o">==</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cap</span><span class="p">:</span>
                    <span class="n">idf</span><span class="o">=</span><span class="n">idf</span><span class="p">[</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;ri&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">idf</span><span class="p">[</span><span class="s1">&#39;rj&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Examining </span><span class="si">{</span><span class="n">idf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bond-candidates of order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">idf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">bdf</span><span class="p">,</span><span class="n">idf</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># logger.debug(&#39;Filtered (by single-bond tests) bonds:&#39;)</span>
        <span class="c1"># for ln in bdf.to_string().split(&#39;\n&#39;):</span>
        <span class="c1">#     logger.debug(ln)</span>

        <span class="k">if</span> <span class="n">stage</span><span class="o">==</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span> <span class="ow">and</span> <span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">bdf</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">unique_atomidx</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">to_list</span><span class="p">()))</span>
            <span class="n">unique_resids</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">ri</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">rj</span><span class="o">.</span><span class="n">to_list</span><span class="p">()))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ai</span> <span class="ow">in</span> <span class="n">unique_atomidx</span><span class="p">:</span>
                    <span class="n">unique_atomidx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># logger.debug(f&#39;Disallowing bond {i} due to repeated atom index {r.ai}&#39;)</span>
                    <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">aj</span> <span class="ow">in</span> <span class="n">unique_atomidx</span><span class="p">:</span>
                    <span class="n">unique_atomidx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># logger.debug(f&#39;Disallowing bond {i} due to repeated atom index {r.aj}&#39;)</span>
                    <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ri</span> <span class="ow">in</span> <span class="n">unique_resids</span><span class="p">:</span>
                    <span class="n">unique_resids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">ri</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># logger.debug(f&#39;Disallowing bond {i} due to repeated residue index {r.ri}&#39;)</span>
                    <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
                <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">rj</span> <span class="ow">in</span> <span class="n">unique_resids</span><span class="p">:</span>
                    <span class="n">unique_resids</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">rj</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># logger.debug(f&#39;Disallowing bond {i} due to repeated residue index {r.rj}&#39;)</span>
                    <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bdf</span><span class="p">[</span><span class="n">bdf</span><span class="p">[</span><span class="s2">&quot;allowed&quot;</span><span class="p">]</span><span class="o">==</span><span class="kc">False</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bonds disallowed due to repeated atom indexes or residue indexes&#39;</span><span class="p">)</span>

            <span class="n">bdf</span><span class="o">=</span><span class="n">bdf</span><span class="p">[</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;allowed&#39;</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># logger.debug(&#39;Allowed bonds:&#39;)</span>
            <span class="c1"># for ln in bdf.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>

            <span class="n">bdf</span><span class="o">=</span><span class="n">TC</span><span class="o">.</span><span class="n">cycle_collective</span><span class="p">(</span><span class="n">bdf</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bdf</span><span class="p">[</span><span class="n">bdf</span><span class="p">[</span><span class="s2">&quot;remove-to-uncyclize&quot;</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bonds removed to break nascent cycles&#39;</span><span class="p">)</span>
            <span class="n">bdf</span><span class="o">=</span><span class="n">bdf</span><span class="p">[</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;remove-to-uncyclize&#39;</span><span class="p">]</span><span class="o">==</span><span class="kc">False</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># logger.debug(&#39;Non-cyclizing bonds:&#39;)</span>
            <span class="c1"># for ln in bdf.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39; roll the dice &#39;&#39;&#39;</span>
            <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;lucky&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">if</span> <span class="n">apply_probabilities</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">r</span><span class="o">.</span><span class="n">prob</span><span class="p">:</span>
                        <span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;lucky&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">bdf</span><span class="p">[</span><span class="n">bdf</span><span class="p">[</span><span class="s2">&quot;lucky&quot;</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bonds survive probability application&#39;</span><span class="p">)</span>
            <span class="n">bdf</span><span class="o">=</span><span class="n">bdf</span><span class="p">[</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;lucky&#39;</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># logger.debug(&#39;Lucky bonds:&#39;)</span>
            <span class="c1"># for ln in bdf.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>

<span class="w">            </span><span class="sd">&#39;&#39;&#39; apply the stated limit &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="n">abs_max</span><span class="o">&gt;-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abs_max</span><span class="o">&lt;</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">bdf</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[:</span><span class="n">abs_max</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Limiting to </span><span class="si">{</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> allowed bonds&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Final bonds:&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stage</span><span class="o">==</span><span class="n">reaction_stage</span><span class="o">.</span><span class="n">cure</span><span class="p">:</span>
            <span class="n">TC</span><span class="o">.</span><span class="n">linkcell_cleanup</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">bdf</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">HTPolyNet</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation and Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-tutorials/index.html">Example Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference-materials/index.html">Reference Materials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTPolyNetPackage.html">HTPolyNet package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Cameron Abrams, Ming Huang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.0.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>