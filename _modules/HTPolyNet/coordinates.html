<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTPolyNet.coordinates &#8212; HTPolyNet 1.0.8 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script src="../../_static/documentation_options.js?v=aec50437"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for HTPolyNet.coordinates</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: coordinates</span>
<span class="sd">   :synopsis: Class for managing gromacs .gro file data</span>

<span class="sd">.. moduleauthor: Cameron F. Abrams, &lt;cfa22@drexel.edu&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="kn">from</span> <span class="nn">HTPolyNet.bondlist</span> <span class="kn">import</span> <span class="n">Bondlist</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.linkcell</span> <span class="kn">import</span> <span class="n">Linkcell</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.ring</span> <span class="kn">import</span> <span class="n">Ring</span><span class="p">,</span><span class="n">Segment</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.dataframetools</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.matrix4</span> <span class="kn">import</span> <span class="n">Matrix4</span>

<span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">GRX_ATTRIBUTES</span>     <span class="o">=</span><span class="p">[</span>  <span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,</span><span class="s1">&#39;reactantName&#39;</span><span class="p">,</span><span class="s1">&#39;sea_idx&#39;</span><span class="p">,</span><span class="s1">&#39;chain&#39;</span><span class="p">,</span><span class="s1">&#39;chain_idx&#39;</span><span class="p">,</span><span class="s1">&#39;molecule&#39;</span><span class="p">,</span><span class="s1">&#39;molecule_name&#39;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;Extended atom attributes</span>

<span class="sd">    - &#39;z&#39; number of sacrificial H&#39;s on atom </span>
<span class="sd">    - &#39;nreactions&#39; number of H&#39;s sacrificed so far to form bonds</span>
<span class="sd">    - &#39;reactantName&#39; name of most recent reactant to which atom belonged</span>
<span class="sd">    - &#39;sea_idx&#39; index of the group of symmetry-related atoms this atom belongs to (atoms with the same sea_idx in the same resid are considered symmetry-equivalent)</span>
<span class="sd">    - &#39;chain&#39; index of the unique chain this atom belongs to</span>
<span class="sd">    - &#39;chain_idx&#39; index of this atom within this chain</span>
<span class="sd">    - &#39;molecule&#39; index of the unique molecule this atom belongs to</span>
<span class="sd">    - &#39;molecule_name&#39; name of that molecule</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">GRX_GLOBALLY_UNIQUE</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span>       <span class="kc">False</span><span class="p">,</span>         <span class="kc">False</span><span class="p">,</span>     <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>      <span class="kc">False</span><span class="p">,</span>      <span class="kc">True</span><span class="p">,</span>          <span class="kc">False</span><span class="p">]</span>
<span class="n">GRX_UNSET_DEFAULTS</span> <span class="o">=</span><span class="p">[</span>    <span class="mi">0</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>       <span class="s1">&#39;UNSET&#39;</span><span class="p">,</span>       <span class="o">-</span><span class="mi">1</span><span class="p">,</span>    <span class="o">-</span><span class="mi">1</span><span class="p">,</span>          <span class="o">-</span><span class="mi">1</span><span class="p">,</span>       <span class="o">-</span><span class="mi">1</span><span class="p">,</span>        <span class="s1">&#39;UNSET&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="dfrotate">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.dfrotate">[docs]</a>
<span class="k">def</span> <span class="nf">dfrotate</span><span class="p">(</span><span class="n">df</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;dfrotate applies rotation matrix R to coordinates in dataframe</span>

<span class="sd">    :param df: coordinates dataframe; must have &#39;posX&#39;, &#39;posY&#39;, and &#39;posZ&#39; columns</span>
<span class="sd">    :type df: pd.DataFrame</span>
<span class="sd">    :param R: rotation matrix</span>
<span class="sd">    :type R: np.ndarray((3,3))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">srow</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">ri</span><span class="o">=</span><span class="n">srow</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">newri</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">ri</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;posX&#39;</span><span class="p">:</span><span class="s1">&#39;posZ&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">newri</span></div>


<div class="viewcode-block" id="Coordinates">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates">[docs]</a>
<span class="k">class</span> <span class="nc">Coordinates</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Handles atom coordinates.</span>

<span class="sd">    The primary object is `A`, a pandas DataFrame with one row per atom.  Each atom has attributes that may be found in a `gro` file and/or a `mol2` file, along with so-called extended attributes, which are used solely  by HTPolyNet.  </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gro_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span> <span class="s1">&#39;resName&#39;</span><span class="p">,</span> <span class="s1">&#39;atomName&#39;</span><span class="p">,</span> <span class="s1">&#39;globalIdx&#39;</span><span class="p">,</span> <span class="s1">&#39;posX&#39;</span><span class="p">,</span> <span class="s1">&#39;posY&#39;</span><span class="p">,</span> <span class="s1">&#39;posZ&#39;</span><span class="p">,</span> <span class="s1">&#39;velX&#39;</span><span class="p">,</span> <span class="s1">&#39;velY&#39;</span><span class="p">,</span> <span class="s1">&#39;velZ&#39;</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;GRO format atom attributes</span>
<span class="sd">    </span>
<span class="sd">    - &#39;resNum&#39; unique index of residue to which atom belongs</span>
<span class="sd">    - &#39;resName&#39; name of that residue (usually a 3-letter designation)</span>
<span class="sd">    - &#39;atomName&#39; name of this atom, must be unique within a residue</span>
<span class="sd">    - &#39;globalIdx&#39; global index of atom in whole system</span>
<span class="sd">    - &#39;posX&#39;, &#39;posY&#39;, &#39;posZ&#39; cartesian coordinates</span>
<span class="sd">    - &#39;velX&#39;, &#39;velY&#39;, &#39;velZ&#39; cartesian velocities</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol2_atom_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">,</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;resName&#39;</span><span class="p">,</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;MOL2 format atom attributes</span>
<span class="sd">    </span>
<span class="sd">    - &#39;globalIdx&#39; global index of atom in whole system</span>
<span class="sd">    - &#39;atomName&#39; name of this atom, must be unique within a residue</span>
<span class="sd">    - &#39;posX&#39;, &#39;posY&#39;, &#39;posZ&#39; cartesian coordinates</span>
<span class="sd">    - &#39;resNum&#39; unique index of residue to which atom belongs</span>
<span class="sd">    - &#39;resName&#39; name of that residue (usually a 3-letter designation)</span>
<span class="sd">    - &#39;charge&#39; charge on atom</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol2_bond_attributes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">,</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;order&#39;</span><span class="p">]</span>
    <span class="n">mol2_bond_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mol2_bond_attributes</span><span class="p">,</span> <span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;__init__ contructs an empty Coordinates object</span>

<span class="sd">        :param name: a name string, defaults to &#39;&#39;</span>
<span class="sd">        :type name: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linkcell</span><span class="o">=</span><span class="n">Linkcell</span><span class="p">(</span><span class="n">pbc_wrapper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap_point</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="o">=</span><span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grx_attributes</span><span class="o">=</span><span class="n">GRX_ATTRIBUTES</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">=</span><span class="kc">None</span>
        
<div class="viewcode-block" id="Coordinates.read_gro">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.read_gro">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_gro</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_gro Read a Gromacs gro file</span>

<span class="sd">        :param filename: name of gro file</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :return: a new Coordinates instance</span>
<span class="sd">        :rtype: Coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inst</span><span class="o">=</span><span class="bp">cls</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">while</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">N</span>
                <span class="n">series</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">gro_attributes</span><span class="p">}</span>
                <span class="n">lc_globalIdx</span><span class="o">=</span><span class="mi">1</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">15</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
<span class="w">                    </span><span class="sd">&#39;&#39;&#39; if formatted correctly, globalIdx is row index + 1 always! &#39;&#39;&#39;</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc_globalIdx</span><span class="p">)</span>
                    <span class="n">lc_globalIdx</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="c1"># split won&#39;t work since sometimes there might be no spaces</span>
                    <span class="c1"># &quot;%5d%-5s%5s%5d%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f&quot;</span>
                    <span class="c1">#numbers=list(map(float,[y.strip() for y in x[20:].split()]))</span>
                    <span class="n">numbers</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,[</span><span class="n">x</span><span class="p">[</span><span class="mi">20</span><span class="o">+</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">20</span><span class="o">+</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">44</span><span class="p">:</span>
                        <span class="n">numbers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,[</span><span class="n">x</span><span class="p">[</span><span class="mi">44</span><span class="o">+</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">44</span><span class="o">+</span><span class="mi">8</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)])))</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;posX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;posY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">series</span><span class="p">[</span><span class="s1">&#39;posZ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">==</span><span class="mi">6</span><span class="p">:</span>
                        <span class="n">series</span><span class="p">[</span><span class="s1">&#39;velX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                        <span class="n">series</span><span class="p">[</span><span class="s1">&#39;velY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
                        <span class="n">series</span><span class="p">[</span><span class="s1">&#39;velZ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="s1">&#39;velX&#39;</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">series</span><span class="p">[</span><span class="s1">&#39;velX&#39;</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">series</span><span class="p">[</span><span class="s1">&#39;velY&#39;</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">series</span><span class="p">[</span><span class="s1">&#39;velZ&#39;</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">inst</span><span class="o">.</span><span class="n">N</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]),</span> <span class="sa">f</span><span class="s1">&#39;Atom count mismatch inside </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="c1"># for k,v in series.items():</span>
                <span class="c1">#     logger.debug(f&#39;in coordinates.read_gro: {k} has {len(v)} items.&#39;)</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
                <span class="n">boxdataline</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">boxdata</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span><span class="n">boxdataline</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
                <span class="c1"># logger.debug(f&#39;boxdata {boxdata}&#39;)</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">boxdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">boxdata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">boxdata</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># logger.debug(f&#39;box: {inst.box}&#39;)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boxdata</span><span class="p">)</span><span class="o">==</span><span class="mi">9</span><span class="p">:</span>
                    <span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">inst</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">boxdata</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">empty</span><span class="o">=</span><span class="kc">False</span>
        <span class="c1"># logger.debug(f&#39;{inst.checkbox()}&#39;)</span>
        <span class="c1"># logger.debug(&#39;Box vectors:&#39;)</span>
        <span class="c1"># for ln in str(inst.box).split(&#39;\n&#39;):</span>
        <span class="c1">#     logger.debug(ln)</span>
        <span class="k">if</span> <span class="n">wrap_coords</span><span class="p">:</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">wrap_coords</span><span class="p">()</span>
        <span class="c1"># logger.debug(inst.A.dtypes)</span>
        <span class="k">return</span> <span class="n">inst</span></div>


<div class="viewcode-block" id="Coordinates.read_mol2">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.read_mol2">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_mol2</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_mol2 Reads in a Sybyl MOL2 file into a Coordinates instance. </span>
<span class="sd">            Note that this method only reads in</span>
<span class="sd">            MOLECULE, ATOM, and BOND sections. </span>

<span class="sd">        :param filename: name of input mol2 file</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :return: a new Coordinates instance</span>
<span class="sd">        :rtype: Coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;***ALL LENGTHS CONVERTED FROM ANGSTROMS TO NM***&#39;&#39;&#39;</span>
        <span class="n">inst</span><span class="o">=</span><span class="bp">cls</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Length units in MOL2 are always Ångström &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">rawsections</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">sections</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">rs</span> <span class="ow">in</span> <span class="n">rawsections</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span><span class="n">rs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">key</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">val</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">==</span><span class="s1">&#39;atom&#39;</span> <span class="ow">or</span> <span class="n">key</span><span class="o">==</span><span class="s1">&#39;bond&#39;</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">=</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="n">sections</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">val</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">sections</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">imetadat</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="n">sections</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="n">imetadat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nBonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">imetadat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nSubs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">imetadat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nFeatures&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">imetadat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nSets&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">imetadat</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;mol2type&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">sections</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;mol2chargetype&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">sections</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">sections</span><span class="p">[</span><span class="s1">&#39;atom&#39;</span><span class="p">],</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">mol2_atom_attributes</span><span class="p">)</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">A</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">*=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">sections</span><span class="p">[</span><span class="s1">&#39;bond&#39;</span><span class="p">],</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">mol2_bond_attributes</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">mol2_bond_types</span><span class="p">)</span>
            <span class="c1"># sort so atom indices are increasing in each bond</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">ai</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span>
                <span class="n">aj</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">aj</span><span class="o">&lt;</span><span class="n">ai</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mol2 bonds swapping </span><span class="si">{</span><span class="n">ai</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">aj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aj</span>
                    <span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ai</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">mol2_bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="o">.</span><span class="n">fromDataFrame</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="p">)</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">empty</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">return</span> <span class="n">inst</span></div>


<div class="viewcode-block" id="Coordinates.fcc">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.fcc">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fcc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">nc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;fcc generates a Coordinates object that represents an FCC crystal</span>

<span class="sd">        :param a: lattice parameter</span>
<span class="sd">        :type a: float</span>
<span class="sd">        :param nc: number of unit cells in the three lattice vector directions, defaults to [1,1,1]</span>
<span class="sd">        :type nc: list, optional</span>
<span class="sd">        :return: a Coordinates object</span>
<span class="sd">        :rtype: Coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inst</span><span class="o">=</span><span class="bp">cls</span><span class="p">()</span>
        <span class="n">basis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">a</span>
        <span class="n">base_atoms</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]])</span><span class="o">*</span><span class="n">a</span>
        <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">p</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nc</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">):</span>
            <span class="n">ll</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base_atoms</span><span class="p">)):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ll</span><span class="o">+</span><span class="n">base_atoms</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
        <span class="c1"># print(p)</span>
        <span class="n">posn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># print(posn)</span>
        <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">posn</span><span class="p">)</span>
        <span class="n">adf</span><span class="o">=</span><span class="n">inst</span><span class="o">.</span><span class="n">A</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;AL&#39;</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;posX&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">posn</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;posY&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">posn</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;posZ&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">posn</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resName&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;MET&#39;</span>
        <span class="n">inst</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="n">N</span>
        <span class="k">return</span> <span class="n">inst</span></div>


<div class="viewcode-block" id="Coordinates.claim_parent">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.claim_parent">[docs]</a>
    <span class="k">def</span> <span class="nf">claim_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">=</span><span class="n">parent</span></div>


<div class="viewcode-block" id="Coordinates.set_box">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.set_box">[docs]</a>
    <span class="k">def</span> <span class="nf">set_box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">box</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_box Set the box size from box</span>

<span class="sd">        :param box: 3-by-1 or 3-by-3 box size matrix</span>
<span class="sd">        :type box: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">box</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">box</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">box</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.total_volume">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.total_volume">[docs]</a>
    <span class="k">def</span> <span class="nf">total_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;gromacs&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns total volume of box.</span>

<span class="sd">        :param units: unit system designation; if &#39;SI&#39; returns m^3, defaults to &#39;gromacs&#39;</span>
<span class="sd">        :type units: str, optional</span>
<span class="sd">        :return: volume (in nm^3 if units is &#39;gromacs&#39; or m^3 if units is &#39;SI&#39;)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nm_per_m</span><span class="o">=</span><span class="mf">1.e9</span>
        <span class="n">vol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>  <span class="c1"># nm^3</span>
        <span class="k">return</span> <span class="n">vol</span> <span class="k">if</span> <span class="n">units</span><span class="o">!=</span><span class="s1">&#39;SI&#39;</span> <span class="k">else</span> <span class="n">vol</span><span class="o">/</span><span class="p">(</span><span class="n">nm_per_m</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.copy_coords">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.copy_coords">[docs]</a>
    <span class="k">def</span> <span class="nf">copy_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;copy_coords copy_coords copy the posX, posY, and posZ atom attributes, and the box size, </span>
<span class="sd">        from other.A to self.A</span>

<span class="sd">        :param other: the other Coordinates instance</span>
<span class="sd">        :type other: Coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="sa">f</span><span class="s1">&#39;Cannot copy -- atom count mismatch </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> vs </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]:</span>
            <span class="n">otherpos</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">otherpos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">box</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.subcoords">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.subcoords">[docs]</a>
    <span class="k">def</span> <span class="nf">subcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sub_adf</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;subcoords generates a new Coordinates object to hold the atoms dataframe in &#39;sub_adf&#39; parameter</span>

<span class="sd">        :param sub_adf: an atom dataframe</span>
<span class="sd">        :type sub_adf: pd.DataFrame</span>
<span class="sd">        :return: a new Coordinates object</span>
<span class="sd">        :rtype: Coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newC</span><span class="o">=</span><span class="n">Coordinates</span><span class="p">()</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">set_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">sub_adf</span>
        <span class="n">newC</span><span class="o">.</span><span class="n">N</span><span class="o">=</span><span class="n">sub_adf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">newC</span></div>

    
<div class="viewcode-block" id="Coordinates.reconcile_subcoords">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.reconcile_subcoords">[docs]</a>
    <span class="k">def</span> <span class="nf">reconcile_subcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">subc</span><span class="p">,</span><span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;moves all values of attribute name contained in attr from Coordinates object subc to self</span>

<span class="sd">        :param subc: A separate, independent Coordinates object</span>
<span class="sd">        :type subc: Coordinates</span>
<span class="sd">        :param attr: attribute name whose value is to be copied from subc to self</span>
<span class="sd">        :type attr: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jdx</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">subc</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">subc</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">globalIdx</span>
            <span class="n">lc_idx</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">attr</span><span class="p">]</span><span class="o">=</span><span class="n">lc_idx</span></div>


<div class="viewcode-block" id="Coordinates.unwrap">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.unwrap">[docs]</a>
    <span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">O</span><span class="p">,</span><span class="n">pbc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;unwrap shifts point P to its unwrapped closest periodic image to point O</span>

<span class="sd">        :param P: a point</span>
<span class="sd">        :type P: np.ndarray(3,float)</span>
<span class="sd">        :param O: origin</span>
<span class="sd">        :type O: np.ndarray(3,float)</span>
<span class="sd">        :param pbc: directions in which pbc are applied</span>
<span class="sd">        :type pbc: np.ndarray(3,int)</span>
<span class="sd">        :return: a point</span>
<span class="sd">        :rtype: nd.ndarray(3,float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ROP</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mic</span><span class="p">(</span><span class="n">O</span><span class="o">-</span><span class="n">P</span><span class="p">,</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">PCPI</span><span class="o">=</span><span class="n">O</span><span class="o">-</span><span class="n">ROP</span>
        <span class="k">return</span> <span class="n">PCPI</span></div>


<div class="viewcode-block" id="Coordinates.pierces">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.pierces">[docs]</a>
    <span class="k">def</span> <span class="nf">pierces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">B</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">C</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">pbc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;pierces determines whether or not bond represented by two points in B pierces ring represented by N points in C</span>

<span class="sd">        :param B: two points defining a bond</span>
<span class="sd">        :type B: pd.DataFrame</span>
<span class="sd">        :param C: N points defining a ring</span>
<span class="sd">        :type C: pd.DataFrame</span>
<span class="sd">        :param pbc: periodic boundary condition flags, one per dimension</span>
<span class="sd">        :type pbc: list</span>
<span class="sd">        :return: True if ring is pierced</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BC</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]])</span>
        <span class="n">CC</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">C</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]])</span>
        <span class="c1"># get both atoms in bond into CPI</span>
        <span class="c1"># get all atoms in ring into CPI (but not necessarily wrt bond)</span>
        <span class="n">CC</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">CC</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pbc</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">CC</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="n">BC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">BC</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">CC</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">BC</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">BC</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">BC</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">BC</span>
        <span class="n">C</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">CC</span>
        <span class="n">S</span><span class="o">=</span><span class="n">Segment</span><span class="p">(</span><span class="n">BC</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span><span class="n">Ring</span><span class="p">(</span><span class="n">CC</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
        <span class="n">do_it</span><span class="p">,</span><span class="n">point</span><span class="o">=</span><span class="n">R</span><span class="o">.</span><span class="n">segint</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">do_it</span></div>


<div class="viewcode-block" id="Coordinates.linkcell_initialize">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.linkcell_initialize">[docs]</a>
    <span class="k">def</span> <span class="nf">linkcell_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">ncpu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">populate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">force_repopulate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;linkcell_initialize initializes link-cell structure for ring-pierce testing</span>

<span class="sd">        :param cutoff: cutoff radius for link-cell structure, defaults to 0.0</span>
<span class="sd">        :type cutoff: float, optional</span>
<span class="sd">        :param ncpu: number of cpus to use to populate link-cell structure, defaults to 1</span>
<span class="sd">        :type ncpu: int, optional</span>
<span class="sd">        :param populate: If True, an actual population of the link-cell structure is performed; defaults to True</span>
<span class="sd">        :type populate: bool, optional</span>
<span class="sd">        :param force_repopulate: If True and this link-cell structure is already populated, a repopulation is performed based on the current Coordinates; defaults to False</span>
<span class="sd">        :type force_repopulate: bool, optional</span>
<span class="sd">        :param save: If true, all atoms&#39; linkcell_idx attributes are written to an output file; defaults to True</span>
<span class="sd">        :type save: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Initializing link-cell structure&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linkcell</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">populate</span><span class="p">:</span>
            <span class="n">lc_file</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;linkcell-</span><span class="si">{</span><span class="n">cutoff</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">.grx&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">lc_file</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force_repopulate</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="n">lc_file</span><span class="si">}</span><span class="s1">; no need to populate.&#39;</span><span class="p">)</span>
                <span class="n">results</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_atomset_attributes</span><span class="p">(</span><span class="n">lc_file</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Read linkcell_idx from </span><span class="si">{</span><span class="n">lc_file</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="p">(</span><span class="s2">&quot;linkcell_idx&quot;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">results</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">linkcell</span><span class="o">.</span><span class="n">make_memberlists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_atomset_attribute</span><span class="p">(</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                <span class="c1"># we only populate with atoms whose positions will be needed in interatomic</span>
                <span class="c1"># distance calculations; these are those (a) in rings, or (b) are reactive</span>
                <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subcoords</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">rings</span><span class="o">.</span><span class="n">all_atoms</span><span class="p">()))</span><span class="o">|</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">linkcell</span><span class="o">.</span><span class="n">populate</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reconcile_subcoords</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write_atomset_attributes</span><span class="p">([</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">],</span><span class="n">lc_file</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.linkcelltest">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.linkcelltest">[docs]</a>
    <span class="k">def</span> <span class="nf">linkcelltest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;linkcelltest returns True if atoms i and j are within potential interaction</span>
<span class="sd">            range based on current link-cell structure</span>

<span class="sd">        :param i: An atom index</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :param j: another atom index</span>
<span class="sd">        :type j: int</span>
<span class="sd">        :return: True if i and j are in the same cell or in neighboring cells</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ci</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
        <span class="n">cj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">ci</span><span class="o">==</span><span class="n">cj</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linkcell</span><span class="o">.</span><span class="n">are_ldx_neighbors</span><span class="p">(</span><span class="n">ci</span><span class="p">,</span><span class="n">cj</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="Coordinates.geometric_center">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.geometric_center">[docs]</a>
    <span class="k">def</span> <span class="nf">geometric_center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;geometric_center computes and returns the geometric center of the atoms in self&#39;s A dataframe</span>

<span class="sd">        :return: geometric center</span>
<span class="sd">        :rtype: np.ndarray(3,float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">posX</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span><span class="n">a</span><span class="o">.</span><span class="n">posY</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span><span class="n">a</span><span class="o">.</span><span class="n">posZ</span><span class="o">.</span><span class="n">mean</span><span class="p">()])</span></div>


<div class="viewcode-block" id="Coordinates.rij">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.rij">[docs]</a>
    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;rij compute distance between atoms i and j</span>

<span class="sd">        :return: distance between i and j</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pbc</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Interatomic distance calculation using PBC with no boxsize set.&#39;</span><span class="p">)</span>
        <span class="n">ri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">rj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">Rij</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mic</span><span class="p">(</span><span class="n">ri</span><span class="o">-</span><span class="n">rj</span><span class="p">,</span><span class="n">pbc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Rij</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rij</span><span class="p">))</span></div>


<div class="viewcode-block" id="Coordinates.mic">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.mic">[docs]</a>
    <span class="k">def</span> <span class="nf">mic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">pbc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;mic applies minimum image convention to displacement vector r</span>

<span class="sd">        :param r: displacement vector</span>
<span class="sd">        :type r: np.ndarray(3,float)</span>
<span class="sd">        :param pbc: periodic boundary condition </span>
<span class="sd">        :type pbc: _type_</span>
<span class="sd">        :return: _description_</span>
<span class="sd">        :rtype: _type_</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;  &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pbc</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
                <span class="n">hbx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
                <span class="k">while</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">&lt;-</span><span class="n">hbx</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">&gt;</span><span class="n">hbx</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">-=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="Coordinates.wrap_point">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.wrap_point">[docs]</a>
    <span class="k">def</span> <span class="nf">wrap_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ri</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wrap_point wraps point ri into the central periodic image</span>

<span class="sd">        :param ri: a point</span>
<span class="sd">        :type ri: np.ndarray(3,float)</span>
<span class="sd">        :return: a tuple containing (1) the wrapped point and (2) number of box lengths required to wrap this point, per dimension</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span><span class="o">=</span><span class="n">ri</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">box_lengths</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">box_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">while</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">box_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">,</span><span class="n">box_lengths</span></div>


<div class="viewcode-block" id="Coordinates.wrap_coords">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.wrap_coords">[docs]</a>
    <span class="k">def</span> <span class="nf">wrap_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wrap_coords Wraps all atomic coordinates into box</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;Cannot wrap if boxsize is not set: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">sp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="n">boxL</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">srow</span> <span class="ow">in</span> <span class="n">sp</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">p</span><span class="p">,</span><span class="n">box_lengths</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wrap_point</span><span class="p">(</span><span class="n">srow</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;posX&#39;</span><span class="p">:</span><span class="s1">&#39;posZ&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">p</span>
            <span class="n">boxL</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box_lengths</span><span class="p">)</span>
        <span class="n">boxL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">boxL</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;boxLx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">boxL</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;boxLy&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">boxL</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;boxLz&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">boxL</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span></div>

        <span class="c1"># logger.debug(f&#39;Wrapped {self._nwrap}/{self.A.shape[0]*3} coordinates.&#39;)</span>

<div class="viewcode-block" id="Coordinates.merge">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.merge">[docs]</a>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;merge Merge two Coordinates objects</span>

<span class="sd">        :param other: the other Coordinates object</span>
<span class="sd">        :type other: Coordinates</span>
<span class="sd">        :return: integer shifts in atom index, bond index, and residue index as a 3-tuple</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idxshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bdxshift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rdxshift</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">empty</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span>
        <span class="n">nOtherBonds</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">oa</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; shift residue indices in other before merging &#39;&#39;&#39;</span>
            <span class="n">oa</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">idxshift</span>
            <span class="n">oa</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">rdxshift</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span><span class="n">oa</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">+=</span><span class="n">oa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; count number of mol2_bonds in other &#39;&#39;&#39;</span>
            <span class="n">nOtherBonds</span><span class="o">=</span><span class="n">ob</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; shift bond indices in other &#39;&#39;&#39;</span>
            <span class="n">ob</span><span class="p">[</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">bdxshift</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">]:</span>
                <span class="n">ob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+=</span><span class="n">idxshift</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="p">,</span><span class="n">ob</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bondlist</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span>
        <span class="k">if</span> <span class="s1">&#39;nBonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nBonds&#39;</span><span class="p">]</span><span class="o">+=</span><span class="n">nOtherBonds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nBonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">nOtherBonds</span>
        
        <span class="k">return</span> <span class="p">(</span><span class="n">idxshift</span><span class="p">,</span><span class="n">bdxshift</span><span class="p">,</span><span class="n">rdxshift</span><span class="p">)</span></div>

            
<div class="viewcode-block" id="Coordinates.write_atomset_attributes">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.write_atomset_attributes">[docs]</a>
    <span class="k">def</span> <span class="nf">write_atomset_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attributes</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">formatters</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_atomset_attributes Writes atom attributes to a file</span>

<span class="sd">        :param attributes: List of attribute names to write</span>
<span class="sd">        :type attributes: list, optional</span>
<span class="sd">        :param filename: Name of file to write</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :param formatters: formatting methods per attribute, defaults to []</span>
<span class="sd">        :type formatters: list</span>
<span class="sd">        :raises Exception: All items in attributes must exist in the coordinates dataframe</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There is no column &quot;</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1">&quot; in this atoms dataframe&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">formatters</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">attributes</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">attributes</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.read_atomset_attributes">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.read_atomset_attributes">[docs]</a>
    <span class="k">def</span> <span class="nf">read_atomset_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">attributes</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads atomic attributes from input file</span>

<span class="sd">        :param filename: name of file</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :param attributes: list of attributes to take, defaults to [] (take all)</span>
<span class="sd">        :type attributes: list, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;Error: </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1"> not found&#39;</span>
        <span class="c1"># if no particular attributes are asked for, read them all in</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">assert</span> <span class="s1">&#39;globalIdx&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1"> does not have a </span><span class="se">\&#39;</span><span class="s1">globalIdx</span><span class="se">\&#39;</span><span class="s1"> column&#39;</span>
            <span class="n">attributes_read</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">attributes_read</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">attributes</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">attributes_read</span><span class="o">=</span><span class="n">attributes</span>
            <span class="c1"># logger.debug(f&#39;Read from {filename}\n{df.head().to_string()}&#39;)</span>
        <span class="c1"># logger.debug(f&#39;Merge:\n{self.A.head().to_string()}\nand\n{df.head().to_string()}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span><span class="n">on</span><span class="o">=</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;Result:\n{self.A.head().to_string()}&#39;)</span>
        <span class="k">return</span> <span class="n">attributes_read</span></div>


<div class="viewcode-block" id="Coordinates.set_atomset_attribute">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.set_atomset_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">set_atomset_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">srs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_atomset_attribute sets attribute of atoms to srs</span>

<span class="sd">        :param attribute: name of attribute</span>
<span class="sd">        :type attribute: str</span>
<span class="sd">        :param srs: scalar or list-like attribute values in same ordering as self.A</span>
<span class="sd">        :type srs: scalar or list-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">attribute</span><span class="p">]</span><span class="o">=</span><span class="n">srs</span></div>


<div class="viewcode-block" id="Coordinates.atomcount">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.atomcount">[docs]</a>
    <span class="k">def</span> <span class="nf">atomcount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;atomcount returns the number of atoms in the Coordinates object</span>

<span class="sd">        :return: number of atoms</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span></div>


<div class="viewcode-block" id="Coordinates.decrement_z">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.decrement_z">[docs]</a>
    <span class="k">def</span> <span class="nf">decrement_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;decrement_z decrements value of z attributes of all atoms found in pairs</span>

<span class="sd">        :param pairs: list of atom index pairs, interpreted as new bonds that just formed</span>
<span class="sd">        :type pairs: list of 2-tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="n">b</span>
            <span class="c1"># ain=self.get_atom_attribute(&#39;atomName&#39;,{&#39;globalIdx&#39;:ai})</span>
            <span class="c1"># ajn=self.get_atom_attribute(&#39;atomName&#39;,{&#39;globalIdx&#39;:aj})</span>
            <span class="n">iz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">ai</span><span class="p">})</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">assert</span> <span class="n">iz</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: decrementing z of atom </span><span class="si">{</span><span class="n">ai</span><span class="si">}</span><span class="s1"> gives erroneous z </span><span class="si">{</span><span class="n">iz</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">jz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aj</span><span class="p">})</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">assert</span> <span class="n">jz</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: decrementing z of atom </span><span class="si">{</span><span class="n">aj</span><span class="si">}</span><span class="s1"> gives erroneous z </span><span class="si">{</span><span class="n">jz</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="c1"># logger.debug(f&#39;Setting z of {ain}-{ai} to {iz}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;Setting z of {ajn}-{aj} to {jz}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_atom_attribute</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="n">iz</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">ai</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_atom_attribute</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="n">jz</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aj</span><span class="p">})</span>
            <span class="n">inr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">ai</span><span class="p">})</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">jnr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aj</span><span class="p">})</span><span class="o">+</span><span class="mi">1</span>
            <span class="c1"># logger.debug(f&#39;Setting z of {ain}-{ai} to {iz}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;Setting z of {ajn}-{aj} to {jz}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_atom_attribute</span><span class="p">(</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,</span><span class="n">inr</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">ai</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_atom_attribute</span><span class="p">(</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,</span><span class="n">jnr</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aj</span><span class="p">})</span></div>

            
<div class="viewcode-block" id="Coordinates.show_z_report">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.show_z_report">[docs]</a>
    <span class="k">def</span> <span class="nf">show_z_report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;show_z_report generates a little text-based histogram displaying number of atoms with each value of z between 0 and 3; atoms are keyed by resname:atomname.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zhists</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">n</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">atomName</span>
            <span class="n">nn</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">resName</span>
            <span class="n">k</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nn</span><span class="si">}</span><span class="s1">:</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">z</span><span class="o">=</span><span class="n">r</span><span class="o">.</span><span class="n">z</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">zhists</span><span class="p">:</span>
                <span class="n">zhists</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">zhists</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">z</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">zhists</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">zhists</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)]):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z-hist for </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> atoms:&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s1">&gt;5d</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">zhists</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="si">:</span><span class="s1">&gt;6d</span><span class="si">}</span><span class="s1">): &#39;</span><span class="o">+</span><span class="s1">&#39;*&#39;</span><span class="o">*</span><span class="p">(</span><span class="n">zhists</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">//</span><span class="mi">10</span><span class="p">))</span></div>


<div class="viewcode-block" id="Coordinates.return_bond_lengths">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.return_bond_lengths">[docs]</a>
    <span class="k">def</span> <span class="nf">return_bond_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return_bond_lengths returns an ordered list of bond lengths computed based on bonds indicated by the parallel &#39;ai&#39; and &#39;aj&#39; columns of the parameter dataframe bdf</span>

<span class="sd">        :param bdf: a pandas dataframe with &#39;ai&#39; and &#39;aj&#39; columns of atom indices indicating bonds</span>
<span class="sd">        :type bdf: pd.DataFrame</span>
<span class="sd">        :return: list of atom distances</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lengths</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rij</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lengths</span></div>


<div class="viewcode-block" id="Coordinates.add_length_attribute">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.add_length_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">add_length_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;add_length_attribute computes bond lengths based on bonds indicated by the parallel &#39;ai&#39; and &#39;aj&#39; columns of the parameter dataframe bdf and stores result in a new column called attr_name</span>

<span class="sd">        :param bdf: a pandas dataframe with &#39;ai&#39; and &#39;aj&#39; columns of atom indices indicating bonds</span>
<span class="sd">        :type bdf: pd.DataFrame</span>
<span class="sd">        :param attr_name: name of length attribute column, defaults to &#39;length&#39;</span>
<span class="sd">        :type attr_name: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lengths</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rij</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">))</span>
        <span class="n">bdf</span><span class="p">[</span><span class="n">attr_name</span><span class="p">]</span><span class="o">=</span><span class="n">lengths</span></div>


<div class="viewcode-block" id="Coordinates.minimum_distance">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.minimum_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">minimum_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">self_excludes</span><span class="o">=</span><span class="p">[],</span><span class="n">other_excludes</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;minimum_distance Computes and returns distance of closest approach between two sets of atoms</span>

<span class="sd">        :param other: other Coordinates instance</span>
<span class="sd">        :type other: Coordinates</span>
<span class="sd">        :param self_excludes: list of atom indexes in self to NOT consider, defaults to []</span>
<span class="sd">        :type self_excludes: list, optional</span>
<span class="sd">        :param other_excludes: list of atom indexes in other to NOT consider, defaults to []</span>
<span class="sd">        :type other_excludes: list, optional</span>
<span class="sd">        :return: distance of closest approach: i.e., the distance between the two atoms, one from self and one from other, that are closest together</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">self_excludes</span><span class="p">)][[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="n">op</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="o">~</span><span class="n">other</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">other_excludes</span><span class="p">)][[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="n">minD</span><span class="o">=</span><span class="mf">1.e9</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">srow</span> <span class="ow">in</span> <span class="n">sp</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">ri</span><span class="o">=</span><span class="n">srow</span><span class="o">.</span><span class="n">values</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">orow</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="n">rj</span><span class="o">=</span><span class="n">orow</span><span class="o">.</span><span class="n">values</span>
                <span class="n">rij</span><span class="o">=</span><span class="n">ri</span><span class="o">-</span><span class="n">rj</span>
                <span class="n">D</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rij</span><span class="p">,</span><span class="n">rij</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">D</span><span class="o">&lt;</span><span class="n">minD</span><span class="p">:</span>
                    <span class="n">minD</span><span class="o">=</span><span class="n">D</span>
        <span class="k">return</span> <span class="n">minD</span></div>

    
<div class="viewcode-block" id="Coordinates.homog_trans">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.homog_trans">[docs]</a>
    <span class="k">def</span> <span class="nf">homog_trans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">M</span><span class="p">:</span><span class="n">Matrix4</span><span class="p">,</span><span class="n">indices</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;applies homogeneous transformation matrix M [4x4] to coordinates</span>

<span class="sd">        :param M: homogeneous transformation matrix</span>
<span class="sd">        :type M: Matrix4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">srow</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">srow</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
                <span class="n">ri</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">srow</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;posX&#39;</span><span class="p">:</span><span class="s1">&#39;posZ&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.rotate">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.rotate">[docs]</a>
    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">R</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;rotate Rotates all coordinate vectors by rotation matrix R</span>

<span class="sd">        :param R: rotation matrix (3x3)</span>
<span class="sd">        :type R: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="o">=</span><span class="n">Matrix4</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">homog_trans</span><span class="p">(</span><span class="n">M</span><span class="p">)</span></div>

    <span class="c1">#     sp=self.A[[&#39;posX&#39;,&#39;posY&#39;,&#39;posZ&#39;]]</span>
    <span class="c1">#     for i,srow in sp.iterrows():</span>
    <span class="c1">#         ri=srow.values</span>
    <span class="c1">#         newri=np.matmul(R,ri)</span>
    <span class="c1">#         self.A.loc[i,&#39;posX&#39;:&#39;posZ&#39;]=newri</span>

<div class="viewcode-block" id="Coordinates.translate">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.translate">[docs]</a>
    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;translate Translates all coordinate vectors by displacement vector L</span>

<span class="sd">        :param L: displacement vector (nm)</span>
<span class="sd">        :type L: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">M</span><span class="o">=</span><span class="n">Matrix4</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">homog_trans</span><span class="p">(</span><span class="n">M</span><span class="p">)</span></div>

    <span class="c1">#     sp=self.A[[&#39;posX&#39;,&#39;posY&#39;,&#39;posZ&#39;]]</span>
    <span class="c1">#     for i,srow in sp.iterrows():</span>
    <span class="c1">#         self.A.loc[i,&#39;posX&#39;:&#39;posZ&#39;]=srow.values+L</span>

<div class="viewcode-block" id="Coordinates.maxspan">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.maxspan">[docs]</a>
    <span class="k">def</span> <span class="nf">maxspan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns dimensions of orthorhombic convex hull enclosing Coordinates</span>

<span class="sd">        :return: array of x-span, y-span, z-span</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">posX</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">posX</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">posY</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">posY</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">posZ</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">sp</span><span class="o">.</span><span class="n">posZ</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.minmax">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.minmax">[docs]</a>
    <span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;minmax returns the coordinates of the atoms at the lower-leftmost and upper-rightmost positions in the constellation of points in the atoms dataframe</span>

<span class="sd">        :return: tuple of two points, lower-leftmost and upper-rightmost, respectively</span>
<span class="sd">        :rtype: tuple(np.ndarray(3,float),np.ndarray(3,float))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">posX</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">sp</span><span class="o">.</span><span class="n">posY</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">sp</span><span class="o">.</span><span class="n">posZ</span><span class="o">.</span><span class="n">min</span><span class="p">()]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sp</span><span class="o">.</span><span class="n">posX</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">sp</span><span class="o">.</span><span class="n">posY</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">sp</span><span class="o">.</span><span class="n">posZ</span><span class="o">.</span><span class="n">max</span><span class="p">()])</span></div>


<div class="viewcode-block" id="Coordinates.checkbox">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.checkbox">[docs]</a>
    <span class="k">def</span> <span class="nf">checkbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;checkbox checks that the entire constellation of points in the atoms dataframe fits within the designated box for this Configuration object</span>

<span class="sd">        :return: True,True if both lower-leftmost and upper-rightmost points are within the box</span>
<span class="sd">        :rtype: tuple(bool,bool)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mm</span><span class="p">,</span><span class="n">MM</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">minmax</span><span class="p">()</span>
        <span class="n">bb</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mm</span><span class="o">&lt;</span><span class="n">bb</span><span class="p">,</span><span class="n">MM</span><span class="o">&gt;</span><span class="n">bb</span></div>


<div class="viewcode-block" id="Coordinates.get_idx">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.get_idx">[docs]</a>
    <span class="k">def</span> <span class="nf">get_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_idx returns the global atom index of the atom in the atoms dataframe which has the attribute:value pairs indicated in the parameter attributes</span>

<span class="sd">        :param attributes: dictionary of attribute:value pairs that identify the atom</span>
<span class="sd">        :type attributes: dict</span>
<span class="sd">        :return: global atom index</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="n">get_row_attribute</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">,</span><span class="n">attributes</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Coordinates.get_R">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.get_R">[docs]</a>
    <span class="k">def</span> <span class="nf">get_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_R return the cartesian position of atom with global index idx</span>

<span class="sd">        :param idx: global index of atom</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :return: its cartesian position</span>
<span class="sd">        :rtype: numpy.ndarray(3,float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">assert</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;posX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtypes</span><span class="o">==</span><span class="nb">float</span>
        <span class="k">assert</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;posY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtypes</span><span class="o">==</span><span class="nb">float</span>
        <span class="k">assert</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;posZ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtypes</span><span class="o">==</span><span class="nb">float</span>
        <span class="n">res</span><span class="o">=</span><span class="n">get_row_attribute</span><span class="p">(</span><span class="n">df</span><span class="p">,[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">],{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">idx</span><span class="p">})</span>
        <span class="c1"># logger.debug(f&#39;get_R result from get_row_attribute is {res} with type {type(res)} dtype {res.dtype}&#39;)</span>
        <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;...and after to_numpy(), it is {res} type {type(res)} dtype {res.dtype}&#39;)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    
<div class="viewcode-block" id="Coordinates.get_atom_attribute">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.get_atom_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atom_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_atom_attribute return values of attributes listed in name from atoms specified by attribute:value pairs in attributes</span>

<span class="sd">        :param name: list of attributes whose values are to be returned</span>
<span class="sd">        :type name: list</span>
<span class="sd">        :param attributes: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attributes: dict</span>
<span class="sd">        :return: scalar or list of one or more return attribute values</span>
<span class="sd">        :rtype: list if name is a list; scalar otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> not found in attributes</span><span class="se">\n</span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">get_row_attribute</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">attributes</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Coordinates.spew_atom">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.spew_atom">[docs]</a>
    <span class="k">def</span> <span class="nf">spew_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;spew_atom outputs all attributes of atom identified by the attributes dict</span>

<span class="sd">        :param attributes: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attributes: dict  </span>
<span class="sd">        :return: stringified dataframe</span>
<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="n">get_row_as_string</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">attributes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.get_atoms_w_attribute">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.get_atoms_w_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atoms_w_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_atoms_w_attribute returns all rows of atoms dataframe and columns named in names of atoms identified by the attributes dict</span>

<span class="sd">        :param name: list of attributes to be in the rows that are returned</span>
<span class="sd">        :type name: list</span>
<span class="sd">        :param attributes: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attributes: dict</span>
<span class="sd">        :return: a dataframe segment</span>
<span class="sd">        :rtype: pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="n">get_rows_w_attribute</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">attributes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.set_atom_attribute">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.set_atom_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">set_atom_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_atom_attribute set the attributes named in name to values named in values (names||values) for the set of atoms specified in the attributes dict</span>

<span class="sd">        :param name: list of names of attributes</span>
<span class="sd">        :type name: list</span>
<span class="sd">        :param value: list of values of attributes to be set</span>
<span class="sd">        :type value: list</span>
<span class="sd">        :param attributes: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attributes: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">set_row_attribute</span><span class="p">(</span><span class="n">df</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">attributes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.has_atom_attributes">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.has_atom_attributes">[docs]</a>
    <span class="k">def</span> <span class="nf">has_atom_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attributes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;has_atom_attributes returns True if all atoms in atoms dataframe have the attribute named in attributes</span>

<span class="sd">        :param attributes: list of attribute names to look for</span>
<span class="sd">        :type attributes:  list or list-like container</span>
<span class="sd">        :return: True if all atoms have the attributes</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">name</span> <span class="ow">in</span> <span class="n">df</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attributes</span><span class="p">])</span></div>


<div class="viewcode-block" id="Coordinates.find_sacrificial_H">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.find_sacrificial_H">[docs]</a>
    <span class="k">def</span> <span class="nf">find_sacrificial_H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairs</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">rename</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">explicit_sacH</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;find_sacrificial_H identifies all appropriate sacrificial hydrogen atoms determined by the bonds indicated in the pairs list of 3-tuples (ai,aj,order)</span>

<span class="sd">        :param pairs: list of atom pairs/order tuples</span>
<span class="sd">        :type pairs: tuple(int,int,int)</span>
<span class="sd">        :param T: the global Topology</span>
<span class="sd">        :type T: Topology</span>
<span class="sd">        :param rename: If true, renames any remaining H atoms so that it appears as though highest-order named H atoms are the ones sacrificed, defaults to False</span>
<span class="sd">        :type rename: bool, optional</span>
<span class="sd">        :param explicit_sacH: dictionary of pre-chosen sacrificial H atoms, keyed by pair index, defaults to {}</span>
<span class="sd">        :type explicit_sacH: dict, optional</span>
<span class="sd">        :return: list of global atom indices to delete</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_to_delete</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">explicit_sacH</span><span class="p">:</span>
                <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">,</span><span class="n">o</span><span class="o">=</span><span class="n">b</span>
                <span class="n">idx_to_delete</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sacH</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx_to_delete</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">explicit_sacH</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">idx_to_delete</span></div>


<div class="viewcode-block" id="Coordinates.sacH">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.sacH">[docs]</a>
    <span class="k">def</span> <span class="nf">sacH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">rename</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sacH Find the two H&#39;s, one bound to ai, the other to aj, that are closest to each other</span>

<span class="sd">        :param ai: index of one atom in bond</span>
<span class="sd">        :type ai: int</span>
<span class="sd">        :param aj: index of other atom in bond</span>
<span class="sd">        :type aj: int</span>
<span class="sd">        :param T: global topology</span>
<span class="sd">        :type T: Topology</span>
<span class="sd">        :param rename: whether to rename remaining H atoms bound to ai and aj so that it appears highest-sorted by name atoms are found, defaults to False</span>
<span class="sd">        :type rename: bool, optional</span>
<span class="sd">        :return: global indexes of two H atoms</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bondlist</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">bondlist</span>
        <span class="n">i_partners</span><span class="o">=</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
        <span class="n">j_partners</span><span class="o">=</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
        <span class="n">i_Hpartners</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i_partners</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">i_partners</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)}</span>
        <span class="n">j_Hpartners</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">j_partners</span><span class="p">,[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j_partners</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_Hpartners</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: atom </span><span class="si">{</span><span class="n">ai</span><span class="si">}</span><span class="s1"> does not have a deletable H atom!&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">j_Hpartners</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: atom </span><span class="si">{</span><span class="n">aj</span><span class="si">}</span><span class="s1"> does not have a deletable H atom!&#39;</span>
        <span class="n">minHH</span><span class="o">=</span><span class="p">(</span><span class="mf">1.e9</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ih</span> <span class="ow">in</span> <span class="n">i_Hpartners</span><span class="p">:</span>
            <span class="n">RiH</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">ih</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">jh</span> <span class="ow">in</span> <span class="n">j_Hpartners</span><span class="p">:</span>
                <span class="n">RjH</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span>
                <span class="n">RijH</span><span class="o">=</span><span class="n">RiH</span><span class="o">-</span><span class="n">RjH</span>
                <span class="n">rijh</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">RijH</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">RijH</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">rijh</span><span class="o">&lt;</span><span class="n">minHH</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">minHH</span><span class="o">=</span><span class="p">(</span><span class="n">rijh</span><span class="p">,</span><span class="n">ih</span><span class="p">,</span><span class="n">jh</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; rename remaining H atoms &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">rename</span><span class="p">:</span>
            <span class="c1"># reverse sort names of hydrogen ligands by their number</span>
            <span class="n">i_avails</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">i_Hpartners</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">j_avails</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">j_Hpartners</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="s1">&#39;0&#39;</span><span class="p">)))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;i_avails </span><span class="si">{</span><span class="n">i_avails</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;j_avails </span><span class="si">{</span><span class="n">j_avails</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># remove the globalIdx of the sacrificial H&#39;s from their atom&#39;s dictionaries of H-atoms</span>
            <span class="k">del</span> <span class="n">i_Hpartners</span><span class="p">[</span><span class="n">ih</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">j_Hpartners</span><span class="p">[</span><span class="n">jh</span><span class="p">]</span>
            <span class="n">Top</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
            <span class="n">Cor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="c1"># for all remaining H neighbor globalIdx of each atom, rename starting from lowest number</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">i_Hpartners</span><span class="p">:</span>
                <span class="n">i_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">=</span><span class="n">i_avails</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Top</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Top</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">i_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                <span class="n">Cor</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Cor</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">i_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;i: changed name of </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">i_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">j_Hpartners</span><span class="p">:</span>
                <span class="n">j_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">=</span><span class="n">j_avails</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Top</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Top</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">j_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                <span class="n">Cor</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Cor</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;atomName&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">j_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;j: changed name of </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">j_Hpartners</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># this makes sure that it always looks like the same atom was deleted</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ih</span><span class="p">,</span><span class="n">jh</span><span class="p">]</span> <span class="c1"># return the globalIdx&#39;s of the two sacrificial H&#39;s</span></div>


<div class="viewcode-block" id="Coordinates.delete_atoms">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.delete_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">delete_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="o">=</span><span class="p">[],</span><span class="n">reindex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;delete_atoms Deletes atoms whose global indices appear in the list idx.</span>
<span class="sd">        If parameter &#39;reindex&#39; is true, then the global indices </span>
<span class="sd">        are recalculated so that they are sequential starting at 1 with no</span>
<span class="sd">        gaps, and two new columns are added to self.DF: &#39;oldGlobalIdx&#39; contains the global index values before the deletion, and &#39;globalIdxShift&#39; is the change from the old to the new global index for each atom.</span>

<span class="sd">        :param idx: list of atom indexes to delete, defaults to []</span>
<span class="sd">        :type idx: list, optional</span>
<span class="sd">        :param reindex: reindex remaining atoms, defaults to True</span>
<span class="sd">        :type reindex: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(f&#39;Coordinates:delete_atoms {idx}&#39;)</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="o">.</span><span class="n">globalIdx</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">adf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
            <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span>
            <span class="n">oldGI</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">adf</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">mapper</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">oldGI</span><span class="p">,</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">])}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">-=</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; delete appropriate bonds &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span>
            <span class="n">indexes_to_drop</span><span class="o">=</span><span class="n">d</span><span class="p">[(</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">idx</span><span class="p">))]</span><span class="o">.</span><span class="n">index</span>
            <span class="n">indexes_to_keep</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes_to_drop</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">indexes_to_keep</span><span class="p">))</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reindex</span><span class="p">:</span>
                <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span>
                <span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
                <span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
                <span class="n">d</span><span class="o">.</span><span class="n">bondIdx</span><span class="o">=</span><span class="n">d</span><span class="o">.</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="s1">&#39;nBonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="p">[</span><span class="s1">&#39;nBonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bondlist</span><span class="o">=</span><span class="n">Bondlist</span><span class="o">.</span><span class="n">fromDataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.write_gro">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.write_gro">[docs]</a>
    <span class="k">def</span> <span class="nf">write_gro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">grotitle</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_gro Write coordinates and if present, velocities, to a Gromacs-format coordinate file</span>

<span class="sd">        :param filename: name of file to write</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">title</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">grotitle</span> <span class="k">else</span> <span class="n">grotitle</span>
        <span class="n">has_vel</span><span class="o">=</span><span class="s1">&#39;velX&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">title</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="si">:</span><span class="s1">&gt;5d</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># C-format: “%5i%5s%5s%5i%8.3f%8.3f%8.3f%8.4f%8.4f%8.4f”</span>
            <span class="c1"># Note that the gro atom number is not used; gromacs assigns atom indicies based</span>
            <span class="c1"># on counting input lines!  We will wrap the index so that it only has 5 digits.</span>
            <span class="n">atomformatters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;5d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&lt;5s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;5s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="o">%</span><span class="mi">10000</span><span class="si">:</span><span class="s1">5d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">8.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="p">[</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">8.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
            <span class="c1"># unfortunately, DataFrame.to_string() can&#39;t write fields with zero whitespace</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">has_vel</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">atomformatters</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gro_attributes</span><span class="p">]))])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">atomformatters</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gro_attributes</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]]))])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Writing Gromacs coordinates file but boxsize is not set.&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># output off-diagonals only if at least one of them is non-zero</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">10.5f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Coordinates.write_mol2">
<a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.coordinates.Coordinates.write_mol2">[docs]</a>
    <span class="k">def</span> <span class="nf">write_mol2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">bondsDF</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(),</span><span class="n">molname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">other_attributes</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_mol2 Write a mol2-format file from coordinates, and optionally, a bonds DataFrame</span>
<span class="sd">            provided externally and passed in as &quot;bondsDF&quot; (typically this would be</span>
<span class="sd">            from a Topology instance).</span>

<span class="sd">        :param filename: name of file name to write</span>
<span class="sd">        :type filename: str, optional</span>
<span class="sd">        :param bondsDF: dataframe of bonds [&#39;ai&#39;,&#39;aj&#39;], defaults to pd.DataFrame()</span>
<span class="sd">        :type bondsDF: pandas.DataFrame, optional</span>
<span class="sd">        :param molname: name of molecule, defaults to &#39;&#39;</span>
<span class="sd">        :type molname: str, optional</span>
<span class="sd">        :param other_attributes: auxiliary dataframe of attributes, defaults to pd.DataFrame()</span>
<span class="sd">        :type other_attributes: pandas.DataFrame, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(f&#39;write_mol2 {filename}&#39;)</span>
        <span class="n">acopy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">bdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">bondsDF</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot write any bonds to MOL2 file </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bondsDF</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">bdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">bondsDF</span><span class="o">.</span><span class="n">empty</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">bdf</span><span class="o">=</span><span class="n">bondsDF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Coordinates.write_mol2 provided with both a bondsDF parameter and a mol2_bonds attribute&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Using the parameter&#39;</span><span class="p">)</span>
            <span class="n">bdf</span><span class="o">=</span><span class="n">bondsDF</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">other_attributes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span> <span class="c1">#self.mol2_atom_attributes:</span>
            <span class="c1"># logger.debug(f&#39;importing/overwriting other_attribute {i}...&#39;)</span>
            <span class="n">acopy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">other_attributes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># logger.debug(f&#39;Updated [ atoms ]:\n{acopy.to_string()}&#39;)</span>
        <span class="n">com</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geometric_center</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">atomformatters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;7d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&lt;8s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;9.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;9.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;9.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&lt;5s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;3d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&lt;7s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;9.4f</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">]</span>
            <span class="n">bondformatters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;6d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;5d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;5d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">:</span><span class="s1">&gt;4s</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">]</span>
            <span class="n">substructureformatters</span> <span class="o">=</span> <span class="p">[</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;6d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&lt;7s</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&gt;6d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s1">&lt;7s</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">]</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;MOLECULE</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">molname</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">molname</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">N</span><span class="o">=</span><span class="n">acopy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#self.N</span>
                <span class="c1"># Infer the residue names and resids from the atom records</span>
                <span class="n">rdf</span><span class="o">=</span><span class="n">acopy</span><span class="p">[[</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;resName&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
                <span class="n">rdf</span><span class="p">[</span><span class="s1">&#39;rootatom&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">rdf</span><span class="p">)</span>
                <span class="n">rdf</span><span class="p">[</span><span class="s1">&#39;residue&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;RESIDUE&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">rdf</span><span class="p">)</span>
                <span class="n">nBonds</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nSubs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rdf</span><span class="p">)</span>
                <span class="n">nFeatures</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nFeatures&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">nSets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nSets&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:&gt;6d}{:&gt;6d}{:&gt;3d}{:&gt;3d}{:&gt;3d}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">nBonds</span><span class="p">,</span><span class="n">nSubs</span><span class="p">,</span> <span class="n">nFeatures</span><span class="p">,</span><span class="n">nSets</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mol2type&#39;</span><span class="p">,</span><span class="s1">&#39;SMALL&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mol2chargetype&#39;</span><span class="p">,</span><span class="s1">&#39;GASTEIGER&#39;</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;ATOM</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="c1"># remember to convert to Angstroms</span>
                <span class="n">pos</span><span class="o">=</span><span class="p">(</span><span class="n">acopy</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">-</span><span class="n">com</span><span class="p">)</span><span class="o">*</span><span class="mf">10.0</span>
                <span class="n">acopy</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">=</span><span class="n">pos</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">acopy</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_atom_attributes</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">formatters</span><span class="o">=</span><span class="n">atomformatters</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;BOND</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">bondsDF</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mol2 bonds from outside&#39;</span><span class="p">)</span>
                    <span class="n">bdf</span><span class="o">=</span><span class="n">bondsDF</span><span class="p">[[</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">,</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;order&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;bondIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">bdf</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bond_attributes</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">formatters</span><span class="o">=</span><span class="n">bondformatters</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;write_mol2 (</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">): Mol2 bonds from mol2_bonds attribute&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mol2_bond_attributes</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">formatters</span><span class="o">=</span><span class="n">bondformatters</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="w">                </span><span class="sd">&#39;&#39;&#39; write substructure section &#39;&#39;&#39;</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;@&lt;TRIPOS&gt;SUBSTRUCTURE</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">rdf</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">formatters</span><span class="o">=</span><span class="n">substructureformatters</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>
</div>

   
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">HTPolyNet</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation and Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-tutorials/index.html">Example Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/index.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTPolyNetPackage.html">HTPolyNet package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Cameron Abrams, Ming Huang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>