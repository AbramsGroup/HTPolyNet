<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HTPolyNet.topocoord &#8212; HTPolyNet 1.0.7.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=6073d2ab"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for HTPolyNet.topocoord</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">.. module:: topocoords</span>
<span class="sd">   :synopsis: Class for jointly handling Topology and Coordinate objects</span>

<span class="sd">.. moduleauthor: Cameron F. Abrams, &lt;cfa22@drexel.edu&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.coordinates</span> <span class="kn">import</span> <span class="n">Coordinates</span><span class="p">,</span> <span class="n">GRX_ATTRIBUTES</span><span class="p">,</span> <span class="n">GRX_GLOBALLY_UNIQUE</span><span class="p">,</span> <span class="n">GRX_UNSET_DEFAULTS</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.topology</span> <span class="kn">import</span> <span class="n">Topology</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.bondtemplate</span> <span class="kn">import</span> <span class="n">BondTemplate</span><span class="p">,</span><span class="n">ReactionBond</span>
<span class="kn">from</span> <span class="nn">HTPolyNet.gromacs</span> <span class="kn">import</span> <span class="n">grompp_and_mdrun</span><span class="p">,</span><span class="n">mdp_get</span><span class="p">,</span> <span class="n">mdp_modify</span><span class="p">,</span> <span class="n">gmx_energy_trace</span>
<span class="kn">import</span> <span class="nn">HTPolyNet.projectfilesystem</span> <span class="k">as</span> <span class="nn">pfs</span>

<span class="n">logger</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="BTRC"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.BTRC">[docs]</a><span class="k">class</span> <span class="nc">BTRC</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bond test return codes: bond tests are applied to those bond-candidates that are within search radius of each other</span>

<span class="sd">    :param Enum: inherits from Enum class</span>
<span class="sd">    :type Enum: class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">passed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">failed_pierce_ring</span> <span class="o">=</span> <span class="mi">1</span>        <span class="c1"># does this bond-candidate pierce a ring?</span>
    <span class="n">failed_short_circuit</span> <span class="o">=</span> <span class="mi">2</span>      <span class="c1"># does this bond-candidate result in short-circuit?</span>
    <span class="n">failed_bond_cycle</span> <span class="o">=</span> <span class="mi">3</span>         <span class="c1"># does this bond-candidate create a bondcycle on its own?</span>
    <span class="n">unset</span> <span class="o">=</span> <span class="mi">99</span></div>

<div class="viewcode-block" id="TopoCoord"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord">[docs]</a><span class="k">class</span> <span class="nc">TopoCoord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container for Topology and Coordinates, along with methods that</span>
<span class="sd">        use either or both of them</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">topfilename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">grofilename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">grxfilename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">mol2filename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">system_name</span><span class="o">=</span><span class="s1">&#39;htpolynet&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor method for TopoCoord.</span>

<span class="sd">        :param topfilename: name of Gromacs-format topology file (top), defaults to &#39;&#39;</span>
<span class="sd">        :type topfilename: str, optional</span>
<span class="sd">        :param grofilename: name of Gromacs-format coordinate file (gro), defaults to &#39;&#39;</span>
<span class="sd">        :type grofilename: str, optional</span>
<span class="sd">        :param mol2filename: name of SYBYL MOL2-format coordinate/bonds file, defaults to &#39;&#39;</span>
<span class="sd">        :type mol2filename: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wrap_coords</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wrap_coords&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># self.basefilenames={}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">grofilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;grx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">grxfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;mol2&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">mol2filename</span><span class="p">)</span>
        <span class="c1"># self.basefilenames[&#39;gro&#39;]=grofilename</span>
        <span class="c1"># self.basefilenames[&#39;top&#39;]=topfilename</span>
        <span class="c1"># self.basefilenames[&#39;grx&#39;]=grxfilename</span>
        <span class="c1"># self.basefilenames[&#39;mol2&#39;]=mol2filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="o">=</span><span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="n">grofilename</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="n">grofilename</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="n">wrap_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">=</span><span class="n">Coordinates</span><span class="p">()</span>  <span class="c1"># empty</span>
        <span class="k">if</span> <span class="n">topfilename</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_top</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">=</span><span class="n">Topology</span><span class="p">(</span><span class="n">system_name</span><span class="o">=</span><span class="n">system_name</span><span class="p">)</span> <span class="c1"># empty</span>
        <span class="k">if</span> <span class="n">mol2filename</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_mol2</span><span class="p">(</span><span class="n">mol2filename</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">grxfilename</span><span class="o">!=</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_gro_attributes</span><span class="p">(</span><span class="n">grxfilename</span><span class="p">)</span>

<div class="viewcode-block" id="TopoCoord.from_top_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.from_top_gro">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_top_gro</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">top</span><span class="p">,</span><span class="n">gro</span><span class="p">):</span>
        <span class="n">X</span><span class="o">=</span><span class="bp">cls</span><span class="p">(</span><span class="n">topfilename</span><span class="o">=</span><span class="n">top</span><span class="p">,</span><span class="n">grofilename</span><span class="o">=</span><span class="n">gro</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">X</span></div>

<div class="viewcode-block" id="TopoCoord.make_bonds"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.make_bonds">[docs]</a>    <span class="k">def</span> <span class="nf">make_bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairs</span><span class="p">,</span><span class="n">explicit_sacH</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds new bonds to the global topology</span>

<span class="sd">        :param pairs: list of pairs of atom global indices indicating each new bond</span>
<span class="sd">        :type pairs: list</span>
<span class="sd">        :param skip_H: list of pairs of atom global indices to skip when identifying</span>
<span class="sd">            the sacrificial H atoms; likely these are identified during molecule-building to</span>
<span class="sd">            optimize mutual orientation and placement of the two reactant molecules, defaults</span>
<span class="sd">            to []</span>
<span class="sd">        :type skip_H: list, optional</span>
<span class="sd">        :return: list of indexes of atoms that must now be deleted (sacrifical H&#39;s)</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idx_to_ignore</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">find_sacrificial_H</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span><span class="n">explicit_sacH</span><span class="o">=</span><span class="n">explicit_sacH</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;idx_to_ignore </span><span class="si">{</span><span class="n">idx_to_ignore</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">add_bonds</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chainlist_update</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;TopoCoord.make_bonds&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;add_bonds&#39;</span><span class="p">)</span>
        <span class="n">rename</span><span class="o">=</span><span class="kc">False</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">explicit_sacH</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">idx_to_delete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">find_sacrificial_H</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span><span class="n">explicit_sacH</span><span class="o">=</span><span class="n">explicit_sacH</span><span class="p">,</span><span class="n">rename</span><span class="o">=</span><span class="n">rename</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx_to_delete</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span>
        <span class="k">return</span> <span class="n">idx_to_delete</span></div>

<div class="viewcode-block" id="TopoCoord.add_restraints"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.add_restraints">[docs]</a>    <span class="k">def</span> <span class="nf">add_restraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairdf</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds bonds of type typ to the topology from the dataframe pairdf</span>

<span class="sd">        :param pairdf: ai, aj, initital-distance</span>
<span class="sd">        :type pairdf: pandas.DataFrame</span>
<span class="sd">        :param typ: bond type to add, defaults to 6 (non-topological restraint)</span>
<span class="sd">        :type typ: int, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">add_restraints</span><span class="p">(</span><span class="n">pairdf</span><span class="p">,</span><span class="n">typ</span><span class="o">=</span><span class="n">typ</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.delete_atoms"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.delete_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">delete_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atomlist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes atoms from both the Topology and Coordinates instances</span>

<span class="sd">        :param atomlist: list of global indexes of atoms to delete</span>
<span class="sd">        :type atomlist: list</span>
<span class="sd">        :return: old-to-new atom global index mapper dictionary resulting from reindexing</span>
<span class="sd">            remaining atoms to make sure global indexes are sequential</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(f&#39;delete_atoms: {atomlist}&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span>
        <span class="n">idx_mapper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">(</span><span class="n">atomlist</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx_mapper</span><span class="p">)</span><span class="o">==</span><span class="nb">dict</span>
        <span class="c1"># logger.debug(f&#39;idx_mapper: {idx_mapper}&#39;)</span>
        <span class="k">for</span> <span class="n">list_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">,</span><span class="s1">&#39;cycle&#39;</span><span class="p">]:</span>
            <span class="c1"># logger.debug(f&#39;remapping idxs in stale {list_name} lists: {self.idx_lists[list_name]}&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_idx_list_from_grx_attributes</span><span class="p">(</span><span class="n">list_name</span><span class="p">)</span>
            <span class="c1"># self.remap_idx_list(list_name,idx_mapper)</span>
        <span class="c1"># logger.debug(f&#39;finished&#39;)</span>
        <span class="k">return</span> <span class="n">idx_mapper</span></div>

<div class="viewcode-block" id="TopoCoord.count_H"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.count_H">[docs]</a>    <span class="k">def</span> <span class="nf">count_H</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;count_H Counts the number of hydrogens bound to atom with index idx; </span>
<span class="sd">        any atom whose name begins with the character &#39;H&#39; or &#39;h&#39; is assumed to be a hydrogen!</span>

<span class="sd">        :param idx: atom global index</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :return: number of H atoms bound to this atom</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aneigh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">aneighnames</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">aneigh</span><span class="p">]</span>
        <span class="n">anH</span><span class="o">=</span><span class="nb">sum</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">aneighnames</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">anH</span></div>

<div class="viewcode-block" id="TopoCoord.map_from_templates"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.map_from_templates">[docs]</a>    <span class="k">def</span> <span class="nf">map_from_templates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">,</span><span class="n">moldict</span><span class="p">,</span><span class="n">overcharge_threshhold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates angles, pairs, dihedrals, atom types, and charges, based on product</span>
<span class="sd">            templates associated with each bond in &#39;bdf&#39;</span>

<span class="sd">        :param bdf: dataframe, columns &#39;ai&#39;, &#39;aj&#39;, &#39;reactantName&#39;</span>
<span class="sd">        :type bdf: pandas.DataFrame</span>
<span class="sd">        :param moldict: dictionary of template Molecules keyed by name</span>
<span class="sd">        :type moldict: dict</span>
<span class="sd">        :raises Exception: nan found in any attribute of any new system angle</span>
<span class="sd">        :raises Exception: nan found in any attribute of any new system dihedral</span>
<span class="sd">        :raises Exception: nan found in any attribute of any new system pair</span>
<span class="sd">            that came along with a dihedral</span>
<span class="sd">        :raises Exception: nan found in ai attribute of any template pair</span>
<span class="sd">        :raises Exception: nan found in aj attribute of any template pair</span>
<span class="sd">        :raises Exception: nan found in any system pair</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="c1"># ij=self.Topology.D[&#39;bondtypes&#39;].set_index([&#39;i&#39;,&#39;j&#39;])</span>
        <span class="c1">#mb=self.D[&#39;mol2_bonds&#39;]</span>
        <span class="c1"># bmi=self.Topology.D[&#39;bonds&#39;].set_index([&#39;ai&#39;,&#39;aj&#39;]).sort_index().index</span>
        <span class="n">grodf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">grodf</span><span class="p">[</span><span class="s1">&#39;old_reactantName&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">grodf</span><span class="p">[</span><span class="s1">&#39;reactantName&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mapping </span><span class="si">{</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> bonds.&#39;</span><span class="p">)</span>
        <span class="n">premapping_total_charge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">total_charge</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Must compensate for an overcharge of </span><span class="si">{</span><span class="n">premapping_total_charge</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">mapped_inst_atoms</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mapping bond </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># for ln in b.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(f&#39;  -&gt; {ln}&#39;)</span>
            <span class="n">bb</span><span class="o">=</span><span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">]</span>
            <span class="n">order</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">order</span>
            <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">]</span>
            <span class="n">resnames</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">resnames</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">resids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">]</span>
            <span class="c1"># this is the product name of the reaction used to identify this bond</span>
            <span class="n">product_name</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">reactantName</span>
            <span class="k">if</span> <span class="n">product_name</span> <span class="ow">in</span> <span class="n">moldict</span><span class="p">:</span>
                <span class="n">P</span><span class="o">=</span><span class="n">moldict</span><span class="p">[</span><span class="n">product_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">P</span><span class="o">.</span><span class="n">is_reactant</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">P</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is a reactant; updating </span><span class="se">\&quot;</span><span class="s1">reactantName</span><span class="se">\&quot;</span><span class="s1"> attributes of </span><span class="si">{</span><span class="n">bb</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="c1"># if the product of this reaction is also a reactant in a cure reaction, we should</span>
                    <span class="c1"># change the reactantName attribute of the two atoms to match this so either of</span>
                    <span class="c1"># these atoms can be found in a later bond search</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bb</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;reactantName&#39;</span><span class="p">,</span><span class="n">product_name</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">P</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is not a reactant; no update of </span><span class="se">\&quot;</span><span class="s1">reactantName</span><span class="se">\&quot;</span><span class="s1"> attributes&#39;</span><span class="p">)</span>
            <span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_resnames</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">bystander_atomnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bystanders</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
            <span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_resnames</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">,</span><span class="n">oneaway_atomnames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_oneaways</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
            <span class="n">intraresidue</span><span class="o">=</span><span class="n">resids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">resids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">BT</span><span class="o">=</span><span class="n">BondTemplate</span><span class="p">(</span><span class="n">names</span><span class="p">,</span><span class="n">resnames</span><span class="p">,</span><span class="n">intraresidue</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">bystander_resnames</span><span class="p">,</span><span class="n">bystander_atomnames</span><span class="p">,</span><span class="n">oneaway_resnames</span><span class="p">,</span><span class="n">oneaway_atomnames</span><span class="p">)</span>
            <span class="n">RB</span><span class="o">=</span><span class="n">ReactionBond</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span><span class="n">resids</span><span class="p">,</span><span class="n">order</span><span class="p">,</span><span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;apparent bond template </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;apparent bond instance </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">RB</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">T</span><span class="p">,</span><span class="n">rb</span><span class="p">,</span><span class="n">reverse_bond</span><span class="o">=</span><span class="n">find_template</span><span class="p">(</span><span class="n">BT</span><span class="p">,</span><span class="n">moldict</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reverse_bond</span><span class="p">:</span> <span class="n">RB</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">temp_i_idx</span><span class="p">,</span><span class="n">temp_j_idx</span><span class="o">=</span><span class="n">rb</span><span class="o">.</span><span class="n">idx</span>
            <span class="n">d</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
            <span class="c1"># copy all bond records matching these two bonds; should be only one!!</span>
            <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">[((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">temp_i_idx</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">temp_j_idx</span><span class="p">))</span><span class="o">|</span>
                <span class="p">((</span><span class="n">d</span><span class="o">.</span><span class="n">ai</span><span class="o">==</span><span class="n">temp_j_idx</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">aj</span><span class="o">==</span><span class="n">temp_i_idx</span><span class="p">))]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Using </span><span class="si">{</span><span class="n">T</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> is sent inst-bond </span><span class="si">{</span><span class="n">i_idx</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j_idx</span><span class="si">}</span><span class="s1"> which is claimed to map to </span><span class="si">{</span><span class="n">temp_i_idx</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">temp_j_idx</span><span class="si">}</span><span class="s1">, but no such unique bond is found:</span><span class="se">\n</span><span class="si">{</span><span class="n">T</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39; check passed &#39;&#39;&#39;</span>
            <span class="n">temp_angles</span><span class="p">,</span><span class="n">temp_dihedrals</span><span class="p">,</span><span class="n">temp_pairs</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">get_angles_dihedrals</span><span class="p">((</span><span class="n">temp_i_idx</span><span class="p">,</span><span class="n">temp_j_idx</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mapping </span><span class="si">{</span><span class="n">temp_angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> angles, </span><span class="si">{</span><span class="n">temp_dihedrals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> dihedrals, and </span><span class="si">{</span><span class="n">temp_pairs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> pairs from template </span><span class="si">{</span><span class="n">T</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># determine the set of unique atoms in template that must be mapped to instance -- it is all</span>
            <span class="c1"># atoms involved in these bonded interactions</span>
            <span class="n">uniq_temp_idx</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="p">[</span><span class="n">temp_angles</span><span class="p">,</span><span class="n">temp_dihedrals</span><span class="p">,</span><span class="n">temp_pairs</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">df</span><span class="p">:</span>
                        <span class="n">uniq_temp_idx</span><span class="o">=</span><span class="n">uniq_temp_idx</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Template atom indexes that must be mapped: </span><span class="si">{</span><span class="n">uniq_temp_idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># get the bidirectional instance&lt;-&gt;template mapping dictionaries</span>
            <span class="n">inst2temp</span><span class="p">,</span><span class="n">temp2inst</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">idx_mappers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">RB</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span><span class="n">RB</span><span class="o">.</span><span class="n">bystander_resids</span><span class="p">,</span><span class="n">RB</span><span class="o">.</span><span class="n">oneaway_resids</span><span class="p">,</span><span class="n">uniq_temp_idx</span><span class="p">)</span>
            <span class="c1"># some hard checks on compatibility of the dicts</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inst2temp</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">inst2temp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">temp2inst</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">temp2inst</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">check</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">inst2temp</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">check</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: bidirectional dicts are incompatible; bug</span><span class="se">\n</span><span class="si">{</span><span class="n">inst2temp</span><span class="si">}</span><span class="se">\b</span><span class="si">{</span><span class="n">temp2inst</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="c1"># logger.debug(f&#39;inst2temp {inst2temp}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;temp2inst {temp2inst}&#39;)</span>
            <span class="n">i_idx</span><span class="p">,</span><span class="n">j_idx</span><span class="o">=</span><span class="n">bb</span>
            <span class="n">_temp_i_idx</span><span class="p">,</span><span class="n">_temp_j_idx</span><span class="o">=</span><span class="n">inst2temp</span><span class="p">[</span><span class="n">i_idx</span><span class="p">],</span><span class="n">inst2temp</span><span class="p">[</span><span class="n">j_idx</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">temp_i_idx</span><span class="o">==</span><span class="n">_temp_i_idx</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;mapping mismatch -- bug&#39;</span>
            <span class="k">assert</span> <span class="n">temp_j_idx</span><span class="o">==</span><span class="n">_temp_j_idx</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;mapping mismatch -- bug&#39;</span>

            <span class="n">need_new_bond_parameters</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">total_dcharge</span><span class="o">=</span><span class="mf">0.0</span>
            <span class="n">temp_atdf</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">temp_atom</span><span class="p">,</span><span class="n">inst_atom</span> <span class="ow">in</span> <span class="n">temp2inst</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="n">inst_atom</span> <span class="ow">in</span> <span class="n">atdf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: mapped atom </span><span class="si">{</span><span class="n">inst_atom</span><span class="si">}</span><span class="s1"> not found in [ atoms ]&#39;</span>
                <span class="n">inst_type</span><span class="p">,</span><span class="n">inst_charge</span><span class="p">,</span><span class="n">inst_name</span><span class="p">,</span><span class="n">inst_resn</span><span class="p">,</span><span class="n">inst_rnam</span><span class="o">=</span><span class="n">atdf</span><span class="p">[</span><span class="n">atdf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">inst_atom</span><span class="p">][[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span><span class="s1">&#39;charge&#39;</span><span class="p">,</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span><span class="s1">&#39;resnr&#39;</span><span class="p">,</span><span class="s1">&#39;residue&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">temp_type</span><span class="p">,</span><span class="n">temp_charge</span><span class="p">,</span><span class="n">temp_name</span><span class="p">,</span><span class="n">temp_resn</span><span class="p">,</span><span class="n">temp_rnam</span><span class="o">=</span><span class="n">temp_atdf</span><span class="p">[</span><span class="n">temp_atdf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">temp_atom</span><span class="p">][[</span><span class="s1">&#39;type&#39;</span><span class="p">,</span><span class="s1">&#39;charge&#39;</span><span class="p">,</span><span class="s1">&#39;atom&#39;</span><span class="p">,</span><span class="s1">&#39;resnr&#39;</span><span class="p">,</span><span class="s1">&#39;residue&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># logger.debug(f&#39;temp {temp_atom} {temp_name} {temp_rnam} {temp_resn} {temp_type} {temp_charge}&#39;)</span>
                <span class="c1"># logger.debug(f&#39;inst {inst_atom} {inst_name} {inst_rnam} {inst_resn} {inst_type} {inst_charge}&#39;)</span>
                <span class="k">if</span> <span class="n">inst_type</span><span class="o">!=</span><span class="n">temp_type</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;changing type of inst atom </span><span class="si">{</span><span class="n">inst_atom</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">inst_resn</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">inst_rnam</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">inst_name</span><span class="si">}</span><span class="s1">) from </span><span class="si">{</span><span class="n">inst_type</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">temp_type</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">atdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">atdf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">inst_atom</span><span class="p">,</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">temp_type</span>
                    <span class="k">if</span> <span class="n">inst_atom</span><span class="o">==</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span> <span class="ow">or</span> <span class="n">inst_atom</span><span class="o">==</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">:</span>
                        <span class="c1"># changed type of one or both of the bond atoms</span>
                        <span class="n">need_new_bond_parameters</span><span class="o">=</span><span class="kc">True</span>
                <span class="k">if</span> <span class="n">inst_charge</span><span class="o">!=</span><span class="n">temp_charge</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;charge </span><span class="si">{</span><span class="n">inst_atom</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">inst_resn</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">inst_rnam</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">inst_name</span><span class="si">}</span><span class="s1">) from </span><span class="si">{</span><span class="n">inst_charge</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">temp_charge</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">atdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">atdf</span><span class="p">[</span><span class="s1">&#39;nr&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">inst_atom</span><span class="p">,</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">temp_charge</span>
                    <span class="n">dcharge</span><span class="o">=</span><span class="n">temp_charge</span><span class="o">-</span><span class="n">inst_charge</span>
                    <span class="n">total_dcharge</span><span class="o">+=</span><span class="n">dcharge</span>
            <span class="n">mapped_inst_atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">temp2inst</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">need_new_bond_parameters</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">reset_override_from_type</span><span class="p">(</span><span class="s1">&#39;bonds&#39;</span><span class="p">,</span><span class="s1">&#39;bondtypes&#39;</span><span class="p">,</span><span class="n">inst_idx</span><span class="o">=</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">aj</span><span class="p">))</span>

            <span class="c1"># get all angle, dihedrals, and pairs from template that result from the existence of the specified bond</span>
            <span class="c1"># temp_angles,temp_dihedrals,temp_pairs=T.get_angles_dihedrals((temp_i_idx,temp_j_idx))</span>
            <span class="c1"># logger.debug(f&#39;Mapping {temp_angles.shape[0]} angles, {temp_dihedrals.shape[0]} dihedrals, and {temp_pairs.shape[0]} pairs from template {T.name}&#39;)</span>
            <span class="c1"># map from template atom indicies to system atom indicies in angles</span>
            <span class="c1"># logger.debug(f&#39;Template angles:&#39;)</span>
            <span class="c1"># for ln in temp_angles.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>
            <span class="n">inst_angles</span><span class="o">=</span><span class="n">temp_angles</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">inst_angles</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">temp_angles</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="n">inst_angles</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">temp_angles</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="n">inst_angles</span><span class="o">.</span><span class="n">ak</span><span class="o">=</span><span class="n">temp_angles</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;Mapped instance angles:&#39;)</span>
            <span class="c1"># for ln in inst_angles.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>
            <span class="c1"># add new angles to the system topology</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">inst_angles</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                            
            <span class="c1"># hard check for any nan&#39;s in any atom index attribute in any angle</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;angles&#39;</span><span class="p">]</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">]:</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in angles&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>

            <span class="c1"># logger.debug(f&#39;Template dihedrals:&#39;)</span>
            <span class="c1"># for ln in temp_dihedrals.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>
            <span class="c1"># map from template atom indicies to system atom indicies in dihedrals</span>
            <span class="n">inst_dihedrals</span><span class="o">=</span><span class="n">temp_dihedrals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">inst_dihedrals</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">temp_dihedrals</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="n">inst_dihedrals</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">temp_dihedrals</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="n">inst_dihedrals</span><span class="o">.</span><span class="n">ak</span><span class="o">=</span><span class="n">temp_dihedrals</span><span class="o">.</span><span class="n">ak</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="n">inst_dihedrals</span><span class="o">.</span><span class="n">al</span><span class="o">=</span><span class="n">temp_dihedrals</span><span class="o">.</span><span class="n">al</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;Mapped instance dihedrals:&#39;)</span>
            <span class="c1"># for ln in inst_dihedrals.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>
            <span class="n">d</span><span class="o">=</span><span class="n">inst_dihedrals</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">False</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">]:</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s1"> NAN in dihedrals</span><span class="se">\n</span><span class="si">{</span><span class="n">inst_dihedrals</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>
            <span class="c1"># add new dihedrals to global topology</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">inst_dihedrals</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># hard check for no nans</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;dihedrals&#39;</span><span class="p">]</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">,</span><span class="s1">&#39;ak&#39;</span><span class="p">,</span><span class="s1">&#39;al&#39;</span><span class="p">]:</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in dihedrals&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">]:</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in pairs premapping&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>

            <span class="c1"># double-hard check to make sure pairs can be mapped</span>
            <span class="n">k</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">temp2inst</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">v</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">temp2inst</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">k</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;null in temp2inst keys&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;null in temp2inst values&#39;</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;temp_pairs:\n{temp_pairs.to_string()}&#39;)</span>
            <span class="n">isin</span><span class="o">=</span><span class="p">[</span><span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp2inst</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp_pairs</span><span class="o">.</span><span class="n">ai</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">isin</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isin</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">jj</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;atom ai </span><span class="si">{</span><span class="n">temp_pairs</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="si">}</span><span class="s1"> not in temp2inst&#39;</span><span class="p">)</span>
            <span class="n">isin</span><span class="o">=</span><span class="p">[</span><span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp2inst</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">temp_pairs</span><span class="o">.</span><span class="n">aj</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">isin</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">jj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">isin</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">jj</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;atom aj </span><span class="si">{</span><span class="n">temp_pairs</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="si">}</span><span class="s1"> not in temp2inst&#39;</span><span class="p">)</span>

            <span class="c1"># map all ai attributes of all template pairs to global ai</span>
            <span class="n">temp_pairs</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">temp_pairs</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="c1"># check AGAIN for nans (I am afraid of nans)</span>
            <span class="k">if</span> <span class="n">temp_pairs</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in pairs ai&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>
            <span class="c1"># map all aj attributes of all template pairs to global ai</span>
            <span class="n">temp_pairs</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">temp_pairs</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">temp2inst</span><span class="p">)</span>
            <span class="c1"># check YET AGAIN for nans (eek!)</span>
            <span class="k">if</span> <span class="n">temp_pairs</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in pairs aj&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>
            <span class="c1"># add these pairs to the topology</span>
            <span class="c1"># logger.debug(f&#39;Concatenating this pairs to global pairs&#39;)</span>
            <span class="c1"># for ln in temp_pairs.to_string().split(&#39;\n&#39;):</span>
            <span class="c1">#     logger.debug(ln)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">d</span><span class="p">,</span><span class="n">temp_pairs</span><span class="p">),</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
            <span class="c1"># check AGAIN for nans</span>
            <span class="n">check</span><span class="o">=</span><span class="kc">True</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">]:</span>
                <span class="n">check</span><span class="o">=</span><span class="n">check</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;NAN in pairs post mapping&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span>
            <span class="c1"># return temp_pairs</span>
        <span class="n">mapped_inst_atoms</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mapped_inst_atoms</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;System overcharge after mapping: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">total_charge</span><span class="p">()</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_charges</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">mapped_inst_atoms</span><span class="p">,</span><span class="n">overcharge_threshhold</span><span class="o">=</span><span class="n">overcharge_threshhold</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;overcharge magnitude exceeds </span><span class="si">{</span><span class="n">overcharge_threshhold</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.enumerate_1_4_pairs"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.enumerate_1_4_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">enumerate_1_4_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">at_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;enumerate_1_4_pairs enumerate all 1-4 pair interactions resulting from new bonds in at_idx</span>

<span class="sd">        :param at_idx: list of 2-tuples, each containing global indices of atoms that bond to each other</span>
<span class="sd">        :type at_idx: list</span>
<span class="sd">        :return: dataframe of all pairs</span>
<span class="sd">        :rtype: pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
        <span class="c1"># each of these bonds results in 1-4 pair interactions</span>
        <span class="n">bl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span>
        <span class="n">pai</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">paj</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pri</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">prj</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">prsource</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">at_idx</span><span class="p">:</span>
            <span class="c1"># determine all nj--nk pairs from j-k bond, where nj are neighbors of j not including k, and nk are neighbors of k not including j</span>
            <span class="c1"># and all nnj--k pairs from all nj-j bonds, where nnj are next-nearest neighbors of j excluding j</span>
            <span class="c1"># and all j--nnk pairs from all k-nk bonds, where nnk are next-nearest neighbors of k excluding k</span>
            <span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">p</span>
            <span class="n">nj</span><span class="o">=</span><span class="n">bl</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">nj</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">nnj</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nj</span><span class="p">:</span>
                <span class="n">t</span><span class="o">=</span><span class="n">bl</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">nnj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">nk</span><span class="o">=</span><span class="n">bl</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">nk</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">nnk</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nk</span><span class="p">:</span>
                <span class="n">t</span><span class="o">=</span><span class="n">bl</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">nn</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">nnk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">nj</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">nk</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">nnj</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">nnk</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">nj</span><span class="p">,</span><span class="n">nk</span><span class="p">):</span>
                <span class="n">jj</span><span class="p">,</span><span class="n">kk</span><span class="o">=</span><span class="n">pp</span>
                <span class="n">pai</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>
                <span class="n">paj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kk</span><span class="p">)</span>
                <span class="n">pri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">prj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">prsource</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nnj</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">:</span>
                        <span class="n">pai</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
                        <span class="n">paj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">pri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">prj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">prsource</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;l&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">nnk</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">:</span>
                        <span class="n">pai</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">paj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
                        <span class="n">pri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="n">prj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">prsource</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="n">pi_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;ai&#39;</span><span class="p">:</span><span class="n">pai</span><span class="p">,</span><span class="s1">&#39;aj&#39;</span><span class="p">:</span><span class="n">paj</span><span class="p">,</span><span class="s1">&#39;source&#39;</span><span class="p">:</span><span class="n">prsource</span><span class="p">,</span><span class="s1">&#39;bi&#39;</span><span class="p">:</span><span class="n">pri</span><span class="p">,</span><span class="s1">&#39;bj&#39;</span><span class="p">:</span><span class="n">prj</span><span class="p">})</span>
        <span class="n">pi_df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pi_df</span></div>


<div class="viewcode-block" id="TopoCoord.update_topology_and_coordinates"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.update_topology_and_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">update_topology_and_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">,</span><span class="n">template_dict</span><span class="o">=</span><span class="p">{},</span><span class="n">write_mapper_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;update_topology_and_coordinates updates global topology and necessary atom attributes in the configuration to reflect formation of all bonds listed in `keepbonds`</span>

<span class="sd">        :param bdf: bonds dataframe, columns &#39;ai&#39;, &#39;aj&#39;, &#39;reactantName&#39;</span>
<span class="sd">        :type bdf: pandas.DataFrame</span>
<span class="sd">        :param template_dict: dictionary of molecule templates keyed on molecule name</span>
<span class="sd">        :type template_dict: dict</span>
<span class="sd">        :return: 3-tuple: new topology file name, new coordinate file name, list of bonds with atom indices updated to reflect any atom deletions</span>
<span class="sd">        :rtype: 3-tuple</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">explicit_sacH</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;explicit_sacH&#39;</span><span class="p">,{})</span>
        <span class="n">template_source</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;template_source&#39;</span><span class="p">,</span><span class="s1">&#39;internal&#39;</span><span class="p">)</span>
        <span class="n">overcharge_threshhold</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;overcharge_threshhold&#39;</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;begins.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;ai&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">==</span><span class="nb">int</span>
            <span class="k">assert</span> <span class="n">bdf</span><span class="p">[</span><span class="s1">&#39;aj&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">==</span><span class="nb">int</span>
            <span class="c1"># pull out just the atom index pairs (first element of each tuple)</span>
            <span class="n">at_idx</span><span class="o">=</span><span class="p">[(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ai</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">aj</span><span class="p">),</span><span class="n">x</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Making </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">at_idx</span><span class="p">)</span><span class="si">}</span><span class="s1"> bonds.&#39;</span><span class="p">)</span>
            <span class="n">idx_to_delete</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">make_bonds</span><span class="p">(</span><span class="n">at_idx</span><span class="p">,</span><span class="n">explicit_sacH</span><span class="o">=</span><span class="n">explicit_sacH</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deleting </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_to_delete</span><span class="p">)</span><span class="si">}</span><span class="s1"> atoms.&#39;</span><span class="p">)</span>
            <span class="n">idx_mapper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">delete_atoms</span><span class="p">(</span><span class="n">idx_to_delete</span><span class="p">)</span> <span class="c1"># will result in full reindexing</span>
            <span class="c1"># logger.debug(f&#39;null check&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;delete_atoms&#39;</span><span class="p">)</span>
            <span class="c1"># reindex all atoms in the list of bonds sent in, and write it out</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z-decrement, nreactions increment&#39;</span><span class="p">)</span>
            <span class="n">ri_bdf</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ri_bdf</span><span class="o">.</span><span class="n">ai</span><span class="o">=</span><span class="n">ri_bdf</span><span class="o">.</span><span class="n">ai</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">idx_mapper</span><span class="p">)</span>
            <span class="n">ri_bdf</span><span class="o">.</span><span class="n">aj</span><span class="o">=</span><span class="n">ri_bdf</span><span class="o">.</span><span class="n">aj</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">idx_mapper</span><span class="p">)</span>
            <span class="n">at_idx</span><span class="o">=</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">x</span><span class="o">.</span><span class="n">aj</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ri_bdf</span><span class="o">.</span><span class="n">itertuples</span><span class="p">()]</span>
            <span class="k">for</span> <span class="n">idx_pair</span> <span class="ow">in</span> <span class="n">at_idx</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx_pair</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">decrement_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">idx</span><span class="p">})</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">increment_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;nreactions&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">idx</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">template_source</span><span class="o">==</span><span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;calling map_from_templates&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">map_from_templates</span><span class="p">(</span><span class="n">ri_bdf</span><span class="p">,</span><span class="n">template_dict</span><span class="p">,</span><span class="n">overcharge_threshhold</span><span class="o">=</span><span class="n">overcharge_threshhold</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;1-4 pair update&#39;</span><span class="p">)</span>
            <span class="n">pi_df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">enumerate_1_4_pairs</span><span class="p">(</span><span class="n">at_idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">null_check</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;update_topology_and_coordinates&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">write_mapper_to</span><span class="p">:</span>
                <span class="n">tdf</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;old&#39;</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">idx_mapper</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span><span class="s1">&#39;new&#39;</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="n">idx_mapper</span><span class="o">.</span><span class="n">values</span><span class="p">())})</span>
                <span class="n">tdf</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">write_mapper_to</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;finished&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ri_bdf</span><span class="p">,</span><span class="n">pi_df</span></div>

<div class="viewcode-block" id="TopoCoord.read_top"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.read_top">[docs]</a>    <span class="k">def</span> <span class="nf">read_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">topfilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_top Creates a new Topology member by reading from a Gromacs-style top file.</span>
<span class="sd">            Just a wrapper for the read_gro method of Topology</span>

<span class="sd">        :param topfilename: name of topology file</span>
<span class="sd">        :type topfilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">=</span><span class="n">Topology</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.read_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.read_gro">[docs]</a>    <span class="k">def</span> <span class="nf">read_gro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grofilename</span><span class="p">,</span><span class="n">preserve_box</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_gro Creates a new Coordinates member by reading from a Gromacs-style coordinates</span>
<span class="sd">            file.  Just a wrapper for the read_gro method of Coordinates</span>

<span class="sd">        :param grofilename: name of gro file</span>
<span class="sd">        :type grofilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">grofilename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">preserve_box</span><span class="p">:</span>
            <span class="n">savebox</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">=</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="n">grofilename</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="n">wrap_coords</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">preserve_box</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">savebox</span></div>
        <span class="c1"># logger.debug(f&#39;box: {self.Coordinates.box}&#39;)</span>

<div class="viewcode-block" id="TopoCoord.read_mol2"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.read_mol2">[docs]</a>    <span class="k">def</span> <span class="nf">read_mol2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mol2filename</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_mol2 Creates a new Coordinates member by reading from a SYBYL-style MOL2 file.</span>
<span class="sd">            A wrapper for read_mol2 from Coordinates, but also sets the &#39;mol2_bonds&#39;</span>
<span class="sd">            dataframe in the Topology if the parameter ignore_bonds is False.  If</span>
<span class="sd">            the mol2_bonds dataframe is created, and the Topology already has a &#39;bonds&#39; dataframe, a consistency check is peformed.</span>

<span class="sd">        :param mol2filename: name of mol2 file</span>
<span class="sd">        :type mol2filename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ignore_bonds</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ignore_bonds&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">overwrite_coordinates</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;overwrite_coordinates&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;mol2&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">mol2filename</span><span class="p">)</span>
        <span class="n">temp_coords</span><span class="o">=</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">read_mol2</span><span class="p">(</span><span class="n">mol2filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="n">overwrite_coordinates</span><span class="p">:</span>
            <span class="n">save_box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">=</span><span class="n">temp_coords</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">save_box</span>
            <span class="n">temp_coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_bonds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">temp_coords</span><span class="o">.</span><span class="n">mol2_bonds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bond_source_check</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopoCoord.swap_atom_names"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.swap_atom_names">[docs]</a>    <span class="k">def</span> <span class="nf">swap_atom_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;swap_atom_names Swaps the names of the two atoms with global indicies ai and aj.  This is used when</span>
<span class="sd">        automatically selected which of several possible sacrificial H&#39;s will actually be</span>
<span class="sd">        selected.  Surviving H&#39;s are renamed so it always appears that the H with &quot;least</span>
<span class="sd">        important&quot; name (lowest order if sorted) is the sacrificial H.  Why do we do this?  It</span>
<span class="sd">        gives us perfect control of the names of the atoms that survive a bond.</span>

<span class="sd">        :param ai: global index of first atom</span>
<span class="sd">        :type ai: int</span>
<span class="sd">        :param aj: global index of second atom</span>
<span class="sd">        :type aj: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>
        <span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">l1</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;atom&#39;</span>
        <span class="n">l2</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">columns</span><span class="o">==</span><span class="s1">&#39;atomName&#39;</span>
        <span class="n">iname</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ai</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">jname</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">aj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># logger.debug(f&#39;Swapping names of atoms {ai}({iname}) and {aj}({jname})&#39;)</span>
        <span class="n">tmpNm</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ai</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ai</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">]</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">aj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">]</span>
        <span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">aj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l1</span><span class="p">]</span><span class="o">=</span><span class="n">tmpNm</span>
        <span class="n">C</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">ai</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l2</span><span class="p">]</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">aj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l2</span><span class="p">]</span>
        <span class="n">C</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">aj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l2</span><span class="p">]</span><span class="o">=</span><span class="n">tmpNm</span></div>

<div class="viewcode-block" id="TopoCoord.read_top_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.read_top_gro">[docs]</a>    <span class="k">def</span> <span class="nf">read_top_gro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">topfilename</span><span class="p">,</span><span class="n">grofilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;read_top_gro Wrapper for read_top and read_gro; generates new Topology and Coordinates members</span>

<span class="sd">        :param topfilename: name of topology file</span>
<span class="sd">        :type topfilename: str</span>
<span class="sd">        :param grofilename: name of coordinates file (Gromacs format)</span>
<span class="sd">        :type grofilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_top</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="n">grofilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.write_top"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.write_top">[docs]</a>    <span class="k">def</span> <span class="nf">write_top</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">topfilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_top Write a Gromacs-format topology file; this will only write an in-line version,</span>
<span class="sd">            no itp; wrapper for Topology.to_file()</span>

<span class="sd">        :param topfilename: name of file to write</span>
<span class="sd">        :type topfilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.write_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.write_gro">[docs]</a>    <span class="k">def</span> <span class="nf">write_gro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grofilename</span><span class="p">,</span><span class="n">grotitle</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_gro Write a Gromacs-format coordinate file; wrapper for Coordinates.write_gro()</span>

<span class="sd">        :param grofilename: name of file to write</span>
<span class="sd">        :type grofilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="n">grofilename</span><span class="p">,</span><span class="n">grotitle</span><span class="o">=</span><span class="n">grotitle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">grofilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.write_top_gro"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.write_top_gro">[docs]</a>    <span class="k">def</span> <span class="nf">write_top_gro</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">topfilename</span><span class="p">,</span><span class="n">grofilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_top_gro Writes both a Gromacs top file and Gromacs coordinate file</span>

<span class="sd">        :param topfilename: name of topology file to write</span>
<span class="sd">        :type topfilename: str</span>
<span class="sd">        :param grofilename: name of coordinate file to write</span>
<span class="sd">        :type grofilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_top</span><span class="p">(</span><span class="n">topfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="n">grofilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.return_bond_lengths"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.return_bond_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">return_bond_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return_bond_lengths Return the length of all bonds in list bonds</span>

<span class="sd">        :param bdf: bonds dataframe, &#39;ai&#39;,&#39;aj&#39;,&#39;reactantName&#39;</span>
<span class="sd">        :type bonds: pandas.DataFrame</span>
<span class="sd">        :return: list of lengths parallel to bonds</span>
<span class="sd">        :rtype: list of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">return_bond_lengths</span><span class="p">(</span><span class="n">bdf</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.add_length_attribute"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.add_length_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">add_length_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;add_length_attribute computes bond lengths based on bonds indicated by the parallel &#39;ai&#39; and &#39;aj&#39; columns of the parameter dataframe bdf and stores result in a new column called attr_name</span>

<span class="sd">        :param bdf: a pandas dataframe with &#39;ai&#39; and &#39;aj&#39; columns of atom indices indicating bonds</span>
<span class="sd">        :type bdf: pd.DataFrame</span>
<span class="sd">        :param attr_name: name of length attribute column, defaults to &#39;length&#39;</span>
<span class="sd">        :type attr_name: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">add_length_attribute</span><span class="p">(</span><span class="n">bdf</span><span class="p">,</span><span class="n">attr_name</span><span class="o">=</span><span class="n">attr_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.copy_bond_parameters"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.copy_bond_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">copy_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bonds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate and return a copy of a bonds dataframe that contains all bonds</span>
<span class="sd">           listed in bonds</span>

<span class="sd">        :param bonds: list of bonds, each a 2-tuple of global atom indices</span>
<span class="sd">        :type bonds: list</span>
<span class="sd">        :return: bonds dataframe</span>
<span class="sd">        :rtype: pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">copy_bond_parameters</span><span class="p">(</span><span class="n">bonds</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.remove_restraints"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.remove_restraints">[docs]</a>    <span class="k">def</span> <span class="nf">remove_restraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairsdf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all bonds represented in in pairdf.</span>
<span class="sd">        These are interpreted as non-topological</span>
<span class="sd">        restraints, so deleting these &#39;bonds&#39; does </span>
<span class="sd">        not influence angles or dihedrals</span>

<span class="sd">        :param pairdf: dataframe of pairs [&#39;ai&#39;,&#39;aj&#39;]</span>
<span class="sd">        :type pairdf: pandas DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">remove_restraints</span><span class="p">(</span><span class="n">pairsdf</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.attenuate_bond_parameters"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.attenuate_bond_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">attenuate_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bonds</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">minimum_distance</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">init_colname</span><span class="o">=</span><span class="s1">&#39;initial_distance&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alter the kb and b0 parameters for new crosslink bonds according to the values prior to</span>
<span class="sd">            relaxation (stored in lengths), their equilibrium values, and the ratio stage/max_stages.</span>
<span class="sd">            Let stage/max_stages be x, and 1/max_stages &lt;= x &lt;= 1.  The spring constant for each</span>
<span class="sd">            bond is multiplied by x and the distance is 1 xth of the way from its maximum value</span>
<span class="sd">            to its equilibrium value.</span>

<span class="sd">        :param bonds: bonds dataframe, &#39;ai&#39;, &#39;aj&#39;, &#39;initial_distance&#39;</span>
<span class="sd">        :type bonds: pandas.DataFrame</span>
<span class="sd">        :param stage: index of stage in the series of post-bond-formation relaxation</span>
<span class="sd">        :type stage: int</span>
<span class="sd">        :param max_stages: total number of relaxation stages for this iteration</span>
<span class="sd">        :type max_stages: int</span>
<span class="sd">        :param minimum_distance: minimum bondlegth allowed, overriding type-specific b0</span>
<span class="sd">        :type lengths: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">attenuate_bond_parameters</span><span class="p">(</span><span class="n">bonds</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">minimum_distance</span><span class="o">=</span><span class="n">minimum_distance</span><span class="p">,</span><span class="n">init_colname</span><span class="o">=</span><span class="n">init_colname</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.attenuate_pair_parameters"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.attenuate_pair_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">attenuate_pair_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pairdf</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">draglimit_nm</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alter the kb and b0 parameters for new pre-crosslink pairs according</span>
<span class="sd">            to the values prior to dragging (stored in pairdf[&#39;initial_distances&#39;]),</span>
<span class="sd">            the desired lower limit of interatomic distance &#39;draglimit_nm&#39;,</span>
<span class="sd">            and the ratio stage/max_stages.</span>

<span class="sd">        :param pairdf: pairs dataframe ([&#39;ai&#39;],[&#39;aj&#39;],[&#39;initial_distance&#39;])</span>
<span class="sd">        :type pairdf: pandas.DataFrame</span>
<span class="sd">        :param stage: index of stage in the series of pre-bond-formation dragging</span>
<span class="sd">        :type stage: int</span>
<span class="sd">        :param max_stages: total number of drag stages for this iteration</span>
<span class="sd">        :type max_stages: int</span>
<span class="sd">        :param draglimit_nm: lower limit of interatomic distance requested from drag</span>
<span class="sd">        :type draglimit_nm: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">attenuate_pair_parameters</span><span class="p">(</span><span class="n">pairdf</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">minimum_distance</span><span class="o">=</span><span class="n">draglimit_nm</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.copy_coords"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.copy_coords">[docs]</a>    <span class="k">def</span> <span class="nf">copy_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy coordinates and box size from other to self</span>

<span class="sd">        :param other: a TopoCoord instance</span>
<span class="sd">        :type other: TopoCoord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">copy_coords</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="TopoCoord.restore_bond_parameters"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.restore_bond_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">restore_bond_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">saved</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retores saved bond parameters in df saved by overwriting</span>

<span class="sd">        :param saved: [ bonds ] dataframe</span>
<span class="sd">        :type saved: pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">restore_bond_parameters</span><span class="p">(</span><span class="n">saved</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.set_grx_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.set_grx_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">set_grx_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attributes</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_grx_attributes override the global GRX_ATTRIBUTES</span>

<span class="sd">        :param attributes: new GRX attributes to use, defaults to []</span>
<span class="sd">        :type attributes: list, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="o">=</span><span class="n">GRX_ATTRIBUTES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="o">=</span><span class="n">attributes</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;grxattr set to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TopoCoord.write_gro_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.write_gro_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">write_gro_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attributes_list</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_gro_attributes Writes atomic attributes to a file</span>

<span class="sd">        :param attributes_list: list of attributes to write</span>
<span class="sd">        :type attributes_list: list</span>
<span class="sd">        :param grxfilename: name of output file</span>
<span class="sd">        :type grxfilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">write_atomset_attributes</span><span class="p">(</span><span class="n">attributes_list</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;grx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">grxfilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.write_grx_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.write_grx_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">write_grx_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_grx_attributes Writes GRX attributes to a file</span>

<span class="sd">        :param grxfilename: name of output file</span>
<span class="sd">        :type grxfilename: str</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">write_gro_attributes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.read_gro_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.read_gro_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">read_gro_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">grxfilename</span><span class="p">,</span><span class="n">attribute_list</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read attributes from file into self.Coordinates.A</span>

<span class="sd">        :param grxfilename: name of input file</span>
<span class="sd">        :type grxfilename: str</span>
<span class="sd">        :param attribute_list: list of attributes to take, defaults to [] (take all)</span>
<span class="sd">        :type attribute_list: list, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;grx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">grxfilename</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Reading </span><span class="si">{</span><span class="n">grxfilename</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">attributes_read</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">read_atomset_attributes</span><span class="p">(</span><span class="n">grxfilename</span><span class="p">,</span><span class="n">attributes</span><span class="o">=</span><span class="n">attribute_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;chain&#39;</span> <span class="ow">in</span> <span class="n">attributes_read</span> <span class="ow">and</span> <span class="s1">&#39;chain_idx&#39;</span> <span class="ow">in</span> <span class="n">attributes_read</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_idx_list_from_grx_attributes</span><span class="p">(</span><span class="s1">&#39;chain&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;cycle&#39;</span> <span class="ow">in</span> <span class="n">attributes_read</span> <span class="ow">and</span> <span class="s1">&#39;cycle_idx&#39;</span> <span class="ow">in</span> <span class="n">attributes_read</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_idx_list_from_grx_attributes</span><span class="p">(</span><span class="s1">&#39;cycle&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attributes_read</span><span class="o">!=</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="o">=</span><span class="n">attributes_read</span></div>

<div class="viewcode-block" id="TopoCoord.set_gro_attribute"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.set_gro_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">set_gro_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">srs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_gro_attribute sets attribute of atoms to srs (drillst through to Coordinates.set_atomset_attributes())</span>

<span class="sd">        :param attribute: name of attribute</span>
<span class="sd">        :type attribute: str</span>
<span class="sd">        :param srs: scalar or list-like attribute values in same ordering as self.A</span>
<span class="sd">        :type srs: scalar or list-like</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">set_atomset_attribute</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span><span class="n">srs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.set_gro_attribute_by_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.set_gro_attribute_by_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">att_name</span><span class="p">,</span><span class="n">att_value</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;set_atom_attribute set the attributes named in name to values named in values (names||values) for the set of atoms specified in the attributes dict</span>

<span class="sd">        :param name: list of names of attributes</span>
<span class="sd">        :type name: list</span>
<span class="sd">        :param value: list of values of attributes to be set</span>
<span class="sd">        :type value: list</span>
<span class="sd">        :param attributes: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attributes: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">set_atom_attribute</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span><span class="n">att_value</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.get_gro_attribute_by_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.get_gro_attribute_by_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">att_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_gro_attribute_by_attributes return values of attributes listed in name from atoms specified by attribute:value pairs in attribute_dict</span>

<span class="sd">        :param att_name: list of attributes whose values are to be returned</span>
<span class="sd">        :type att_name: list</span>
<span class="sd">        :param attribute_dict: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attribute_dict: dict</span>
<span class="sd">        :return: scalar or list of one or more return attribute values</span>
<span class="sd">        :rtype: list if name is a list; scalar otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">get_atom_attribute</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.increment_gro_attribute_by_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.increment_gro_attribute_by_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">increment_gro_attribute_by_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">att_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;increment_gro_attribute_by_attributes add one to attribute att_name of all atoms identified by attribute:value pairs in attribute_dict</span>

<span class="sd">        :param att_name: name of attribute to increment</span>
<span class="sd">        :type att_name: str</span>
<span class="sd">        :param attribute_dict: attribute:value pairs that specify atoms to which to apply this incrementation</span>
<span class="sd">        :type attribute_dict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span>
        <span class="n">val</span><span class="o">+=</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.decrement_gro_attribute_by_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.decrement_gro_attribute_by_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">decrement_gro_attribute_by_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">att_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;decrement_gro_attribute_by_attributes subtract one from attribute att_name of all atoms identified by attribute:value pairs in attribute_dict</span>

<span class="sd">        :param att_name: name of attribute to increment</span>
<span class="sd">        :type att_name: str</span>
<span class="sd">        :param attribute_dict: attribute:value pairs that specify atoms to which to apply this incrementation</span>
<span class="sd">        :type attribute_dict: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span>
        <span class="n">val</span><span class="o">-=</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="n">att_name</span><span class="p">,</span><span class="n">val</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.get_gro_attributelist_by_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.get_gro_attributelist_by_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">get_gro_attributelist_by_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute_list</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_atoms_w_attribute returns all rows of atoms dataframe and columns named in names of atoms identified by the attributes dict</span>

<span class="sd">        :param attribute_list: list of attributes to be in the rows that are returned</span>
<span class="sd">        :type sttribute_list: list</span>
<span class="sd">        :param attribute_dict: dictionary of attribute:value pairs that specify the set of atoms to be considered</span>
<span class="sd">        :type attribute_dict: dict</span>
<span class="sd">        :return: a dataframe segment</span>
<span class="sd">        :rtype: pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">get_atoms_w_attribute</span><span class="p">(</span><span class="n">attribute_list</span><span class="p">,</span><span class="n">attribute_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.get_R"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.get_R">[docs]</a>    <span class="k">def</span> <span class="nf">get_R</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_R return the cartesian position of atom with global index idx</span>

<span class="sd">        :param idx: atom global index</span>
<span class="sd">        :type idx: int</span>
<span class="sd">        :return: position of atom</span>
<span class="sd">        :rtype: numpy.ndarray(3,float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.rotate"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">R</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;rotate applies rotation matrix R to all atom positions</span>

<span class="sd">        :param R: rotation matrix</span>
<span class="sd">        :type R: numpy.ndarray((3,3),float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.translate"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;translate applies translation vector L to all atom positions</span>

<span class="sd">        :param L: translation vector</span>
<span class="sd">        :type L: numpy.ndarray(3,float)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">L</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.partners_of"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.partners_of">[docs]</a>    <span class="k">def</span> <span class="nf">partners_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;partners_of return list of atom indices of bonded partners of atom i</span>

<span class="sd">        :param i: global index of atom</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :return: list of partner global indices</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.resid_partners_of"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.resid_partners_of">[docs]</a>    <span class="k">def</span> <span class="nf">resid_partners_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ri</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;resid_partners_of return list of resid partners of resid ri</span>

<span class="sd">        :param ri: residue index</span>
<span class="sd">        :type ri: int</span>
<span class="sd">        :return: list of partner residue indices (two residues are partners if there is at least one interatomic bond joining them)</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">radf</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">ri</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">radf</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">():</span>
            <span class="n">bl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">at</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bl</span><span class="p">:</span>
                <span class="n">theirresid</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">theirresid</span><span class="o">!=</span><span class="n">ri</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">theirresid</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theirresid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="TopoCoord.interresidue_partners_of"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.interresidue_partners_of">[docs]</a>    <span class="k">def</span> <span class="nf">interresidue_partners_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;interresidue_partners_of return list of atom indices that are bonded partners of atom i and are not in the residue of atom i</span>

<span class="sd">        :param i: atom global index</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :return: list of atom indices of atoms that are partners of i not in i&#39;s residue</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">bl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;{i} partners {bl}&#39;)</span>
        <span class="n">myresid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">bl</span><span class="p">:</span>
            <span class="n">theirresid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;resNum&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">theirresid</span><span class="o">!=</span><span class="n">myresid</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="TopoCoord.minimum_distance"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.minimum_distance">[docs]</a>    <span class="k">def</span> <span class="nf">minimum_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="n">self_excludes</span><span class="o">=</span><span class="p">[],</span><span class="n">other_excludes</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;minimum_distance computes the distance of closest approach between self&#39;s Coordinates that other&#39;s Coordinates</span>

<span class="sd">        :param other: another TopoCoord object</span>
<span class="sd">        :type other: TopoCoord</span>
<span class="sd">        :param self_excludes: list of global atom indices to ignore in self, defaults to []</span>
<span class="sd">        :type self_excludes: list, optional</span>
<span class="sd">        :param other_excludes: list of global atom indices to ignore in other, defaults to []</span>
<span class="sd">        :type other_excludes: list, optional</span>
<span class="sd">        :return: distance of closest approach: i.e., the distance between the two atoms, one from self and one from other, that are closest together</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">minimum_distance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">,</span><span class="n">self_excludes</span><span class="o">=</span><span class="n">self_excludes</span><span class="p">,</span><span class="n">other_excludes</span><span class="o">=</span><span class="n">other_excludes</span><span class="p">)</span></div>

    <span class="c1"># def has_gro_attributes(self,attribute_list):</span>
    <span class="c1">#     return self.Coordinates.has_atom_attributes(attribute_list)</span>

<div class="viewcode-block" id="TopoCoord.are_bonded"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.are_bonded">[docs]</a>    <span class="k">def</span> <span class="nf">are_bonded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;are_bonded checks to see if atoms with indices i and j are bonded to each other</span>

<span class="sd">        :param i: an atom global index</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :param j: another atom global index</span>
<span class="sd">        :type j: int</span>
<span class="sd">        :return: True if atoms are bonded, False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">bondlist</span><span class="o">.</span><span class="n">are_bonded</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span></div>

    <span class="c1"># def decrement_z(self,pairs):</span>
    <span class="c1">#     self.Coordinates.decrement_z(pairs)</span>

<div class="viewcode-block" id="TopoCoord.adjust_charges"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.adjust_charges">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atoms</span><span class="o">=</span><span class="p">[],</span><span class="n">overcharge_threshhold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">netcharge</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;adjust_charges adjust the partial charges on atoms in list &#39;atoms&#39; if the absolute net charge exceeds &#39;netcharge&#39; by the &#39;overcharge_threshhold&#39; </span>

<span class="sd">        :param atoms: list of atom indexes to consider, defaults to []</span>
<span class="sd">        :type atoms: list, optional</span>
<span class="sd">        :param overcharge_threshhold: absolute deviation from netcharge that triggers adjustment, defaults to 0.1</span>
<span class="sd">        :type overcharge_threshhold: float, optional</span>
<span class="sd">        :param netcharge: desired net charge, defaults to 0.0</span>
<span class="sd">        :type netcharge: float, optional</span>
<span class="sd">        :param msg: a little message to echo to console if adjustment is necessary, defaults to &#39;&#39;</span>
<span class="sd">        :type msg: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">adjust_charges</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span><span class="n">overcharge_threshhold</span><span class="o">=</span><span class="n">overcharge_threshhold</span><span class="p">,</span><span class="n">desired_charge</span><span class="o">=</span><span class="n">netcharge</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.gro_DataFrame"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.gro_DataFrame">[docs]</a>    <span class="k">def</span> <span class="nf">gro_DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;gro_DataFrame return the appropriate Coordinates dataframe based on the directive in &#39;name&#39;</span>

<span class="sd">        :param name: either &#39;atoms&#39; or &#39;mol2_bonds&#39;</span>
<span class="sd">        :type name: str</span>
<span class="sd">        :return: the desired dataframe</span>
<span class="sd">        :rtype: pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s1">&#39;atoms&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">==</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">mol2_bonds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="TopoCoord.overwrite_coords"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.overwrite_coords">[docs]</a>    <span class="k">def</span> <span class="nf">overwrite_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;overwrite_coords overwrite coordinates in self by those in other</span>

<span class="sd">        :param other: another TopoCoord object</span>
<span class="sd">        :type other: TopoCoord</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(f&#39;Overwriting {other.Coordinates.A.shape[0]} coordinates&#39;)</span>
        <span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;before update:\n{C.to_string()}&#39;)</span>
        <span class="n">B</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">)</span>
        <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">[[</span><span class="s1">&#39;posX&#39;</span><span class="p">,</span><span class="s1">&#39;posY&#39;</span><span class="p">,</span><span class="s1">&#39;posZ&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># logger.debug(f&#39;new coordinates:\n{B.to_string()}&#39;)</span>
        <span class="n">C</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span></div>
        <span class="c1"># logger.debug(f&#39;after update:\n{self.Coordinates.A.to_string()}&#39;)</span>

<div class="viewcode-block" id="TopoCoord.linkcell_initialize"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.linkcell_initialize">[docs]</a>    <span class="k">def</span> <span class="nf">linkcell_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cutoff</span><span class="p">,</span><span class="n">ncpu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">force_repopulate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;linkcell_initialize Initialize the linkcell structure; a wrapper for Coordinates</span>

<span class="sd">        :param cutoff: minimum value of cell side-length</span>
<span class="sd">        :type cutoff: float</span>
<span class="sd">        :param ncpu: number of processors to use in populating linkcell structure in parallel, default 1</span>
<span class="sd">        :type ncpu: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">linkcell_initialize</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span><span class="n">ncpu</span><span class="o">=</span><span class="n">ncpu</span><span class="p">,</span><span class="n">populate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">force_repopulate</span><span class="o">=</span><span class="n">force_repopulate</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.linkcell_cleanup"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.linkcell_cleanup">[docs]</a>    <span class="k">def</span> <span class="nf">linkcell_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;linkcell_cleanup removes linkcell_idx attribute from Coordinate.A</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">],</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.atom_count"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.atom_count">[docs]</a>    <span class="k">def</span> <span class="nf">atom_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;atom_count Check to be sure the Coordinate and Topology members contain the same number of</span>
<span class="sd">            atoms</span>

<span class="sd">        :return: the number of atoms</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TopoCoord.total_mass"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.total_mass">[docs]</a>    <span class="k">def</span> <span class="nf">total_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;SI&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;total_mass Returns the total mass of the system.  Just a wrapper.</span>

<span class="sd">        :param units: units designation, defaults to &#39;SI&#39; (other option is &#39;gromacs&#39;)</span>
<span class="sd">        :type units: str, optional</span>
<span class="sd">        :return: mass</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">total_mass</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.total_volume"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.total_volume">[docs]</a>    <span class="k">def</span> <span class="nf">total_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;SI&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;total_volume returns total volume represented by the system&#39;s Coordinates</span>

<span class="sd">        :param units: unit designation, defaults to &#39;SI&#39;</span>
<span class="sd">        :type units: str, optional</span>
<span class="sd">        :return: box volume</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box_volume</span><span class="p">(</span><span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.density"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.density">[docs]</a>    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="s1">&#39;SI&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;density returns system density</span>

<span class="sd">        :param units: unit designation, defaults to &#39;SI&#39;</span>
<span class="sd">        :type units: str, optional</span>
<span class="sd">        :return: density</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_mass</span><span class="p">(</span><span class="n">units</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">total_volume</span><span class="p">(</span><span class="n">units</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.wrap_coords"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.wrap_coords">[docs]</a>    <span class="k">def</span> <span class="nf">wrap_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;wrap_coords wrap all coordinates into center periodic box</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">wrap_coords</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopoCoord.inherit_grx_attributes_from_molecules"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.inherit_grx_attributes_from_molecules">[docs]</a>    <span class="k">def</span> <span class="nf">inherit_grx_attributes_from_molecules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">molecule_dict</span><span class="p">,</span><span class="n">initial_composition</span><span class="p">,</span><span class="n">globally_unique</span><span class="o">=</span><span class="n">GRX_GLOBALLY_UNIQUE</span><span class="p">,</span><span class="n">unset_defaults</span><span class="o">=</span><span class="n">GRX_UNSET_DEFAULTS</span><span class="p">,</span><span class="n">overall_default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;inherit_grx_attributes_from_molecules Copy non-Gromacs-standard atom attributes in list &quot;attributes&quot; from molecule templates in molecule_dict according to molecule counts in dict initial_composition.</span>

<span class="sd">        :param attributes: list of labels of attributes to copy</span>
<span class="sd">        :type attributes: list</span>
<span class="sd">        :param molecule_dict: dictionary of available molecules (name:Molecule)</span>
<span class="sd">        :type molecule_dict: dict</span>
<span class="sd">        :param initial_composition: dictionary of initial composition (name:count)</span>
<span class="sd">        :type initial_composition: dict</span>
<span class="sd">        :param globally_unique: boolean list indicating attributes that must be globally unique, defaults to []</span>
<span class="sd">        :type globally_unique: list, optional</span>
<span class="sd">        :param unset_defaults: list of values, one per attribute, that signify UNSET, defaults to []</span>
<span class="sd">        :type unset_defaults: list, optional</span>
<span class="sd">        :param overall_default: default UNSET value for all attributes if unset_defaults is empty, defaults to 0</span>
<span class="sd">        :type overall_default: int, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># logger.debug(f&#39;inherit grx {attributes} {unset_defaults} {globally_unique}&#39;)</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; set up the globally_unique and unset_defaults list if necessary &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">globally_unique</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">):</span>
            <span class="n">globally_unique</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">))]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unset_defaults</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">):</span>
            <span class="n">unset_defaults</span><span class="o">=</span><span class="p">[</span><span class="n">overall_default</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">))]</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39; drop all attribute values from current global atom dataframe &#39;&#39;&#39;</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">adf</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">adf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> atoms inheriting these attributes from molecular templates:&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    Attribute name     Default value   Globally unique?&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attname</span><span class="p">,</span><span class="n">defval</span><span class="p">,</span><span class="n">gu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">,</span><span class="n">unset_defaults</span><span class="p">,</span><span class="n">globally_unique</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;    </span><span class="si">{</span><span class="n">attname</span><span class="si">:</span><span class="s1">&lt;15s</span><span class="si">}</span><span class="s1">    </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">defval</span><span class="p">)</span><span class="si">:</span><span class="s1">&lt;13s</span><span class="si">}</span><span class="s1">   </span><span class="si">{</span><span class="n">gu</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unset_defaults</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">):</span>
            <span class="n">att_running_maxval</span><span class="o">=</span><span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">,</span><span class="n">unset_defaults</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">==</span><span class="nb">float</span><span class="p">:</span>
                    <span class="n">att_running_maxval</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">att_running_maxval</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;0&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">att_running_maxval</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">overall_default</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">}</span>

        <span class="n">attribute_lists</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:[]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">}</span>
        <span class="n">value_counts</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">}</span>
        <span class="n">mol_idx_counter</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">icdict</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cc</span> <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="n">initial_composition</span> <span class="k">if</span> <span class="s1">&#39;count&#39;</span> <span class="ow">in</span> <span class="n">cc</span><span class="p">]:</span>
            <span class="n">molecule</span><span class="o">=</span><span class="n">icdict</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span>
            <span class="n">count</span><span class="o">=</span><span class="n">icdict</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
            <span class="n">mol_adf</span><span class="o">=</span><span class="n">molecule_dict</span><span class="p">[</span><span class="n">molecule</span><span class="p">]</span><span class="o">.</span><span class="n">TopoCoord</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Inheriting from </span><span class="si">{</span><span class="n">molecule</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">mol_adf</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                 <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
            <span class="n">mol_attr_df</span><span class="o">=</span><span class="n">mol_adf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">molecule_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grxattr</span><span class="p">):</span>
                    <span class="n">tra</span><span class="o">=</span><span class="n">mol_attr_df</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="s1">&#39;molecule&#39;</span><span class="p">:</span> 
                        <span class="n">utra</span><span class="o">=</span><span class="p">[</span><span class="n">mol_idx_counter</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tra</span><span class="p">]</span>
                        <span class="n">mol_idx_counter</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># nv=len(tra)-tra.count(unset_defaults[i])</span>
                        <span class="n">nuv</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tra</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">unset_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]])))</span>
                        <span class="n">utra</span><span class="o">=</span><span class="p">[]</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tra</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">globally_unique</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="nb">int</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="nb">float</span><span class="p">):</span>
                                <span class="n">xx</span><span class="o">=</span><span class="n">x</span><span class="o">+</span><span class="n">value_counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">!=</span><span class="n">unset_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="n">unset_defaults</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">xx</span><span class="o">=</span><span class="n">x</span>
                            <span class="n">utra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>
                        <span class="n">value_counts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">+=</span><span class="n">nuv</span>
                    <span class="n">attribute_lists</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">utra</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">L</span> <span class="ow">in</span> <span class="n">attribute_lists</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">L</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;postinherit adf columns </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.make_resid_graph"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.make_resid_graph">[docs]</a>    <span class="k">def</span> <span class="nf">make_resid_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">json_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;make_resid_graph make a residue connectivity graph</span>

<span class="sd">        :param json_file: name of output JSON file to write, defaults to None</span>
<span class="sd">        :type json_file: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">make_resid_graph</span><span class="p">(</span><span class="n">json_file</span><span class="o">=</span><span class="n">json_file</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.maxspan"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.maxspan">[docs]</a>    <span class="k">def</span> <span class="nf">maxspan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;maxspan Returns the maxspan of the Coordinates (dimensions of orthorhombic</span>
<span class="sd">            convex hull enclosing Coordinates). Just a wrapper.</span>

<span class="sd">        :return: array of x-span, y-span, z-span</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">maxspan</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopoCoord.minmax"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.minmax">[docs]</a>    <span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;minmax returns the coordinates of the atoms at the lower-leftmost and upper-rightmost positions in the constellation of points in the atoms dataframe</span>

<span class="sd">        :return: tuple of two points, lower-leftmost and upper-rightmost, respectively</span>
<span class="sd">        :rtype: tuple(np.ndarray(3,float),np.ndarray(3,float))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">minmax</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopoCoord.checkbox"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.checkbox">[docs]</a>    <span class="k">def</span> <span class="nf">checkbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;checkbox checks that the entire constellation of points in the atoms dataframe fits within the designated box for this Configuration object</span>

<span class="sd">        :return: True,True if both lower-leftmost and upper-rightmost points are within the box</span>
<span class="sd">        :rtype: tuple(bool,bool)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">checkbox</span><span class="p">()</span></div>

<div class="viewcode-block" id="TopoCoord.write_mol2"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.write_mol2">[docs]</a>    <span class="k">def</span> <span class="nf">write_mol2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">molname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">element_names_as_types</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;write_mol2 Writes a SYBYL MOL2-format file using Coordinates, with certain</span>
<span class="sd">           atom attributes borrowed from the Topology</span>

<span class="sd">        :param filename: name of file to write</span>
<span class="sd">        :type filename: str</span>
<span class="sd">        :param molname: name of molecule to put in mol2 file, defaults to &#39;&#39;</span>
<span class="sd">        :type molname: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">molname</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">molname</span><span class="o">=</span><span class="s1">&#39;This Molecule has no name&#39;</span>
        <span class="n">other_attributes</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">element_names_as_types</span><span class="p">:</span>
            <span class="n">element_names</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]]</span>
            <span class="n">other_attributes</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">element_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other_attributes</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="n">other_attributes</span><span class="p">[</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">][</span><span class="s1">&#39;charge&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;mol2&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="c1"># logger.debug(f&#39;write_mol2, other_attributes:\n{other_attributes.to_string()}&#39;)</span>
        <span class="k">if</span> <span class="s1">&#39;mol2_bonds&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">write_mol2</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">molname</span><span class="o">=</span><span class="n">molname</span><span class="p">,</span><span class="n">bondsDF</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;mol2_bonds&#39;</span><span class="p">],</span><span class="n">other_attributes</span><span class="o">=</span><span class="n">other_attributes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">write_mol2</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">molname</span><span class="o">=</span><span class="n">molname</span><span class="p">,</span><span class="n">other_attributes</span><span class="o">=</span><span class="n">other_attributes</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.merge"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;merge Merges the TopoCoord instance &quot;other&quot; to self</span>

<span class="sd">        :param other: another TopoCoord instance</span>
<span class="sd">        :type other: TopoCoord</span>
<span class="sd">        :return: a shift tuple (returned by Coordinates.merge())</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Topology</span><span class="p">)</span>
        <span class="n">shifts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">idx_lists</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">idx_lists</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># logger.debug(f&#39;TopoCoord merge: list_name {name} lists {idx_lists}&#39;)</span>
            <span class="k">for</span> <span class="n">a_list</span> <span class="ow">in</span> <span class="n">idx_lists</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="o">+</span><span class="n">shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a_list</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_grx_attributes_from_idx_list</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shifts</span></div>

<div class="viewcode-block" id="TopoCoord.bondtest_df"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.bondtest_df">[docs]</a>    <span class="k">def</span> <span class="nf">bondtest_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">df</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span><span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">show_piercings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bondtest_df applies bond filters to all bonds in the dataframe;</span>

<span class="sd">        :param df: dataframe of possible bonds; dataframe should have columns &#39;ai&#39;, &#39;aj&#39; and &#39;r&#39;; this method adds the column &#39;results&#39;</span>
<span class="sd">        :type df: pd.DataFrame</span>
<span class="sd">        :param pbc: flags indicating dimensions in which pbc are used, defaults to [1,1,1]</span>
<span class="sd">        :type pbc: list, optional</span>
<span class="sd">        :param show_piercings: toggles diagnostic output for pierced rings, defaults to True</span>
<span class="sd">        :type show_piercings: bool, optional</span>
<span class="sd">        :return: input data frame with new &#39;results&#39; column</span>
<span class="sd">        :rtype: pandas.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df</span>
        <span class="n">results</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">itertuples</span><span class="p">():</span>
            <span class="n">result</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bondtest</span><span class="p">((</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">r</span><span class="p">),</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span><span class="n">show_piercings</span><span class="o">=</span><span class="n">show_piercings</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">results</span>
        <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">BTRC</span><span class="o">.</span><span class="n">passed</span><span class="p">]</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="TopoCoord.bondtest"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.bondtest">[docs]</a>    <span class="k">def</span> <span class="nf">bondtest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">show_piercings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if bond b is to be allowed to form based on geometric and</span>
<span class="sd">            topological criteria</span>

<span class="sd">        :param b: bond, tuple (ai,aj,rij)</span>
<span class="sd">        :type b: 2-tuple</span>
<span class="sd">        :param pbc: periodic boundary condition flags in each direction, defaults to [1,1,1]</span>
<span class="sd">        :type pbc: list, optional</span>
<span class="sd">        :param show_piercings: flag indicating you want to write gro files showing</span>
<span class="sd">            pierced rings</span>
<span class="sd">        :type show_piercings: bool</span>
<span class="sd">        :return: BTRC instance</span>
<span class="sd">        :rtype: BTRC enum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">rij</span><span class="o">=</span><span class="n">b</span>
        <span class="c1"># i=int(i)</span>
        <span class="c1"># j=int(j)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">makes_shortcircuit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BTRC</span><span class="o">.</span><span class="n">failed_short_circuit</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">makes_cycle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BTRC</span><span class="o">.</span><span class="n">failed_bond_cycle</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pierces_ring</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span><span class="n">show_piercings</span><span class="o">=</span><span class="n">show_piercings</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BTRC</span><span class="o">.</span><span class="n">failed_pierce_ring</span><span class="p">,</span><span class="mi">0</span>
        <span class="c1"># logger.debug(f&#39;passed: {i:&gt;7d} {j:&gt;7d} {rij:&gt;6.3f} nm&#39;)</span>
        <span class="k">return</span> <span class="n">BTRC</span><span class="o">.</span><span class="n">passed</span><span class="p">,</span><span class="n">rij</span></div>

<div class="viewcode-block" id="TopoCoord.pierces_ring"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.pierces_ring">[docs]</a>    <span class="k">def</span> <span class="nf">pierces_ring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">show_piercings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;pierces_ring checks to see if bond i-j would pierce any covalent ring structure</span>

<span class="sd">        :param i: global index of an atom</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :param j: global index of another</span>
<span class="sd">        :type j: int</span>
<span class="sd">        :param pbc: flags indicating which dimensions have pbc applied, defaults to [1,1,1]</span>
<span class="sd">        :type pbc: list, optional</span>
<span class="sd">        :param show_piercings: toggles diagnostic output of ring piercings, defaults to True</span>
<span class="sd">        :type show_piercings: bool, optional</span>
<span class="sd">        :return: True if a ring is pierced; False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">LC</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">linkcell</span>
        <span class="c1"># at the current state, a linkcell is active under Coordinates</span>
        <span class="c1"># with spacing *greater* than the initial length of any bond.</span>
        <span class="c1"># so we can visit rings with one or more atom in a cell neighboring</span>
        <span class="c1"># the cells of the two atoms</span>
        <span class="k">assert</span> <span class="s1">&#39;linkcell_idx&#39;</span> <span class="ow">in</span> <span class="n">adf</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;Error: atoms have no linkcell_idx attribute - bug!&#39;</span>
        <span class="n">i_lcidx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
        <span class="n">j_lcidx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
        <span class="n">joint_idx</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">LC</span><span class="o">.</span><span class="n">neighborlists</span><span class="p">[</span><span class="n">i_lcidx</span><span class="p">]</span><span class="o">+</span><span class="n">LC</span><span class="o">.</span><span class="n">neighborlists</span><span class="p">[</span><span class="n">j_lcidx</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="n">i_lcidx</span><span class="p">,</span><span class="n">j_lcidx</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">joint_idx</span><span class="p">:</span>
                <span class="n">joint_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">cycle_tags</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">adf</span><span class="p">[(</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;linkcell_idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">joint_idx</span><span class="p">))][</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()))</span>
        <span class="n">B</span><span class="o">=</span><span class="n">adf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">saveB</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># logger.debug(f&#39;bond {i} {j} subframe&#39;)</span>
        <span class="c1"># for ln in B.to_string().split(&#39;\n&#39;):</span>
        <span class="c1">#     logger.debug(ln)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycle_tags</span><span class="p">:</span>
            <span class="n">C</span><span class="o">=</span><span class="n">adf</span><span class="p">[</span><span class="n">adf</span><span class="p">[</span><span class="s1">&#39;cycle&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># logging.debug(f&#39;ring {c} has {C.shape[0]} members&#39;)</span>
            <span class="c1"># assert 4&lt;C.shape[0]&lt;7</span>
            <span class="n">saveC</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">pierces</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">pbc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">show_piercings</span><span class="p">:</span>
                    <span class="n">sub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">subcoords</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">]))</span>
                    <span class="n">sub</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ring-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;.gro&#39;</span><span class="p">)</span>
                    <span class="n">sub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">subcoords</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">saveB</span><span class="p">,</span><span class="n">saveC</span><span class="p">]))</span>
                    <span class="n">sub</span><span class="o">.</span><span class="n">write_gro</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ring-orig-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="o">+</span><span class="s1">&#39;.gro&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cycle </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s1"> pierced by bond candidate </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">sub</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TopoCoord.makes_shortcircuit"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.makes_shortcircuit">[docs]</a>    <span class="k">def</span> <span class="nf">makes_shortcircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine whether atoms i and j, if bonded, would produce a short circuit,</span>
<span class="sd">           defined as an instance in which i and j belong to residues that are already</span>
<span class="sd">           bonded to each other</span>

<span class="sd">        :param i: global index of first atom</span>
<span class="sd">        :type i: int</span>
<span class="sd">        :param j: global index of second atom</span>
<span class="sd">        :type j: int</span>
<span class="sd">        :return: True if a short circuit would happen, False otherwise</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i_resName</span><span class="p">,</span><span class="n">i_resNum</span><span class="p">,</span><span class="n">i_atomName</span><span class="p">,</span><span class="n">i_molNum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">([</span><span class="s1">&#39;resName&#39;</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">,</span><span class="s1">&#39;molecule&#39;</span><span class="p">],{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
        <span class="n">j_resName</span><span class="p">,</span><span class="n">j_resNum</span><span class="p">,</span><span class="n">j_atomName</span><span class="p">,</span><span class="n">j_molNum</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">([</span><span class="s1">&#39;resName&#39;</span><span class="p">,</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">,</span><span class="s1">&#39;molecule&#39;</span><span class="p">],{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        In a cure reaction, atoms that react should be in different residues</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">i_resNum</span><span class="o">!=</span><span class="n">j_resNum</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;shortcircuit test error </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> both in residue </span><span class="si">{</span><span class="n">i_resNum</span><span class="si">}</span><span class="s1">?&#39;</span>
        <span class="n">i_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">j_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">partners_of</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="c1"># if i in j_neighbors or j in i_neighbors:</span>
        <span class="c1">#     # logger.debug(f&#39;atoms {i} and {j} already on each other\&#39;s list of bonded partners&#39;)</span>
        <span class="c1">#     return True</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Should never test a proposed bond that already exists</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i_neighbors</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">j_neighbors</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set up a DataFrame for heavy atoms in each molecule</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ADF</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">R1DF</span><span class="o">=</span><span class="n">ADF</span><span class="p">[</span><span class="n">ADF</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">i_molNum</span><span class="p">]</span>
        <span class="n">R1DF</span><span class="o">=</span><span class="n">R1DF</span><span class="p">[[(</span><span class="ow">not</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">R1DF</span><span class="p">[</span><span class="s1">&#39;atomName&#39;</span><span class="p">]]]</span>
        <span class="n">R2DF</span><span class="o">=</span><span class="n">ADF</span><span class="p">[</span><span class="n">ADF</span><span class="p">[</span><span class="s1">&#39;molecule&#39;</span><span class="p">]</span><span class="o">==</span><span class="n">j_molNum</span><span class="p">]</span>
        <span class="n">R2DF</span><span class="o">=</span><span class="n">R2DF</span><span class="p">[[(</span><span class="ow">not</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">R2DF</span><span class="p">[</span><span class="s1">&#39;atomName&#39;</span><span class="p">]]]</span>
        <span class="k">assert</span> <span class="n">R1DF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span>
        <span class="k">assert</span> <span class="n">R2DF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Test to see if there exists any bond between these two molecules</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">R1DF</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span><span class="n">R2DF</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">()):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">are_bonded</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TopoCoord.reset_grx_attributes_from_idx_list"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.reset_grx_attributes_from_idx_list">[docs]</a>    <span class="k">def</span> <span class="nf">reset_grx_attributes_from_idx_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">list_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reset_grx_attributes_from_idx_list uses information in the &quot;index lists&quot; to repopulate appropriate GRX attributes.  There are two index lists:  one for cycles and the other for chains.  Each index list is a list of lists; each element corresponds to a unique structure (cycle or chain) and is a list of global atom indices for atoms that make up that structural instance.</span>

<span class="sd">        :param list_name: either &#39;cycle&#39; or &#39;chain&#39;</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">list_name</span><span class="si">}</span><span class="s1">_idx&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="n">list_name</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="n">list_name</span><span class="p">,</span><span class="n">i</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">list_name</span><span class="si">}</span><span class="s1">_idx&#39;</span><span class="p">,</span><span class="n">j</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span></div>

<div class="viewcode-block" id="TopoCoord.reset_idx_list_from_grx_attributes"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.reset_idx_list_from_grx_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">reset_idx_list_from_grx_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">list_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reset_idx_list_from_grx_attributes is the inverse of reset_grx_attributes_from_idx_list: it uses the GRX attributes to rebuild index lists.</span>

<span class="sd">        :param list_name: either &#39;cycle&#39; or &#39;chain&#39;</span>
<span class="sd">        :type list_name: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;reset: columns </span><span class="si">{</span><span class="n">adf</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">tmp_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">adf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">gix</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">]</span>
            <span class="n">cid</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="n">list_name</span><span class="p">]</span>
            <span class="n">cix</span><span class="o">=</span><span class="n">r</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">list_name</span><span class="si">}</span><span class="s1">_idx&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cid</span><span class="o">!=-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cid</span> <span class="ow">in</span> <span class="n">tmp_dict</span><span class="p">:</span>
                    <span class="n">tmp_dict</span><span class="p">[</span><span class="n">cid</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                <span class="n">tmp_dict</span><span class="p">[</span><span class="n">cid</span><span class="p">][</span><span class="n">cix</span><span class="p">]</span><span class="o">=</span><span class="n">gix</span>
        <span class="c1"># logger.debug(f&#39;{list_name} tmp_dict item count: {len(tmp_dict)}&#39;)</span>
        <span class="c1"># logger.debug(f&#39;{tmp_dict}&#39;)</span>
        <span class="k">if</span> <span class="n">tmp_dict</span><span class="p">:</span>
            <span class="n">consec_test</span><span class="o">=</span><span class="p">[</span><span class="n">a</span> <span class="ow">in</span> <span class="n">tmp_dict</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_dict</span><span class="p">))]</span>
            <span class="c1"># logger.debug(f&#39;{consec_test}&#39;)</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">consec_test</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">list_name</span><span class="si">}</span><span class="s1"> reset_idx_list for group attribute </span><span class="si">{</span><span class="n">list_name</span><span class="si">}</span><span class="s1"> has non-consecutive integer keys -- bug</span><span class="se">\n</span><span class="si">{</span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">tmp_dict</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_dict</span><span class="p">))]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">ngroups</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="n">list_name</span><span class="p">]</span><span class="o">=</span><span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngroups</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngroups</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tmp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="n">list_name</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp_dict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span></div>
        <span class="c1"># logger.debug(f&#39;-&gt; idx_lists[{list_name}]: {self.idx_lists[list_name]}&#39;)</span>

<div class="viewcode-block" id="TopoCoord.chainlist_update"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.chainlist_update">[docs]</a>    <span class="k">def</span> <span class="nf">chainlist_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_bond_recs</span><span class="p">,</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;chainlist_update updates the chain index lists due to generation of new bonds</span>

<span class="sd">        :param new_bond_recs: list of bond records, each a tuple of two ints corresponding to atom indices</span>
<span class="sd">        :type new_bond_recs: list</span>
<span class="sd">        :param msg: a nice message (unused), defaults to &#39;&#39;</span>
<span class="sd">        :type msg: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chainlists</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
        <span class="c1"># logger.debug(f&#39;pre {msg} chainlists&#39;)</span>
        <span class="c1"># for i,c in enumerate(chainlists):</span>
        <span class="c1">#     logger.debug(f&#39;  {i} {c}&#39;)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">new_bond_recs</span><span class="p">:</span>
            <span class="n">aidx</span><span class="p">,</span><span class="n">bidx</span><span class="o">=</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aidx</span><span class="p">})</span>
            <span class="n">br</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">bidx</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">ar</span><span class="o">==</span><span class="n">br</span><span class="p">:</span> <span class="k">continue</span> <span class="c1"># ignore intramolecular bonds</span>
            <span class="c1"># logger.debug(f&#39;chainlist_update pair {aidx} {bidx}&#39;)</span>
            <span class="n">ac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aidx</span><span class="p">})</span>
            <span class="n">bc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">bidx</span><span class="p">})</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ac </span><span class="si">{</span><span class="n">ac</span><span class="si">}</span><span class="s1"> bc </span><span class="si">{</span><span class="n">bc</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ac</span><span class="o">==-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">bc</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># neither of these newly bonded atoms is already in a chain, so</span>
                <span class="c1"># there is no possibility that this new bond can join two chains.</span>
                <span class="k">continue</span>
            <span class="c1"># logger.debug(f&#39;chain of bidx {bidx}: {chainlists[bc]}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;chain of aidx {aidx}: {chainlists[ac]}&#39;)</span>
            <span class="n">aci</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aidx</span><span class="p">})</span>
            <span class="n">bci</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">bidx</span><span class="p">})</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; -&gt; </span><span class="si">{</span><span class="n">aidx</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">bidx</span><span class="si">}</span><span class="s1">: ac </span><span class="si">{</span><span class="n">ac</span><span class="si">}</span><span class="s1"> #</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span><span class="si">}</span><span class="s1"> aci </span><span class="si">{</span><span class="n">aci</span><span class="si">}</span><span class="s1"> bc </span><span class="si">{</span><span class="n">bc</span><span class="si">}</span><span class="s1"> #</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span><span class="si">}</span><span class="s1"> bci </span><span class="si">{</span><span class="n">bci</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># one must be a head and the other a tail</span>
            <span class="k">if</span> <span class="n">aci</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># a is a head</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="o">!=</span><span class="n">bci</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Atom </span><span class="si">{</span><span class="n">bidx</span><span class="si">}</span><span class="s1"> has index </span><span class="si">{</span><span class="n">bci</span><span class="si">}</span><span class="s1"> in chain </span><span class="si">{</span><span class="n">bc</span><span class="si">}</span><span class="s1"> but that chain has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">bc</span><span class="p">])</span><span class="si">}</span><span class="s1"> elements, so it cannot be the tail of the chain. The tail appears to be atom </span><span class="si">{</span><span class="n">chainlists</span><span class="p">[</span><span class="n">bc</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">. So something is wrong, and I am not merging these chains.&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;chain of </span><span class="si">{</span><span class="n">aidx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">chainlists</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;chain of </span><span class="si">{</span><span class="n">bidx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">chainlists</span><span class="p">[</span><span class="n">bc</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">c1</span><span class="o">=</span><span class="n">ac</span>
                <span class="n">c2</span><span class="o">=</span><span class="n">bc</span>
            <span class="k">elif</span> <span class="n">bci</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># b is a head</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="o">!=</span><span class="n">aci</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Atom </span><span class="si">{</span><span class="n">aidx</span><span class="si">}</span><span class="s1"> has index </span><span class="si">{</span><span class="n">aci</span><span class="si">}</span><span class="s1"> in chain </span><span class="si">{</span><span class="n">ac</span><span class="si">}</span><span class="s1"> but that chain has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">ac</span><span class="p">])</span><span class="si">}</span><span class="s1"> elements, so it cannot be the tail of the chain. The tail appears to be atom </span><span class="si">{</span><span class="n">chainlists</span><span class="p">[</span><span class="n">ac</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">. So something is wrong, and I am not merging these chains.&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;chain of </span><span class="si">{</span><span class="n">aidx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">chainlists</span><span class="p">[</span><span class="n">ac</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;chain of </span><span class="si">{</span><span class="n">bidx</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">chainlists</span><span class="p">[</span><span class="n">bc</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">c1</span><span class="o">=</span><span class="n">bc</span>
                <span class="n">c2</span><span class="o">=</span><span class="n">ac</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Neither of </span><span class="si">{</span><span class="n">aidx</span><span class="si">}</span><span class="s1"> or </span><span class="si">{</span><span class="n">bidx</span><span class="si">}</span><span class="s1"> are heads of their respective chains.&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This is most likely happening because of branching, which is permitted but&#39;</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;does not allow for merging of 1-D chains.&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">chainlists</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">c1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">aidx</span> <span class="ow">in</span> <span class="n">chainlists</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain&#39;</span><span class="p">,</span><span class="n">c2</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aidx</span><span class="p">})</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain_idx&#39;</span><span class="p">,</span><span class="n">chainlists</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">aidx</span><span class="p">),{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">aidx</span><span class="p">})</span>
            <span class="c1"># logger.debug(f&#39;removing chain {c1}&#39;)</span>
            <span class="n">chainlists</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">chainlists</span><span class="p">[</span><span class="n">c1</span><span class="p">])</span>
            <span class="c1"># since we remove c1, all indices greater than c1 must decrement</span>
            <span class="n">dec_us</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">])</span>
            <span class="n">bad_chain_idx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dec_us</span><span class="o">&gt;</span><span class="n">c1</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;bad_chain_idx: {bad_chain_idx}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;{dec_us[bad_chain_idx]}&#39;)</span>
            <span class="n">dec_us</span><span class="p">[</span><span class="n">bad_chain_idx</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">dec_us</span>
        <span class="n">cnms</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]:</span>
            <span class="n">cnms</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">])</span></div>
        <span class="c1"># logger.debug(f&#39;post {msg} chains {self.idx_lists[&quot;chain&quot;]} {cnms}&#39;)</span>

<div class="viewcode-block" id="TopoCoord.makes_cycle"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.makes_cycle">[docs]</a>    <span class="k">def</span> <span class="nf">makes_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">aidx</span><span class="p">,</span><span class="n">bidx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;makes_cycle checks the current chain index lists to see if a bond between aidx and bidx (global atom indices) would generate a C-C&#39; cycle</span>

<span class="sd">        :param aidx: global index of an atom</span>
<span class="sd">        :type aidx: int</span>
<span class="sd">        :param bidx: global index of another atom</span>
<span class="sd">        :type bidx: int</span>
<span class="sd">        :return: True if a bond betwen aidx and bidx would form a C-C&#39; cycle</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># is there a chain with aidx as head and bidx as tail, or vice versa?</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aidx</span><span class="o">==</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bidx</span><span class="o">==</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">aidx</span><span class="o">==</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">bidx</span><span class="o">==</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="TopoCoord.cycle_collective"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.cycle_collective">[docs]</a>    <span class="k">def</span> <span class="nf">cycle_collective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bdf</span><span class="p">:</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;cycle_collective Check to see if, when considered as a collective, this</span>
<span class="sd">        set of bondrecs leads to one or more cyclic chain; if so, longest bonds that </span>
<span class="sd">        break cycles are removed from bondrecs list and resulting list is returned</span>

<span class="sd">        :param bdf: bonds data frame</span>
<span class="sd">        :type bdf: pandas.DataFrame</span>
<span class="sd">        :return: list of bond records that results in no new cycles</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">addlink</span><span class="p">(</span><span class="n">chainlist</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
            <span class="n">i_cidx</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">j_cidx</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cidx</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chainlist</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">i_cidx</span><span class="o">=</span><span class="p">(</span><span class="n">cidx</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">j_cidx</span><span class="o">=</span><span class="p">(</span><span class="n">cidx</span><span class="p">,</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;i </span><span class="si">{</span><span class="n">i_cidx</span><span class="si">}</span><span class="s1"> j </span><span class="si">{</span><span class="n">j_cidx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i_cidx</span><span class="o">==</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j_cidx</span><span class="o">==</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))):</span>
                <span class="c1"># logger.debug(f&#39;cycle_collective: {i} is in chain {i_cidx[0]} at {i_cidx[1]}&#39;)</span>
                <span class="c1"># logger.debug(f&#39;cycle_collective: {j} is in chain {j_cidx[0]} at {j_cidx[1]}&#39;)</span>
                <span class="k">if</span> <span class="n">i_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">j_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># cyclized!</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;chain </span><span class="si">{</span><span class="n">i_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> is cyclized!&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">i_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="kc">True</span>
                <span class="n">old_head</span><span class="p">,</span><span class="n">old_tail</span><span class="o">=</span><span class="p">(</span><span class="n">i_cidx</span><span class="p">,</span><span class="n">j_cidx</span><span class="p">)</span> <span class="k">if</span> <span class="n">i_cidx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">j_cidx</span><span class="p">,</span><span class="n">i_cidx</span><span class="p">)</span>
                <span class="n">chainlist</span><span class="p">[</span><span class="n">old_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chainlist</span><span class="p">[</span><span class="n">old_head</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="c1"># logger.debug(f&#39;new chain {old_tail[0]} {chainlist[old_tail[0]]}&#39;)</span>
                <span class="n">chainlist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">chainlist</span><span class="p">[</span><span class="n">old_head</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="k">return</span> <span class="n">old_tail</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># this bond involves one atom in a chain and another that is not; no way this can be a cyclization, but we have to return somthing</span>
                <span class="k">return</span> <span class="n">i_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">i_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">j_cidx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="kc">False</span>

        <span class="c1"># kb=bondrecs.copy()</span>
        <span class="c1"># logger.debug(f&#39;checking set of {bdf.shape[0]} bonds for nascent cycles&#39;)</span>
        <span class="n">new_bdf</span><span class="o">=</span><span class="n">bdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_bdf</span><span class="p">[</span><span class="s1">&#39;remove-to-uncyclize&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">chains</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="n">chains</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chains</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_bdf</span>
        <span class="n">cyclized_chains</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">chains_of_bonds</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">chain_idx</span><span class="p">,</span><span class="n">cyclized</span><span class="o">=</span><span class="n">addlink</span><span class="p">(</span><span class="n">chains</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;bond {i} {r.ai}-{r.aj} ({r.reactantName}) adds to chain {chain_idx}&#39;)</span>
            <span class="n">chains_of_bonds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain_idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cyclized</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">chain_idx</span> <span class="ow">in</span> <span class="n">cyclized_chains</span><span class="p">:</span>
                <span class="n">cyclized_chains</span><span class="p">[</span><span class="n">chain_idx</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">chains_of_bonds</span><span class="p">)</span><span class="o">==</span><span class="n">bdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">bdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="c1"># logger.debug(f&#39;compiling bonds of cyclized chains: bond {i}&#39;)</span>
            <span class="n">cidx</span><span class="o">=</span><span class="n">chains_of_bonds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># logger.debug(f&#39;compiling bonds of cyclized chains: cidx {chains_of_bonds[i]}&#39;)</span>
            <span class="k">if</span> <span class="n">cidx</span> <span class="ow">in</span> <span class="n">cyclized_chains</span><span class="p">:</span>
                <span class="n">cyclized_chains</span><span class="p">[</span><span class="n">cidx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">cyclized_chains</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lb</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># last bondrec in list</span>
            <span class="n">new_bdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">lb</span><span class="p">,</span><span class="s1">&#39;remove-to-uncyclize&#39;</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">return</span> <span class="n">new_bdf</span></div>

<div class="viewcode-block" id="TopoCoord.get_bystanders"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.get_bystanders">[docs]</a>    <span class="k">def</span> <span class="nf">get_bystanders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atom_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_bystanders identify and return bystanders at a particular proposed bond specified by atom_idx</span>

<span class="sd">        :param atom_idx: container of two global atom indices specifying a proposed bond</span>
<span class="sd">        :type atom_idx: container</span>
<span class="sd">        :return: 4-tuple of special bystander info containers</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bystander_atomidx</span><span class="o">=</span><span class="p">[[</span><span class="nb">int</span><span class="p">],[</span><span class="nb">int</span><span class="p">]]</span> <span class="c1"># elements correspond to atoms in atom_idx</span>
        <span class="n">bystander_atomnames</span><span class="o">=</span><span class="p">[[</span><span class="nb">str</span><span class="p">],[</span><span class="nb">str</span><span class="p">]]</span>
        <span class="n">bystander_resids</span><span class="o">=</span><span class="p">[[</span><span class="nb">int</span><span class="p">],[</span><span class="nb">int</span><span class="p">]]</span>
        <span class="n">bystander_resnames</span><span class="o">=</span><span class="p">[[</span><span class="nb">str</span><span class="p">],[</span><span class="nb">str</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">bystander_atomidx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interresidue_partners_of</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">atom_idx</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bystander_atomidx</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span> <span class="c1"># if new bond has not yet formed</span>
                <span class="n">bystander_atomidx</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atom_idx</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">])</span>
            <span class="n">bystander_atomnames</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;atomName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">bystander_atomidx</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="n">bystander_resids</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">bystander_atomidx</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
            <span class="n">bystander_resnames</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resName&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">bystander_atomidx</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">bystander_resids</span><span class="p">,</span><span class="n">bystander_resnames</span><span class="p">,</span><span class="n">bystander_atomidx</span><span class="p">,</span><span class="n">bystander_atomnames</span></div>
    
<div class="viewcode-block" id="TopoCoord.get_oneaways"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.get_oneaways">[docs]</a>    <span class="k">def</span> <span class="nf">get_oneaways</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atom_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_oneaways identify and return one-aways for a particular proposed bond specified by atom_idx</span>

<span class="sd">        :param atom_idx: two-element container of atom indices specifying proposed bond</span>
<span class="sd">        :type atom_idx: list</span>
<span class="sd">        :return: tuple of oneaways-lists</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resids</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_idx</span><span class="p">]</span>
        <span class="n">chains</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_idx</span><span class="p">]</span>
        <span class="n">chain_idx</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;chain_idx&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">})</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">atom_idx</span><span class="p">]</span>
        <span class="c1"># logger.debug(f&#39;chains {chains} chain_idx {chain_idx}&#39;)</span>
        <span class="n">oneaway_resids</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">oneaway_resnames</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">oneaway_atomidx</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">oneaway_atomnames</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="c1"># assert chain_idx[0]==0 or chain_idx[1]==0 # one must be a head</span>
        <span class="k">if</span> <span class="n">chains</span><span class="o">!=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">chainlists_idx</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">idx_lists</span><span class="p">[</span><span class="s1">&#39;chain&#39;</span><span class="p">][</span><span class="n">chains</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">chainlists_atomnames</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">chainlists_resids</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">chainlists_resnames</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">atomnamelist</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">residlist</span><span class="o">=</span><span class="p">[]</span>
                <span class="n">resnamelist</span><span class="o">=</span><span class="p">[]</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">chainlists_idx</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                    <span class="n">rnum</span><span class="p">,</span><span class="n">rname</span><span class="p">,</span><span class="n">aname</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">([</span><span class="s1">&#39;resNum&#39;</span><span class="p">,</span><span class="s1">&#39;resName&#39;</span><span class="p">,</span><span class="s1">&#39;atomName&#39;</span><span class="p">],{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">})</span>
                    <span class="n">residlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnum</span><span class="p">)</span>
                    <span class="n">resnamelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rname</span><span class="p">)</span>
                    <span class="n">atomnamelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aname</span><span class="p">)</span>
                <span class="n">chainlists_atomnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atomnamelist</span><span class="p">)</span>
                <span class="n">chainlists_resids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residlist</span><span class="p">)</span>
                <span class="n">chainlists_resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resnamelist</span><span class="p">)</span>
            <span class="c1"># logger.debug(f&#39;chainlists_idx: {chainlists_idx}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;chainlists_atomnames: {chainlists_atomnames}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;chainlists_resids: {chainlists_resids}&#39;)</span>
            <span class="c1"># logger.debug(f&#39;chainlists_resnames: {chainlists_resnames}&#39;)</span>
            <span class="n">oa_chain_idx</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">if</span> <span class="n">chain_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">chain_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">chain_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">oa_chain_idx</span><span class="o">=</span><span class="p">[</span><span class="n">chain_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">chain_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">chain_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">chain_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">chain_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">oa_chain_idx</span><span class="o">=</span><span class="p">[</span><span class="n">chain_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">chain_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># logger.debug(f&#39;oa_chain_idx {oa_chain_idx}&#39;)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">oa_chain_idx</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
            <span class="n">oa_idx</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">oa_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">chainlists_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">oa_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span>
                <span class="k">if</span> <span class="n">oa_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">oneaway_atomidx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">chainlists_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">oneaway_atomnames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">chainlists_atomnames</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">oneaway_resids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">chainlists_resids</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                    <span class="n">oneaway_resnames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">chainlists_resnames</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">oa_chain_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="c1"># logger.debug(f&#39;result oneaway_resids {oneaway_resids} oneaway_resnames {oneaway_resnames}&#39;)</span>
        <span class="c1"># logger.debug(f&#39;oneaway_atomidx {oneaway_atomidx} oneaway_atomnames {oneaway_atomnames}&#39;)</span>
        <span class="k">return</span> <span class="n">oneaway_resids</span><span class="p">,</span><span class="n">oneaway_resnames</span><span class="p">,</span><span class="n">oneaway_atomidx</span><span class="p">,</span><span class="n">oneaway_atomnames</span></div>

<div class="viewcode-block" id="TopoCoord.grab_files"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.grab_files">[docs]</a>    <span class="k">def</span> <span class="nf">grab_files</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;grab_files using absolute pathname information, grab the most up-to-date gromacs files for this system and deposit them into the cwd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cwd</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span><span class="s1">&#39;gro&#39;</span><span class="p">,</span><span class="s1">&#39;grx&#39;</span><span class="p">]:</span>
            <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s1"> grabbing </span><span class="si">{</span><span class="n">pfs</span><span class="o">.</span><span class="n">proj_abspath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="si">}</span><span class="s1"> into </span><span class="si">{</span><span class="n">pfs</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>  
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">commonprefix</span><span class="p">([</span><span class="n">cwd</span><span class="p">,</span><span class="n">filename</span><span class="p">])</span><span class="o">!=</span><span class="n">cwd</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">cwd</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="n">ext</span><span class="p">]</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span></div>

<div class="viewcode-block" id="TopoCoord.grompp_and_mdrun"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.grompp_and_mdrun">[docs]</a>    <span class="k">def</span> <span class="nf">grompp_and_mdrun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">mdp</span><span class="p">,</span><span class="n">mylogger</span><span class="o">=</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;grompp_and_mdrun manages invoking a single Gromacs run using the current TopoCoord</span>

<span class="sd">        :param out: output filename basename</span>
<span class="sd">        :type out: str</span>
<span class="sd">        :param mdp: name of mdp file</span>
<span class="sd">        :type mdp: str</span>
<span class="sd">        :param mylogger: a logger, defaults to logger.debug</span>
<span class="sd">        :type mylogger: logging.logger, optional</span>
<span class="sd">        :return: any message generated by gromacs.grompp_and_mdrun</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wrap_coords</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wrap_coords&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grab_files</span><span class="p">()</span>
        <span class="c1"># make sure required files exist in this directory</span>
        <span class="n">top</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.top&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">gro</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.gro&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s1">.top&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">gro</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mdp</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
        <span class="n">mylogger</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;TopoCoord: running Gromacs </span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s1">.top, </span><span class="si">{</span><span class="n">gro</span><span class="si">}</span><span class="s1">.gro, </span><span class="si">{</span><span class="n">mdp</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">=</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">gro</span><span class="o">=</span><span class="n">gro</span><span class="p">,</span><span class="n">top</span><span class="o">=</span><span class="n">top</span><span class="p">,</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span><span class="n">mdp</span><span class="o">=</span><span class="n">mdp</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy_coords</span><span class="p">(</span><span class="n">TopoCoord</span><span class="p">(</span><span class="n">grofilename</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">.gro&#39;</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="n">wrap_coords</span><span class="p">))</span>
        <span class="n">mylogger</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;after grompp_and_run: gro </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s2">&quot;gro&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span></div>

<div class="viewcode-block" id="TopoCoord.load_files"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.load_files">[docs]</a>    <span class="k">def</span> <span class="nf">load_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filenames</span><span class="p">:</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;load_files load all gromacs files into TopoCoord</span>

<span class="sd">        :param filenames: dictionary of extension:filename</span>
<span class="sd">        :type filenames: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="n">filenames</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;gro&#39;</span><span class="p">,</span><span class="s1">&#39;top&#39;</span><span class="p">,</span><span class="s1">&#39;grx&#39;</span><span class="p">,</span><span class="s1">&#39;mol2&#39;</span><span class="p">]:</span> <span class="k">continue</span>
            <span class="n">bn</span><span class="p">,</span><span class="n">ext</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;bn </span><span class="si">{</span><span class="n">bn</span><span class="si">}</span><span class="s1"> ext </span><span class="si">{</span><span class="n">ext</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span>   <span class="n">ext</span><span class="o">==</span><span class="s1">&#39;.gro&#39;</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">read_gro</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ext</span><span class="o">==</span><span class="s1">&#39;.top&#39;</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">read_top</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ext</span><span class="o">==</span><span class="s1">&#39;.grx&#39;</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">read_gro_attributes</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ext</span><span class="o">==</span><span class="s1">&#39;.mol2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_mol2</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Warning: file </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> has unknown file extension.  Skipped.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.center_coords"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.center_coords">[docs]</a>    <span class="k">def</span> <span class="nf">center_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_boxsize</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;center_coords center all coordinates in box</span>

<span class="sd">        :param new_boxsize: new boxsize if desired, defaults to None</span>
<span class="sd">        :type new_boxsize: numpy.ndarray, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">new_boxsize</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_boxsize</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="n">box_vectors</span><span class="o">=</span><span class="n">new_boxsize</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">new_boxsize</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">box_vectors</span><span class="o">=</span><span class="n">new_boxsize</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">=</span><span class="n">box_vectors</span>
        <span class="n">center</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">gc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">geometric_center</span><span class="p">()</span>
        <span class="n">addme</span><span class="o">=</span><span class="n">center</span><span class="o">-</span><span class="n">gc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">addme</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopoCoord.vacuum_minimize"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.vacuum_minimize">[docs]</a>    <span class="k">def</span> <span class="nf">vacuum_minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;minimized&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;vacuum_minimize the minimize analog to grompp_and_mdrun; performs an energy minimization using mdrun</span>

<span class="sd">        :param outname: output file basename, defaults to &#39;minimized&#39;</span>
<span class="sd">        :type outname: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pad</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">boxsize</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxspan</span><span class="p">())</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maxspan</span><span class="p">()</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">boxsize</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_coords</span><span class="p">(</span><span class="n">new_boxsize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span>
        <span class="n">mdp_prefix</span><span class="o">=</span><span class="s1">&#39;single-molecule-min&#39;</span>
        <span class="n">pfs</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mdp/</span><span class="si">{</span><span class="n">mdp_prefix</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
        <span class="c1"># gromacs_dict={&#39;nt&#39;:1,&#39;nb&#39;:&#39;cpu&#39;,&#39;pme&#39;:&#39;cpu&#39;,&#39;pmefft&#39;:&#39;cpu&#39;,&#39;bonded&#39;:&#39;cpu&#39;,&#39;update&#39;:&#39;cpu&#39;}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="n">mdp</span><span class="o">=</span><span class="n">mdp_prefix</span><span class="p">,</span><span class="n">boxSize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">,</span><span class="n">single_molecule</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#,**gromacs_dict)</span></div>

<div class="viewcode-block" id="TopoCoord.vacuum_simulate"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.vacuum_simulate">[docs]</a>    <span class="k">def</span> <span class="nf">vacuum_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">outname</span><span class="o">=</span><span class="s1">&#39;simulated&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;vacuum_simulate peform a vacuum MD simulation using mdrun</span>

<span class="sd">        :param outname: output file basename, defaults to &#39;simulated&#39;</span>
<span class="sd">        :type outname: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pad</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pad&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">boxsize</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxspan</span><span class="p">())</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">maxspan</span><span class="p">()</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">boxsize</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_coords</span><span class="p">(</span><span class="n">new_boxsize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">)</span>
        <span class="n">mdp_prefix</span><span class="o">=</span><span class="s1">&#39;single-molecule-nvt&#39;</span>
        <span class="n">pfs</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mdp/</span><span class="si">{</span><span class="n">mdp_prefix</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
        <span class="n">nsamples</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nsamples&#39;</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">params</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;params&#39;</span><span class="p">,{})</span>
        <span class="n">T</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;temperature&#39;</span><span class="p">,</span><span class="mf">300.0</span><span class="p">)</span>
        <span class="n">ps</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ps&#39;</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">nsteps</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nsteps&#39;</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">begin_at</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;begin_at&#39;</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ps</span><span class="o">!=</span><span class="mf">0.0</span> <span class="ow">or</span> <span class="n">nsteps</span><span class="o">!=-</span><span class="mi">1</span>
        <span class="n">dt</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">mdp_get</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mdp_prefix</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">,</span><span class="s1">&#39;dt&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ps</span><span class="o">!=</span><span class="mf">0.0</span><span class="p">:</span>
            <span class="n">nsteps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ps</span><span class="o">=</span><span class="n">nsteps</span><span class="o">*</span><span class="n">dt</span>
        <span class="n">sampling_duration_ps</span><span class="o">=</span><span class="n">ps</span><span class="o">-</span><span class="n">begin_at</span>
        <span class="n">sampling_duration_nsteps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sampling_duration_ps</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">sample_interval</span><span class="o">=</span><span class="n">sampling_duration_nsteps</span><span class="o">//</span><span class="n">nsamples</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nsteps </span><span class="si">{</span><span class="n">nsteps</span><span class="si">}</span><span class="s1"> begin_at </span><span class="si">{</span><span class="n">begin_at</span><span class="si">}</span><span class="s1"> ps </span><span class="si">{</span><span class="n">ps</span><span class="si">}</span><span class="s1"> sampling_duration_ps </span><span class="si">{</span><span class="n">sampling_duration_ps</span><span class="si">}</span><span class="s1"> (</span><span class="si">{</span><span class="n">sampling_duration_nsteps</span><span class="si">}</span><span class="s1"> steps) sample_interval </span><span class="si">{</span><span class="n">sample_interval</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># nsteps=nsamples*(sample_interval+1)</span>
        <span class="c1"># nsteps=mdp_get(f&#39;{mdp_prefix}.mdp&#39;,&#39;nsteps&#39;)</span>
        <span class="c1"># nstxout=mdp_get(f&#39;{mdp_prefix}.mdp&#39;,&#39;nstxout&#39;)</span>
        <span class="n">mdp_modify</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">mdp_prefix</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">,{</span><span class="s1">&#39;nsteps&#39;</span><span class="p">:</span><span class="n">nsteps</span><span class="p">,</span><span class="s1">&#39;nstxout&#39;</span><span class="p">:</span><span class="n">sample_interval</span><span class="p">,</span><span class="s1">&#39;ref_t&#39;</span><span class="p">:</span><span class="n">T</span><span class="p">})</span>
        <span class="c1"># gromacs_dict={&#39;nt&#39;:1,&#39;nb&#39;:&#39;cpu&#39;,&#39;pme&#39;:&#39;cpu&#39;,&#39;pmefft&#39;:&#39;cpu&#39;,&#39;bonded&#39;:&#39;cpu&#39;,&#39;update&#39;:&#39;cpu&#39;}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">outname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="n">mdp</span><span class="o">=</span><span class="n">mdp_prefix</span><span class="p">,</span><span class="n">boxSize</span><span class="o">=</span><span class="n">boxsize</span><span class="p">,</span><span class="n">single_molecule</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">wrap_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#,**gromacs_dict)</span></div>

<div class="viewcode-block" id="TopoCoord.equilibrate"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.equilibrate">[docs]</a>    <span class="k">def</span> <span class="nf">equilibrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">deffnm</span><span class="o">=</span><span class="s1">&#39;equilibrate&#39;</span><span class="p">,</span><span class="n">edict</span><span class="o">=</span><span class="p">{},</span><span class="n">gromacs_dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;equilibrate perform an MD simulation using mdrun</span>

<span class="sd">        :param deffnm: output file basename, defaults to &#39;equilibrate&#39;</span>
<span class="sd">        :type deffnm: str, optional</span>
<span class="sd">        :param edict: dictionary of simulation directives, defaults to {}</span>
<span class="sd">        :type edict: dict, optional</span>
<span class="sd">        :param gromacs_dict: dictionary of gromacs directives, defaults to {}</span>
<span class="sd">        :type gromacs_dict: dict, optional</span>
<span class="sd">        :return: list of edr files this equilibration generates</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mod_dict</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">edr_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ens</span><span class="o">=</span><span class="n">edict</span><span class="p">[</span><span class="s1">&#39;ensemble&#39;</span><span class="p">]</span>
        <span class="n">repeat</span><span class="o">=</span><span class="n">edict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ens</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span><span class="s1">&#39;npt&#39;</span><span class="p">,</span><span class="s1">&#39;nvt&#39;</span><span class="p">],</span><span class="sa">f</span><span class="s1">&#39;Bad ensemble: </span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">pfs</span><span class="o">.</span><span class="n">checkout</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mdp/</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span> <span class="c1"># plain jane?</span>
        <span class="k">if</span> <span class="n">ens</span><span class="o">==</span><span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;minimization&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1"> ensemble&#39;</span>
        <span class="k">if</span> <span class="n">ens</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;nvt&#39;</span><span class="p">,</span><span class="s1">&#39;npt&#39;</span><span class="p">]:</span>
            <span class="n">dt</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">mdp_get</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">,</span><span class="s1">&#39;dt&#39;</span><span class="p">))</span>
            <span class="n">mod_dict</span><span class="p">[</span><span class="s1">&#39;ref_t&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">edict</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span>
            <span class="n">mod_dict</span><span class="p">[</span><span class="s1">&#39;gen-temp&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">edict</span><span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">]</span>
            <span class="n">mod_dict</span><span class="p">[</span><span class="s1">&#39;gen-vel&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;yes&#39;</span>
            <span class="n">nsteps</span><span class="o">=</span><span class="n">edict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nsteps&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nsteps</span><span class="p">:</span>
                <span class="n">ps</span><span class="o">=</span><span class="n">edict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ps&#39;</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ps</span><span class="p">:</span> <span class="k">return</span>
                <span class="n">nsteps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ps</span><span class="o">=</span><span class="n">nsteps</span><span class="o">*</span><span class="n">dt</span>
            <span class="n">mod_dict</span><span class="p">[</span><span class="s1">&#39;nsteps&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">nsteps</span>
            <span class="n">msg</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;; </span><span class="si">{</span><span class="n">ps</span><span class="si">:</span><span class="s1">6.2f</span><span class="si">}</span><span class="s1"> ps, </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">edict</span><span class="p">[</span><span class="s2">&quot;temperature&quot;</span><span class="p">])</span><span class="si">:</span><span class="s1">7.2f</span><span class="si">}</span><span class="s1"> K&#39;</span>
            <span class="k">if</span> <span class="n">ens</span><span class="o">==</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span> 
                <span class="n">mod_dict</span><span class="p">[</span><span class="s1">&#39;ref_p&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">edict</span><span class="p">[</span><span class="s1">&#39;pressure&#39;</span><span class="p">]</span>
                <span class="n">msg</span><span class="o">+=</span><span class="sa">f</span><span class="s1">&#39;, </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">edict</span><span class="p">[</span><span class="s2">&quot;pressure&quot;</span><span class="p">])</span><span class="si">:</span><span class="s1">6.2f</span><span class="si">}</span><span class="s1"> bar&#39;</span>
        <span class="n">new_mdp</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">deffnm</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">mdp_modify</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">,</span><span class="n">mod_dict</span><span class="p">,</span><span class="n">new_filename</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">new_mdp</span><span class="si">}</span><span class="s1">.mdp&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Running Gromacs: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">deffnm</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">mdp</span><span class="o">=</span><span class="n">new_mdp</span><span class="p">,</span><span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="n">edr_list</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">deffnm</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ens</span><span class="o">==</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span>
            <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Current box side lengths: </span><span class="si">{</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm x </span><span class="si">{</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm x </span><span class="si">{</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm&#39;</span><span class="p">)</span>
            <span class="n">gmx_energy_trace</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">deffnm</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,[</span><span class="s1">&#39;Density&#39;</span><span class="p">],</span><span class="n">report_averages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repeat</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Repeat </span><span class="si">{</span><span class="n">rep</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1"> out of </span><span class="si">{</span><span class="n">repeat</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">this_deffnm</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">deffnm</span><span class="si">}</span><span class="s1">-repeat-</span><span class="si">{</span><span class="n">rep</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">ens</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grompp_and_mdrun</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">this_deffnm</span><span class="p">,</span><span class="n">mdp</span><span class="o">=</span><span class="n">new_mdp</span><span class="p">,</span><span class="n">quiet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">gromacs_dict</span><span class="p">)</span>
            <span class="n">edr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_deffnm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ens</span><span class="o">==</span><span class="s1">&#39;npt&#39;</span><span class="p">:</span>
                <span class="n">box</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Current box side lengths: </span><span class="si">{</span><span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm x </span><span class="si">{</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm x </span><span class="si">{</span><span class="n">box</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> nm&#39;</span><span class="p">)</span>
            <span class="n">gmx_energy_trace</span><span class="p">(</span><span class="n">this_deffnm</span><span class="p">,[</span><span class="s1">&#39;Density&#39;</span><span class="p">],</span><span class="n">report_averages</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">gromacs_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edr_list</span></div>

<div class="viewcode-block" id="TopoCoord.get_resid_sets"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.get_resid_sets">[docs]</a>    <span class="k">def</span> <span class="nf">get_resid_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">atom_pair</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get_resid_sets identifies individual sets of separate resids owned by unbonded atoms i and j </span>

<span class="sd">        :param atom_pair: tuple of i,j atom indices</span>
<span class="sd">        :type atom_pair: tuple</span>
<span class="sd">        :return: tuple containing the two apposing residue sets</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assertion: i and j are not bonded and they represent two separate sets of residues in this topocoord.</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">atom_pair</span>
        <span class="n">ri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
        <span class="n">rj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_gro_attribute_by_attributes</span><span class="p">(</span><span class="s1">&#39;resNum&#39;</span><span class="p">,{</span><span class="s1">&#39;globalIdx&#39;</span><span class="p">:</span><span class="n">j</span><span class="p">})</span>
        <span class="n">ci</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">local_resid_cluster</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span>
        <span class="n">cj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">local_resid_cluster</span><span class="p">(</span><span class="n">rj</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">==</span><span class="nb">set</span><span class="p">(</span><span class="n">cj</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;resid sets overlap: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">ri</span><span class="si">}</span><span class="s1"> : </span><span class="si">{</span><span class="n">ci</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">rj</span><span class="si">}</span><span class="s1"> : </span><span class="si">{</span><span class="n">cj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ci</span><span class="p">,</span><span class="n">cj</span><span class="p">]</span></div>

<div class="viewcode-block" id="TopoCoord.check_your_topology"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.TopoCoord.check_your_topology">[docs]</a>    <span class="k">def</span> <span class="nf">check_your_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;check_your_topology checks topology for duplicate 1-4 pair interactions and deletes them</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">T</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Topology</span>
        <span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span>
        <span class="n">aT</span><span class="o">=</span><span class="p">{}</span>
        <span class="n">pdf</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span>
        <span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">checked</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">drops</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">pdf</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="o">=</span><span class="nb">min</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">]),</span><span class="nb">max</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span><span class="n">r</span><span class="o">.</span><span class="n">aj</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">ai</span><span class="o">!=</span><span class="n">aj</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">checked</span><span class="p">:</span> 
                <span class="n">checked</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ai</span><span class="p">,</span><span class="n">aj</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># print(f&#39;repeated pair {ai} {aj}&#39;)</span>
                <span class="n">drops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ri</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
            <span class="n">rj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_R</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
            <span class="n">D</span><span class="o">=</span><span class="n">C</span><span class="o">.</span><span class="n">mic</span><span class="p">(</span><span class="n">ri</span><span class="o">-</span><span class="n">rj</span><span class="p">,</span><span class="n">pbc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">],</span><span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">],</span><span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">D</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">drops</span><span class="p">)</span><span class="si">}</span><span class="s1"> duplicate pairs detected&#39;</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="s1">&#39;pairs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">pdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">drops</span><span class="p">)</span>
        <span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span>
        <span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span>
        <span class="n">pdf</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aT</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;dx&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;dy&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;dz&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_top</span><span class="p">(</span><span class="s1">&#39;checked.top&#39;</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="find_template"><a class="viewcode-back" href="../../HTPolyNetPackage.html#HTPolyNet.topocoord.find_template">[docs]</a><span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">BT</span><span class="p">:</span><span class="n">BondTemplate</span><span class="p">,</span><span class="n">moldict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;find_template searches the dictionary of available molecules to identify a bond template that matches the passed-in template, returning the corresponding template molecule and reaction-bond</span>

<span class="sd">    :param BT: bond template to search for</span>
<span class="sd">    :type BT: BondTemplate</span>
<span class="sd">    :param moldict: dictionary of available molecule</span>
<span class="sd">    :type moldict: MoleculeDict</span>
<span class="sd">    :raises Exception: if no matching template is found</span>
<span class="sd">    :return: template Molecule object, corresponding ReactionBond object from that template, and a boolean flag indicating whether or not the match required a symmetric-reversal of the template</span>
<span class="sd">    :rtype: tuple(Molecule,ReactionBond,bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">use_T</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">b_idx</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">reverse_bond</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">for</span> <span class="n">template_name</span><span class="p">,</span><span class="n">T</span> <span class="ow">in</span> <span class="n">moldict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># if BT in T.bond_templates:</span>
        <span class="c1">#     use_T=T</span>
        <span class="c1">#     break</span>
        <span class="n">use_T</span><span class="o">=</span><span class="kc">None</span>
        <span class="k">for</span> <span class="n">b_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">bond_templates</span><span class="p">)):</span>
            <span class="n">bt</span><span class="o">=</span><span class="n">T</span><span class="o">.</span><span class="n">bond_templates</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]</span>
            <span class="c1"># logger.debug(f&#39;comparing to {T.name} {str(bt)}&#39;)</span>
            <span class="k">if</span> <span class="n">bt</span><span class="o">==</span><span class="n">BT</span><span class="p">:</span>
                <span class="c1"># logger.debug(f&#39;TRUE&#39;)</span>
                <span class="n">use_T</span><span class="o">=</span><span class="n">T</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">bt</span><span class="o">.</span><span class="n">is_reverse_of</span><span class="p">(</span><span class="n">BT</span><span class="p">):</span>
                <span class="c1"># logger.debug(f&#39;TRUE, but...&#39;)</span>
                <span class="n">use_T</span><span class="o">=</span><span class="n">T</span>
                <span class="n">reverse_bond</span><span class="o">=</span><span class="kc">True</span>
                <span class="c1"># logger.debug(f&#39;reversed bond instance {str(RB)}&#39;)</span>
        <span class="k">if</span> <span class="n">use_T</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No template is found for </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">BT</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;you have a bond for which I cannot find a template&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using template </span><span class="si">{</span><span class="n">use_T</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> and bond index </span><span class="si">{</span><span class="n">b_idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">rb</span><span class="o">=</span><span class="n">use_T</span><span class="o">.</span><span class="n">reaction_bonds</span><span class="p">[</span><span class="n">b_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">use_T</span><span class="p">,</span><span class="n">rb</span><span class="p">,</span><span class="n">reverse_bond</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">HTPolyNet</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation and Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user-guide/index.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example-tutorials/index.html">Example Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/index.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../HTPolyNetPackage.html">HTPolyNet package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Cameron Abrams, Ming Huang.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>