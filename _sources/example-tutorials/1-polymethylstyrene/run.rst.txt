.. _pms_run:

Running the Build
=================

Now, in our working directory ``my_pms_build``, we are ready to launch HTPolyNet:

.. code-block:: console

    $ cd my_pms_build
    $ ls 
    pMSTY.yaml  lib/
    $ htpolynet run pMSTY.yaml -lib lib -log my_build.log --loglevel debug &
    [1]
    $ ls
    pMSTY.yaml  my_build.log  lib/  proj-0/
    $

HTPolyNet is instructed here to use the local ``./lib/`` as the molecule library; not including a value for ``-lib`` forces HTPolyNet to use the system library in the ``Library`` subpackage, and if you are making new molecules, they won't be there.  It is also instructive to write logging messages to ``my_build.log`` at the ``debug`` (most informative) level.  The build can take several minutes, so we are running it in the background.  All the action is happening in ``proj-0`` (and of course being reportedon in ``my_build.log``), so let's look in there.  

Parameterization results
^^^^^^^^^^^^^^^^^^^^^^^^

The first major block of calculations involves parameterizing all required molecular templates.  So after a few minutes, we can inspect the parameterization results while the build continues:

.. code-block:: console

    $ cd proj-0
    $ ls
    molecules/  plots/  systems/
    $ cd molecules/parameterized
    $ ls EMB.*
    EMB.edr     EMB.log   EMB.tpr
    EMB.frcmod  EMB.mol2  EMB.trr
    EMB.gro     EMB.sea
    EMB.itp     EMB.top
    $

What are we seeing here?  These are all the output files for generated by parameterization of the ``EMB`` residue defined in ``lib/molecules/inputs/EMB.mol2``.  six distinct template molecules, along with the EMB monomer.  Each set comprises four files:

1. ``mol2`` -- output of ``antechamber``
2. ``frcmod`` -- output of ``parmchk2``
3. ``gro/top/itp`` -- output of ``parmed`` (``gro`` is also output of Gromacs minimization)
4. ``sea`` -- custom output of HTPolyNet with symmetry info (not applicable here)
5. ``tpr/trr/edr`` -- files associated with a Gromacs-based energy minimization that produces an coordinate-optimized ``gro`` file.

We can see how many molecules have been parameterized:

.. code-block:: console

    $ ls *.gro 
    EMB1_1.gro  EMB2_1.gro  EMBCC.gro
    EMB1_2.gro  EMB2_2.gro  EMB.gro

So we have parameterized every reaction product, and this is a sufficient set of templates.

Liquid generation and densification
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

After a few more minutes, when the densification MD simulation has finished, let's back out of the ``molecules/parameterized/`` subdirectory and drop into ``systems/init/``:

.. code-block:: console

    $ cd ../../systems/init
    $ ls
    EMB.gro                 mdout.mdp
    gmx.in                  minimize.mdp
    init.gro                npt-1.cpt
    init.grx                npt-1-density.xvg
    init-minimized.edr      npt-1.edr
    init-minimized.gro      npt-1.gro
    init-minimized.log      npt-1.log
    init-minimized.tpr      npt-1-out.xvg
    init-minimized.trr      npt-1.tpr
    init.top                npt-1.trr
    liquid-densify-npt.mdp
    $

HTPolyNet creates ``init.top`` by merging 100 EMB topologies together and writes it.  ``init.gro`` is created using ``gmx insert-molecules`` using ``EMB.gro`` as input.  ``init.grx`` is created by HTPolyNet to store auxiliary atom attributes.  We can see the results of two ``mdrun`` invocations:

1. ``minimize.mdp`` and ``init-minimized.*`` -- this is just an initial energy minimization of the system; and
2. ``liquid-densify-npt.mdp`` and ``npt-1.*`` -- this is the densification MD simulation that runs until the density is equilibrated at the temperature and pressure specified in the ``mdp`` file.
3. Some ``xvg`` files are created by ``gmx energy``, which is controlled non-interactively using ``gmx.in``.  A plot of density vs. time is generated.

Let's go up out of ``systems/init`` and into ``plots/``:

.. code-block:: console

    $ cd ../../plots
    $ ls
    init-density.png

HTPolyNet automatically generates a plot of density vs. time for the densification simulation:

.. image:: init-density.png

We can see that we've successfully arrived at the liquid-like density of about 810 kg/m\ :sup:`3`. (The actual density is 860, so we are a bit low.)

The first CURE iteration
^^^^^^^^^^^^^^^^^^^^^^^^

The next major part of the build is the first CURE iteration, which is the most expensive because the pair searching is most demanding when the number of reactive atoms is maximal.  So let's back out of ``plots`` and drop into ``systems/iter-1``.  When the iteration completes, there are a _lot_ of files generated.  They can be divided into five "phases" for each CURE iteration:

0. Bond search
1. Dragging
2. Topology update
3. Relaxation
4. Equilibration

Names of files corresponding to phases 0-4 all begin with their respective digits.  Names of files that do not begin with a digit are "auxiliary".  Let's consider the files in the seven states.

Bondsearch files
----------------

Files associated with the bondsearch begin with ``0``:

.. code-block:: console

    $ ls -1 0-*
    0-bondsearch-bonds.csv
    0-bondsearch.gro
    0-bondsearch.grx
    0-bondsearch-input.gro
    0-bondsearch.top

The ``gro`` and ``top`` files are sufficient Gromacs input.  The ``grx`` file contains values of four extra attributes for each atom:

.. code-block:: console

    $ head 0-bondsearch.grx
    globalIdx  z  cycle-idx reactantName  nreactions
            1  0          1          EMB           0
            2  0          1          EMB           0
            3  0          1          EMB           0
            4  0          0          EMB           0
            5  0          1          EMB           0
            6  0          1          EMB           0
            7  0          1          EMB           0
            8  1          0          EMB           0
            9  1          0          EMB           0


``globalIdx`` corresponds to the ``nr`` attribute in the ``[ atoms ]`` directive of a ``top`` file, or the ``atomNum`` attribute of a ``gro`` file; it is just the global atom index.  ``z`` is the current value of the number of available crosslink bonds for that atom.  ``cycle-idx`` are unique indices indicated which ring the atom belongs to; rings are labeled uniquely within a residue.  ``reactantName`` is initialized as the residue name the atom belongs to.  However, as we will see, this attribute is key for communicating which product template maps onto a set of particular residues that react.  Finally, ``nreactions`` simply reports the number of times this atom has participated in a reaction.

The ``csv`` file is a dump of the bonds "DataFrame":

.. code-block:: console

    $ head 0-bondsearch-bonds.csv 
    ai aj reactantName order initial-distance
    239 2025 EMB1_1 1 0.3540478556636094
    953 975 EMB1_1 1 0.3623175402875217
    29 1794 EMB1_1 1 0.3648054275912023
    1037 1962 EMB1_1 1 0.3691002573827334
    1835 2088 EMB1_1 1 0.37332157719585396
    386 1269 EMB1_1 1 0.3767585433669687
    512 30 EMB1_1 1 0.3765328670913073
    1331 1941 EMB1_1 1 0.3772466886534595
    134 1206 EMB1_1 1 0.381443311646698

The first two columns are pre-bond global atom indices for each bond-designate; the third column is the name of the product molecule template of the reaction type that forms this bond, and the fourth column is the instantaneous interatomic distance in nm.  This is the first real output of the bond search.  Later, in the "connect" stage, atoms listed here will inherit their ``reactantName`` from this structure.

Dragging files
--------------

Files associated with prebond dragging begin with ``1``.  However, because no bond-designate length exceeded 0.5 nm, no dragging is triggered.  So the build proceeds to topology update.

Topology update files
---------------------

Files associated with the topology update process begin with a ``2``:

.. code-block:: console

    $ ls -1 2*
    2-update-complete-bonds.csv
    2-update-complete.gro
    2-update-complete.grx
    2-update-complete.top
    2-update-idx-mapper.dat
    2-update-resid-graph.json

All files here represent **outputs** of the topology update.  Let's look at the ``2-update-idx-mapper.dat``:

.. code-block:: console

    $ tail 2-update-idx-mapper.dat 
    2089 1977
    2090 1978
    2091 1979
    2092 1980
    2093 1981
    2094 1982
    2095 1983
    2096 1984
    2098 1985
    2099 1986

The purpose of this file is very simple:  The first column are atom indices **before** topology update, and the second column are indices **after** topology update.  Remember that topology updating deletes sacrificial hydrogens, which means atoms are reindexed (since Gromacs requires sequential atom indexes).  This file allows us to match any atoms in pre-update ``gro`` and ``top`` files to those that exist downstream of a topology update.  Note that I've chosen to show a ``tail`` of this file to highlight the largest index differences.  The post-update indexes also appear in the ``csv`` file showing all bonds.

The file ``2-update-complete-bonds.csv`` is just the initial ``0-bondsearch-bonds.csv``, except all the atom indexes have been updated according to the index mapper described above.  The last line in this file reports the new bond with the longest initial length:

.. code-block:: console

    $ tail -1 2-update-complete-bonds.csv
    1033 581 EMB1_1 1 0.4951201874292745

Again, the ``gro`` and ``top`` are proper Gromacs inputs, and the ``grx`` file tabulates all ``z``, ``cycle-idx``, ``reactantName``, and ``nreactions`` attributes.  The ``json`` file represents the graph structure of the network on a resid basis in JSON format.

Relaxation files
----------------

Files that begin with a ``3`` correspond to bond relaxation stages.  In this example, six stages are run by virture of the bond-designate with the longest bond length (0.499 nm) and the ``relax_increment`` of 0.075 nm.  Each stage produces 22 output files: the bonds ``csv``, the ``gro`` / ``grx`` / ``top`` that initializes the first stage, and then the 17 **outputs** from the minimization (5), nvt (6), and npt (6) sub-stages:

.. code-block:: console

    $ ls 3-*
    3-relax-stage-1-bonds.csv
    3-relax-stage-1.gro
    3-relax-stage-1.grx
    3-relax-stage-1-min.edr
    3-relax-stage-1-min.gro
    3-relax-stage-1-min.log
    3-relax-stage-1-min.tpr
    3-relax-stage-1-min.trr
    3-relax-stage-1-npt.cpt
    3-relax-stage-1-npt.edr
    3-relax-stage-1-npt.gro
    3-relax-stage-1-npt.log
    3-relax-stage-1-npt.tpr
    3-relax-stage-1-npt.trr
    3-relax-stage-1-nvt.cpt
    3-relax-stage-1-nvt.edr
    3-relax-stage-1-nvt.gro
    3-relax-stage-1-nvt.log
    3-relax-stage-1-nvt.tpr
    3-relax-stage-1-nvt.trr
    3-relax-stage-1.top
    ...
    3-relax-stage-6-bonds.csv
    3-relax-stage-6.gro
    3-relax-stage-6.grx
    3-relax-stage-6-min.edr
    3-relax-stage-6-min.gro
    3-relax-stage-6-min.log
    3-relax-stage-6-min.tpr
    3-relax-stage-6-min.trr
    3-relax-stage-6-npt.cpt
    3-relax-stage-6-npt.edr
    3-relax-stage-6-npt.gro
    3-relax-stage-6-npt.log
    3-relax-stage-6-npt.tpr
    3-relax-stage-6-npt.trr
    3-relax-stage-6-nvt.cpt
    3-relax-stage-6-nvt.edr
    3-relax-stage-6-nvt.gro
    3-relax-stage-6-nvt.log
    3-relax-stage-6-nvt.tpr
    3-relax-stage-6-nvt.trr
    3-relax-stage-6.top

The attenuation is managed by the sequential ``top`` files.  Let's look at the entry for a particular bond (between atoms 581 and 1033) in each stage's ``top`` file's ``[ bonds ]`` directive:

.. code-block:: console

    $ grep "^581 1033" 3-relax-stage-?.top|awk '{if ($3==1) print $0}'
    3-relax-stage-1.top:581 1033 1 0.43822515619106206 41965.52
    3-relax-stage-2.top:581 1033 1 0.3813301249528497 83931.04
    3-relax-stage-3.top:581 1033 1 0.32443509371463725 125896.56
    3-relax-stage-4.top:581 1033 1 0.2675400624764248 167862.08
    3-relax-stage-5.top:581 1033 1 0.21064503123821238 209827.6
    3-relax-stage-6.top:581 1033 1 0.15375 251793.12
    $

In a ``[ bonds ]`` topology directive, the 4th and 5th columns are ``b0`` and ``kt`` harmonic bond parameters.  In the stage-6 ``top``, we see these parameters at their proper force-field values for a C-C single bond.  Notice how the value of the distance parameter ``b0`` begins at a large initial value and linearly decreases toward the target (but never by *more* than an increment of 0.075 nm), while the spring constant ``kt`` starts low and increases linearly toward its target.  

Equilibration files
-------------------

Files associated with final equilibration of the bonded system at the end of one CURE iteration begin with a ``4``:

.. code-block:: console

    $ ls 4-*
    4-equilibrate-bonds.csv
    4-equilibrate-complete-bonds.csv
    4-equilibrate-complete.gro
    4-equilibrate-complete.grx
    4-equilibrate-complete.top
    4-equilibrate.gro
    4-equilibrate.grx
    4-equilibrate.mdp
    4-equilibrate-post.cpt
    4-equilibrate-post.edr
    4-equilibrate-post.gro
    4-equilibrate-post.log
    4-equilibrate-post.tpr
    4-equilibrate-post.trr
    4-equilibrate.top

Files with the simple prefix ``4-equilibrate`` represent inputs to the Gromacs run.  Files with the prefixs ``4-equilibrate-post`` are the raw Gromacs mdrun outputs, and the files with the prefix ``4-equilibrate-complete`` represent the Gromacs outputs read back in to HTPolyNet and processed.  This set of ``complete`` files are copied to the next CURE iteration directory as the set of ``0-connect`` files.

Subsequent CURE iterations
^^^^^^^^^^^^^^^^^^^^^^^^^^

The primary result of a CURE iteration is the calculated conversion, or the fraction of the maximum number of crosslink bonds possible, based on the initial composition and reaction stoichiometries, that have formed up to that point. If this fraction is below the value associated with the ``CURE_desired_conversion`` option, then a new iteration is begun.  This involves creating the next ``iter-n/`` directory under ``systems/``, and copying over the prior iteration's ``4-equilibrate-complete.top/gro/grx`` files onto the new ``0-bondsearch.top/gro/grx`` files.  At the beginning of any CURE iterations, the maximum number of new bonds required to reach the desired conversion is calculated and used as a limit in creating new bonds, so that the desired conversion is hit exactly.  

The number of CURE iterations needed to reach a specified conversion is never deterministic because of the randomness inherent in the inter-stage and post-bonding MD simulations.  In this particular instance, a total of 9 CURE iterations were required to reach 0.95 conversion.  Files for each iteration's directory follow the same naming convention explained for the first iteration.

Post-cure reactions, equilibration, and finalization
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

After iteration 9, when the conversion specification is satisfied, HTPolyNet progresses to the post-cure stage.  The directory ``systems/postcure`` is created and the final outputs from the last CURE iterations are copied here.  If there were any monomers that had not yet reacted (here there are not), then the EMBCC reaction would be used to revert them back to double bonds, followed by an equilibration. After the equilibration, HTPolyNet generates the final files ``7-final.top/gro/grx``. 
    

